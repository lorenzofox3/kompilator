{"version":3,"file":"index.js","sources":["../../../../node_modules/zora/dist/zora.es.js","../../src/tokens.js","../../src/source.js","../../src/chars.js","../../src/utils.js","../../src/scanners.js","../comments.js","../identifiers.js","../punctuators.js","../numerics.js","../regexps.js","../strings.js","../whitespaces.js","../lineTerminators.js","../scanner.js","../templates.js","../../src/index.js","../selfTokenizer.js","../index.js"],"sourcesContent":["function createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar keys = createCommonjsModule(function (module, exports) {\nexports = module.exports = typeof Object.keys === 'function'\n  ? Object.keys : shim;\n\nexports.shim = shim;\nfunction shim (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n});\n\nvar is_arguments = createCommonjsModule(function (module, exports) {\nvar supportsArgumentsClass = (function(){\n  return Object.prototype.toString.call(arguments)\n})() == '[object Arguments]';\n\nexports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\nexports.supported = supported;\nfunction supported(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nexports.unsupported = unsupported;\nfunction unsupported(object){\n  return object &&\n    typeof object == 'object' &&\n    typeof object.length == 'number' &&\n    Object.prototype.hasOwnProperty.call(object, 'callee') &&\n    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||\n    false;\n}\n});\n\nvar index = createCommonjsModule(function (module) {\nvar pSlice = Array.prototype.slice;\n\n\n\nvar deepEqual = module.exports = function (actual, expected, opts) {\n  if (!opts) opts = {};\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return opts.strict ? actual === expected : actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected, opts);\n  }\n};\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer (x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') return false;\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (is_arguments(a)) {\n    if (!is_arguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b, opts);\n  }\n  if (isBuffer(a)) {\n    if (!isBuffer(b)) {\n      return false;\n    }\n    if (a.length !== b.length) return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  try {\n    var ka = keys(a),\n        kb = keys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n});\n\nvar assert = (collect) => {\n  const insertAssertionHook = (fn) => (...args) => {\n    const assertResult = fn(...args);\n    collect(assertResult);\n    return assertResult;\n  };\n\n  return {\n    ok: insertAssertionHook((val, message = 'should be truthy') => ({\n      pass: Boolean(val),\n      expected: 'truthy',\n      actual: val,\n      operator: 'ok',\n      message\n    })),\n    deepEqual: insertAssertionHook((actual, expected, message = 'should be equivalent') => ({\n      pass: index(actual, expected),\n      actual,\n      expected,\n      message,\n      operator: 'deepEqual'\n    })),\n    equal: insertAssertionHook((actual, expected, message = 'should be equal') => ({\n      pass: actual === expected,\n      actual,\n      expected,\n      message,\n      operator: 'equal'\n    })),\n    notOk: insertAssertionHook((val, message = 'should not be truthy') => ({\n      pass: !Boolean(val),\n      expected: 'falsy',\n      actual: val,\n      operator: 'notOk',\n      message\n    })),\n    notDeepEqual: insertAssertionHook((actual, expected, message = 'should not be equivalent') => ({\n      pass: !index(actual, expected),\n      actual,\n      expected,\n      message,\n      operator: 'notDeepEqual'\n    })),\n    notEqual: insertAssertionHook((actual, expected, message = 'should not be equal') => ({\n      pass: actual !== expected,\n      actual,\n      expected,\n      message,\n      operator: 'notEqual'\n    })),\n    throws: insertAssertionHook((func, expected, message) => {\n      let caught, pass, actual;\n      if (typeof expected === 'string') {\n        [expected, message] = [message, expected];\n      }\n      try {\n        func();\n      } catch (error) {\n        caught = {error};\n      }\n      pass = caught !== undefined;\n      actual = caught && caught.error;\n      if (expected instanceof RegExp) {\n        pass = expected.test(actual) || expected.test(actual && actual.message);\n        expected = String(expected);\n      } else if (typeof expected === 'function' && caught) {\n        pass = actual instanceof expected;\n        actual = actual.constructor;\n      }\n      return {\n        pass,\n        expected,\n        actual,\n        operator: 'throws',\n        message: message || 'should throw'\n      };\n    }),\n    doesNotThrow: insertAssertionHook((func, expected, message) => {\n      let caught;\n      if (typeof expected === 'string') {\n        [expected, message] = [message, expected];\n      }\n      try {\n        func();\n      } catch (error) {\n        caught = {error};\n      }\n      return {\n        pass: caught === undefined,\n        expected: 'no thrown error',\n        actual: caught && caught.error,\n        operator: 'doesNotThrow',\n        message: message || 'should not throw'\n      };\n    }),\n    fail: insertAssertionHook((reason = 'fail called') => ({\n      pass: false,\n      actual: 'fail called',\n      expected: 'fail not called',\n      message: reason,\n      operator: 'fail'\n    }))\n  };\n};\n\nvar test = ({description, spec, only = false} = {}) => {\n  const assertions = [];\n  const collect = (...args) => assertions.push(...args.map(a => Object.assign({description}, a)));\n\n  const instance = {\n    run(){\n      const now = Date.now();\n      return Promise.resolve(spec(assert(collect)))\n        .then(() => ({assertions, executionTime: Date.now() - now}));\n    }\n  };\n\n  Object.defineProperties(instance, {\n    only: {value: only},\n    assertions: {value: assertions},\n    length: {\n      get(){\n        return assertions.length\n      }\n    },\n    description: {value: description}\n  });\n\n  return instance;\n};\n\nconst tapOut = ({pass, message, index}) => {\n  const status = pass === true ? 'ok' : 'not ok';\n  console.log([status, index, message].join(' '));\n};\n\nconst canExit = () => {\n  return typeof process !== 'undefined' && typeof process.exit === 'function';\n};\n\nvar tap = () => function * () {\n  let index = 1;\n  let lastId = 0;\n  let success = 0;\n  let failure = 0;\n\n  const starTime = Date.now();\n  console.log('TAP version 13');\n  try {\n    while (true) {\n      const assertion = yield;\n      if (assertion.pass === true) {\n        success++;\n      } else {\n        failure++;\n      }\n      assertion.index = index;\n      if (assertion.id !== lastId) {\n        console.log(`# ${assertion.description} - ${assertion.executionTime}ms`);\n        lastId = assertion.id;\n      }\n      tapOut(assertion);\n      if (assertion.pass !== true) {\n        console.log(`  ---\n  operator: ${assertion.operator}\n  expected: ${JSON.stringify(assertion.expected)}\n  actual: ${JSON.stringify(assertion.actual)}\n  ...`);\n      }\n      index++;\n    }\n  } catch (e) {\n    console.log('Bail out! unhandled exception');\n    console.log(e);\n    if (canExit()) {\n      process.exit(1);\n    }\n  }\n  finally {\n    const execution = Date.now() - starTime;\n    if (index > 1) {\n      console.log(`\n1..${index - 1}\n# duration ${execution}ms\n# success ${success}\n# failure ${failure}`);\n    }\n    if (failure && canExit()) {\n      process.exit(1);\n    }\n  }\n};\n\nvar plan = () => {\n  const tests = [];\n  const instance = {\n    test(description, spec, opts = {}){\n      if (!spec && description.test) {\n        //this is a plan\n        tests.push(...description);\n      } else {\n        const testItems = (description, spec) => (!spec && description.test) ? [...description] : [{description, spec}];\n        tests.push(...testItems(description, spec).map(t => test(Object.assign(t, opts))));\n      }\n      return instance;\n    },\n    only(description, spec, opts = {}){\n      return instance.test(description, spec, Object.assign(opts, {only: true}));\n    },\n    async run(sink = tap()){\n      const sinkIterator = sink();\n      const hasOnly = tests.some(t => t.only);\n      const runnable = hasOnly ? tests.filter(t => t.only) : tests;\n      let id = 1;\n      sinkIterator.next();\n      try {\n        const results = runnable.map(t => t.run());\n        for (let r of results) {\n          const {assertions, executionTime} = await r;\n          for (let assert of assertions) {\n            sinkIterator.next(Object.assign(assert, {id, executionTime}));\n          }\n          id++;\n        }\n      }\n      catch (e) {\n        sinkIterator.throw(e);\n      } finally {\n        sinkIterator.return();\n      }\n    },\n    [Symbol.iterator](){\n      return tests[Symbol.iterator]();\n    }\n  };\n\n  Object.defineProperties(instance, {\n    tests: {value: tests},\n    length: {\n      get(){\n        return tests.length\n      }\n    }\n  });\n\n  return instance;\n};\n\nexport default plan;\n","export const categories = {\n  WhiteSpace: 0,\n  LineTerminator: 1,\n  SingleLineComment: 2,\n  MultiLineComment: 3,\n  Punctuator: 4,\n  Identifier: 5,\n  NumericLiteral: 6,\n  StringLiteral: 7,\n  RegularExpressionLiteral: 8,\n  Template: 9,\n  TemplateHead: 10,\n  TemplateMiddle: 11,\n  TemplateTail: 12\n};\n\n//defined as keywords\n//todo check async, let ?\nconst keywords = 'await break case catch class const continue debugger default delete do else export extends finally for function if import in instanceof new return super switch this throw try typeof var void while with yield'.split(' ');\nconst futureReservedKeyword = ['enum'];\nconst reservedKeywords = keywords.concat(futureReservedKeyword, ['null', 'true', 'false']);\n\n//defined as punctuators\nexport const puncutators = `{ ( ) [ ] . ... ; , < > <= >= == != === !== + - * % ** ++ -- << >> >>> & | ^ ! ~ && || ? : = += -= *= %= **= <<= >>= >>>= &= |= ^= => / /= }`.split(' ');\n\nexport const allowRegexpAfter = 'case delete do else in instanceof new return throw typeof void { ( [ . ; , < > <= >= == != === !== + - * << >> >>> & | ^ ! ~ && || ? : = += -= *= %= <<= >>= >>>= &= |= ^= /='.split(' ');\n\nconst createLanguageToken = (symbol, value) => {\n  return Object.freeze(Object.assign(Object.create(null, {\n    type: {\n      get () {\n        return this; //type is an alias to itself (so we can use in Maps as we would to for other categories such literals, etc)\n      }\n    }\n  }), {\n    value: value !== void  0 ? value : symbol,\n    rawValue: symbol,\n    isReserved: reservedKeywords.includes(symbol)\n  }));\n};\n\n//create a token table\nexport const tokenRegistry = () => {\n  const ecmaScriptTokens = puncutators.concat(keywords, futureReservedKeyword)\n    .map(symbol => ([symbol, createLanguageToken(symbol)]));\n  ecmaScriptTokens.push(['null', createLanguageToken('null', null)]);\n  ecmaScriptTokens.push(['true', createLanguageToken('true', true)]);\n  ecmaScriptTokens.push(['false', createLanguageToken('false', false)]);\n  ecmaScriptTokens.push(['of', createLanguageToken('of')]);\n\n  const tokenMap = new Map(ecmaScriptTokens);\n\n  return {\n    get (key) {\n      return tokenMap.get(key)\n    },\n    evaluate (lexeme) {\n      if (!tokenMap.has(lexeme.rawValue)) {\n        switch (lexeme.type) {\n          case categories.StringLiteral:\n            return Object.assign(lexeme, {\n              value: lexeme.rawValue.substr(1, lexeme.rawValue.length - 2),\n              isReserved: false\n            });\n          case categories.NumericLiteral:\n            return Object.assign(lexeme, {value: Number(lexeme.rawValue), isReserved: false});\n          case categories.RegularExpressionLiteral:\n            return Object.assign(lexeme, {isReserved: false, value: new RegExp(lexeme.pattern, lexeme.flags)});\n          default:\n            return Object.assign(lexeme, {isReserved: false, value: lexeme.rawValue});\n        }\n      }\n      return tokenMap.get(lexeme.rawValue);\n    },\n    addToken () {\n      throw new Error('not implemented');\n    }\n  }\n};\n\nexport default tokenRegistry();","//todo put track loc as an option ?\nexport const sourceStream = (code) => {\n  const lineTerminatorRegexp = /[\\u000a\\u000d\\u2028\\u2029]/g;\n  let index = 0;\n  let col = 0;\n  let line = 1;\n\n  const test = (regexp) => nextStretch().search(regexp) === 0;\n  const nextSubStr = (count = 1) => code.substr(index, count);\n  const seeNextAt = (offset = 0) => code[index + offset];\n  const nextStretch = () => nextSubStr(3); //we need three chars to be really sure of the current lexical production (0x3...)\n  const loc = () => ({col, line});\n\n  const advance = (number = 1) => {\n    let lastLineIndex = 0;\n    // console.log(`col: ${col}`);\n    // console.log(`line: ${line}`);\n    const stretch = nextSubStr(number);\n    // console.log(`symbols: ${stretch}`);\n    // console.log('-------')\n    while (lineTerminatorRegexp.test(stretch)) {\n      line += 1;\n      col = 0;\n      lastLineIndex = lineTerminatorRegexp.lastIndex;\n    }\n    col += (number - lastLineIndex);\n    index += number;\n  };\n\n  const stream = {\n    loc,\n    test,\n    nextSubStr,\n    seeNextAt,\n    //advance stream\n    match (regexp) {\n      regexp.lastIndex = index;\n      const [rawValue] = regexp.exec(code);\n      advance(rawValue.length);\n      return rawValue;\n    },\n    //advance stream\n    read (length) {\n      const s = this.nextSubStr(length);\n      advance(length);\n      return s;\n    }\n  };\n\n  Object.defineProperty(stream, 'done', {\n    get () {\n      return code[index] === void 0;\n    }\n  });\n  Object.defineProperty(stream, 'index', {\n    get () {\n      return index;\n    }\n  });\n\n  return stream;\n};","export const CHAR_STAR = '*';\nexport const CHAR_SLASH = '/';\nexport const MULTI_LINE_COMMENT_START = '/*';\nexport const SINGLE_LINE_COMMENT_START = '//';\nexport const CHAR_BACKSLASH = '\\\\';\nexport const CHAR_SINGLE_QUOTE = \"'\";\nexport const CHAR_DOUBLE_QUOTE = '\"';\nexport const CHAR_LEFT_BRACKET = '[';\nexport const CHAR_RIGHT_BRACKET = ']';\nexport const CHAR_DOT = '.';\nexport const SPREAD = '...';\nexport const CHAR_TEMPLATE_QUOTE = '`';\nexport const CHAR_DOLLAR = '$';\nexport const CHAR_BRACE_OPEN = '{';\nexport const CHAR_BRACE_CLOSE = '}';","export const lazyMapWith = (fn) => function* (iterator) {\n  for (let i of iterator) {\n    yield fn(i);\n  }\n};\n\nexport const lazyFilterWith = fn => function* (iterator) {\n  for (let i of iterator) {\n    if (fn(i)) {\n      yield i;\n    }\n  }\n};\n\nexport const syntacticFlags = {\n  allowRegexp: 1 << 0,\n  allowRightBrace: 1 << 1\n};","import {\n  categories,\n  puncutators\n} from \"./tokens\";\nimport * as chars from \"./chars\";\nimport {syntacticFlags} from \"./utils\";\n\nconst lexemeFromRegExp = (regExp, category) => sourceStream => ({type: category, rawValue: sourceStream.match(regExp)});\nconst testFromRegExp = regExp => sourceStream => sourceStream.test(regExp);\nconst productionFromRegexp = ({test, lexeme, category}) => () => {\n  //we create regexp dynamically so they are not global to every instance of the scanner\n  const testRegexp = new RegExp(test);\n  const lexemeRegexp = new RegExp(lexeme, 'y');\n  return {\n    test: testFromRegExp(testRegexp),\n    lexeme: lexemeFromRegExp(lexemeRegexp, category)\n  }\n};\n\nexport const numbers = productionFromRegexp({\n  category: categories.NumericLiteral,\n  test: `^(?:[1-9]|\\\\.\\\\d|0[1-9]?|0[xX][0-9a-fA-F]|0[bB][01]|0[oO][0-7])`,\n  lexeme: `0[xX][0-9a-fA-F]+|0[bB][01]+|0[oO][0-7]+|(?:(?:\\\\d+(?:\\\\.\\\\d*)?|\\\\.\\\\d+)(?:[eE][-+]?\\\\d+)?)`\n});\n\nexport const identifiers = productionFromRegexp({\n  category: categories.Identifier,\n  test: `^[$_a-zA-Z]`,\n  lexeme: `[$_a-zA-Z][$\\\\w]*`\n});\n\nexport const whiteSpace = productionFromRegexp({\n  category: categories.WhiteSpace,\n  test: `^(?:[\\\\u0009\\\\u000b\\\\u000c\\\\u0020\\\\u00a0\\\\ufeff])`,\n  lexeme: `[\\\\u0009\\\\u000b\\\\u000c\\\\u0020\\\\u00a0\\\\ufeff]+`\n});\n\nexport const lineTerminator = productionFromRegexp({\n  category: categories.LineTerminator,\n  test: `^(?:[\\\\u000a\\\\u000d\\\\u2028\\\\u2029])`,\n  lexeme: `[\\\\u000a\\\\u000d\\\\u2028\\\\u2029]+`\n});\n\nexport const singleLineComment = () => {\n  const lexemeRegExp = /\\/\\/.*/y;\n  return {\n    test: (sourceStream) => sourceStream.nextSubStr(2) === chars.SINGLE_LINE_COMMENT_START,\n    lexeme: lexemeFromRegExp(lexemeRegExp, categories.SingleLineComment)\n  };\n};\n\nexport const multiLineComment = () => {\n  const lexeme = (sourceStream, count = 2) => {\n    const next = sourceStream.seeNextAt(count);\n    count++;\n    if (next === chars.CHAR_STAR) {\n      const secondNext = sourceStream.seeNextAt(count);\n      if (secondNext === chars.CHAR_SLASH) {\n        return {\n          type: categories.MultiLineComment,\n          rawValue: sourceStream.read(count + 1)\n        }\n      }\n    }\n    return lexeme(sourceStream, count);\n  };\n  return {\n    test (sourceStream) {\n      return sourceStream.nextSubStr(2) === chars.MULTI_LINE_COMMENT_START;\n    },\n    lexeme\n  };\n};\n\nconst fromQuote = quote => {\n  const fn = (sourceStream, count = 1) => {\n    const next = sourceStream.seeNextAt(count);\n    count += 1;\n    if (next === quote) {\n      return {\n        type: categories.StringLiteral,\n        rawValue: sourceStream.read(count)\n      };\n    }\n    if (next === chars.CHAR_BACKSLASH) {\n      count += 1;\n    }\n    return fn(sourceStream, count);\n  };\n  return fn;\n};\nexport const stringLiteral = () => {\n  const singleQuote = fromQuote(chars.CHAR_SINGLE_QUOTE);\n  const doubleQuote = fromQuote(chars.CHAR_DOUBLE_QUOTE);\n  return {\n    test (sourceStream) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_SINGLE_QUOTE || next === chars.CHAR_DOUBLE_QUOTE;\n    },\n    lexeme (sourceStream) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_DOUBLE_QUOTE ? doubleQuote(sourceStream) : singleQuote(sourceStream);\n    }\n  };\n};\n\nexport const punctuators = (punctuatorList = puncutators) => {\n\n  const sizeOnePunctuatorList = punctuatorList.filter(p => p.length === 1);\n  const sizeTwoPunctuatorList = punctuatorList.filter(p => p.length === 2);\n  const sizeThreePunctuatorList = punctuatorList.filter(p => p.length === 3);\n  const sizeFourPunctuatorList = punctuatorList.filter(p => p.length === 4);\n\n  //micro optimization (this function will run often)\n  const isInPunctuatorList = (str) => {\n    switch (str.length) {\n      case 2:\n        return sizeTwoPunctuatorList.includes(str);\n      case 3:\n        return sizeThreePunctuatorList.includes(str);\n      case 4:\n        return sizeFourPunctuatorList.includes(str);\n      default:\n        return false;\n    }\n  };\n  const lexeme = (sourceStream, count = 1) => {\n    const nextStretch = sourceStream.nextSubStr(count + 1);\n    if (!isInPunctuatorList(nextStretch) || nextStretch.length !== count + 1 /*End of file */) {\n      return {\n        type: categories.Punctuator,\n        rawValue: sourceStream.read(count)\n      };\n    }\n    return lexeme(sourceStream, count + 1);\n  };\n  const lexemeFromDot = sourceStream => ({\n    type: categories.Punctuator,\n    rawValue: (sourceStream.nextSubStr(3) === chars.SPREAD) ? sourceStream.read(3) : sourceStream.read(1)\n  });\n  return {\n    test (sourceStream, context) {\n      const next = sourceStream.seeNextAt();\n      switch (next) {\n        case chars.CHAR_SLASH:\n          return ~context & syntacticFlags.allowRegexp;\n        case chars.CHAR_BRACE_CLOSE:\n          return context & syntacticFlags.allowRightBrace;\n        default:\n          return sizeOnePunctuatorList.includes(next);\n      }\n    },\n    lexeme: sourceStream => sourceStream.seeNextAt() === chars.CHAR_DOT ? lexemeFromDot(sourceStream) : lexeme(sourceStream)\n  };\n};\n\nconst scanRegExpBody = (sourceStream, count = 1) => {\n  const next = sourceStream.seeNextAt(count);\n  count += 1;\n  switch (next) {\n    case chars.CHAR_SLASH:\n      return count;\n    case chars.CHAR_LEFT_BRACKET: {\n      // slash are \"escaped\" in a regexp class\n      count = scanRegExpClass(sourceStream, count);//+1\n      break;\n    }\n    case chars.CHAR_BACKSLASH: {\n      count += 1;\n      break;\n    }\n  }\n  return scanRegExpBody(sourceStream, count);\n};\nconst scanRegExpClass = (sourceStream, count) => {\n  const next = sourceStream.seeNextAt(count);\n  count += 1;\n  switch (next) {\n    case chars.CHAR_RIGHT_BRACKET:\n      return count;\n    case chars.CHAR_BACKSLASH:\n      count += 1\n  }\n  return scanRegExpClass(sourceStream, count);\n};\n\nconst identifierPart = /[$\\w]/;\nconst scanRegExpFlags = (sourceStream, count) => {\n  const next = sourceStream.seeNextAt(count);\n  if (!next || !identifierPart.test(next)) {\n    return count;\n  }\n  return scanRegExpFlags(sourceStream, count + 1);\n};\n\nexport const regularExpression = () => {\n  return {\n    test (sourceStream, context) {\n      const next = sourceStream.seeNextAt();\n      return (context & syntacticFlags.allowRegexp) && next === chars.CHAR_SLASH;\n    },\n    lexeme (sourceStream) {\n      const body = scanRegExpBody(sourceStream);\n      const withFlags = scanRegExpFlags(sourceStream, body);\n      const rawValue = sourceStream.read(withFlags);\n      return {\n        type: categories.RegularExpressionLiteral,\n        rawValue,\n        pattern: rawValue.substr(1, body - 2),\n        flags: rawValue.substr(body, withFlags - body)\n      };\n    }\n  };\n};\n\nconst templateOrPart = (onExit = categories.Template, onFollow = categories.TemplateHead) => {\n  const fn = (sourceStream, count = 1) => {\n    const next = sourceStream.seeNextAt(count);\n    count += 1;\n    if (next === chars.CHAR_TEMPLATE_QUOTE) {\n      return {\n        type: onExit,\n        rawValue: sourceStream.read(count)\n      };\n    }\n\n    if (next === chars.CHAR_DOLLAR && sourceStream.seeNextAt(count) === chars.CHAR_BRACE_OPEN) {\n      return {\n        type: onFollow,\n        rawValue: sourceStream.read(count + 1)\n      };\n    }\n\n    if (next === chars.CHAR_BACKSLASH) {\n      count += 1;\n    }\n\n    return fn(sourceStream, count);\n\n  };\n  return fn;\n};\nconst headOrTemplate = templateOrPart();\nexport const templateHeadOrLiteral = () => {\n  return {\n    test (sourceStream) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_TEMPLATE_QUOTE;\n    },\n    lexeme (sourceStream) {\n      return headOrTemplate(sourceStream);\n    }\n  };\n};\n\nconst middleOrTail = templateOrPart(categories.TemplateTail, categories.TemplateMiddle);\nexport const templateTailOrMiddle = () => {\n  return {\n    test (sourceStream, context) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_BRACE_CLOSE && (~context & syntacticFlags.allowRightBrace);\n    },\n    lexeme (sourceStream) {\n      return middleOrTail(sourceStream);\n    }\n  }\n};\n\nexport const ECMAScriptLexicalGrammar = [\n  whiteSpace,\n  lineTerminator,\n  numbers,\n  singleLineComment,\n  multiLineComment,\n  punctuators,\n  identifiers,\n  regularExpression,\n  stringLiteral,\n  templateHeadOrLiteral,\n  templateTailOrMiddle\n];\n\nexport const scanner = (lexicalRules = ECMAScriptLexicalGrammar.map(g => g())) => {\n  return (source, context) => {\n    const rule = lexicalRules.find(lr => lr.test(source, context));\n    if (rule === void 0) {\n      throw new Error(`could not understand the symbol ${source.seeNextAt()}`);\n    }\n    return rule.lexeme(source);\n  };\n};\n\nexport default scanner();\n","import zora from 'zora';\nimport {categories} from \"../src/tokens\";\nimport {sourceStream} from \"../src/source\";\nimport {\n  singleLineComment as singleLineCommentScanner,\n  multiLineComment as multiLineCommentScanner\n} from \"../src/scanners\";\n\nconst p = zora();\n\nconst singleLineComment = [`//foo`, '//* const foo bar woot f1o2*/'];\nconst multiLineComment = ['/* f_oo const \\n foo * / bar = \"what\" */', '/* const foo \\n bar = \"what\"  sdfd\\n */'];\n\nfor (let t of singleLineComment) {\n  p.test(`\"${t}\" should result in an single Line comment token `, (assert) => {\n    try {\n      const scanner = singleLineCommentScanner();\n      const source = sourceStream(t);\n      const {type, rawValue} = scanner.lexeme(source);\n      assert.equal(type, categories.SingleLineComment, `\"${t}\" should have the single line comment token type`);\n      assert.equal(rawValue, t, `should match the input`);\n    } catch (e) {\n      console.log(e);\n      assert.fail();\n    }\n  });\n}\n\nfor (let t of multiLineComment) {\n  p.test(`\"${t}\" should result in an multi Line comment token `, (assert) => {\n    try {\n      const scanner = multiLineCommentScanner();\n      const source = sourceStream(t);\n      const {type, rawValue} = scanner.lexeme(source);\n      assert.equal(type, categories.MultiLineComment, `\"${t}\" should have the multiple line comment token type`);\n      assert.equal(rawValue, t, `should match the input`);\n    } catch (e) {\n      console.log(e);\n      assert.fail();\n    }\n  });\n}\n\nexport default p;","import zora from 'zora';\nimport {categories} from \"../src/tokens\";\nimport {sourceStream} from \"../src/source\";\nimport {identifiers} from \"../src/scanners\";\n\n\nconst p = zora();\n\nconst passingTests = ['foo', 'f1o2', 'f_oo', '$foo', '_foo', 'const', 'function'];\n\nfor (let t of passingTests) {\n  p.test(`\"${t}\" should result in an identifier token `, (assert) => {\n    try {\n      const source = sourceStream(t);\n      const {type, rawValue} = identifiers().lexeme(source);\n      assert.equal(type, categories.Identifier, `\"${t}\" should have scan a token with identifier type`);\n      assert.equal(rawValue, t, `should match the input`);\n    } catch (e) {\n      console.log(e);\n      assert.fail();\n    }\n  });\n}\n\nexport default p;","import zora from 'zora';\nimport {categories} from \"../src/tokens\";\nimport {sourceStream} from \"../src/source\";\nimport {punctuators} from \"../src/scanners\";\n\nconst p = zora();\nconst passingTests = [\"}\", \"{\", \"(\", \")\", \"[\", \"]\", \"/\", \"/=\", \".\", \"...\", \";\", \",\", \"<\", \">\", \"<=\", \">=\", \"==\", \"!=\", \"===\", \"!==\", \"+\", \"-\", \"*\", \"%\", \"**\", \"++\", \"--\", \"<<\", \">>\", \">>>\", \"&\", \"|\", \"^\", \"!\", \"~\", \"&&\", \"||\", \"?\", \":\", \"=\", \"+=\", \"-=\", \"*=\", \"%=\", \"<<=\", \">>=\", \">>>=\", \"&=\", \"|=\", \"^=\", \"=>\"];\nfor (let t of passingTests) {\n  p.test(`\"${t}\" should result in a punctuator token `, (assert) => {\n    try {\n      const {type, rawValue} = punctuators().lexeme(sourceStream(t), false);\n      assert.equal(type, categories.Punctuator, `\"${t}\" should have the punctuator token type`);\n      assert.equal(rawValue, t, `should match the input`);\n    } catch (e) {\n      console.log(e);\n      assert.fail();\n    }\n  });\n}\n\nexport default p;","import zora from 'zora';\nimport {categories} from \"../src/tokens\";\nimport {sourceStream} from \"../src/source\";\nimport {numbers} from \"../src/scanners\";\n\nconst p = zora();\n\nconst passingTests = [\n  '0x3F3a',\n  '0X3F3a',\n  '0o3705',\n  '0O3705',\n  '0b0101011',\n  '0B0101011',\n  '123',\n  '023',\n  '34.',\n  '.3435',\n  '345.767',\n  '.34e-1',\n  '.34E-1',\n  '.65e+3',\n  '.6E+3',\n  '.86e4',\n  '.34E4',\n  '4545.4545e+5',\n  '4545.4545E+5',\n  '4545.4545e5',\n  '4545.4545E5',\n  '4545.4545e-5',\n  '4545.4545E-5',\n  '34e+5',\n  '34E+5',\n  '34e5',\n  '34E5',\n  '34e-5',\n  '34E-5',\n];\n\nfor (let t of passingTests) {\n  p.test(`\"${t}\" should result in a numeric literal token `, (assert) => {\n    try {\n      const {type, rawValue} = numbers().lexeme(sourceStream(t));\n      assert.equal(type, categories.NumericLiteral, `\"${t}\" should have the numeric literal token type`);\n      assert.equal(rawValue, t, `should match the input`);\n    } catch (e) {\n      console.log(e);\n      assert.fail();\n    }\n  });\n}\n\nexport default p;","import zora from 'zora';\nimport {regularExpression} from \"../src/scanners\";\nimport {sourceStream} from \"../src/source\";\nimport {categories} from \"../src/tokens\";\n\n\nconst p = zora();\n\nconst passingTests = [\n  `/a+b?*/`,\n  `/a+b?*/ig`,\n  `/\\\\s+sbw/`,\n  `/\\\\s+sbw/ig`,\n  `/\\\\s|[0-9]*/`,\n  `/\\\\s|[0-9]+/ig`,\n  `/\\\\s|[0-9\\\\-]/`,\n];\n\nfor (let t of passingTests) {\n  p.test(`\"${t}\" should result in a regexp literal token`, (assert) => {\n    try {\n      const {type, rawValue} = regularExpression().lexeme(sourceStream(t),true);\n      assert.equal(type, categories.RegularExpressionLiteral, `\"${t}\" should have the regexp literal token type`);\n      assert.equal(rawValue, t, `should match the input`);\n    } catch (e) {\n      console.log(e);\n      assert.fail();\n    }\n  });\n}\n\n\nexport default p;","import zora from 'zora';\nimport {stringLiteral} from \"../src/scanners\";\nimport {categories} from \"../src/tokens\";\nimport {sourceStream} from \"../src/source\";\n\nconst p = zora();\n\nconst passingTests = [\n  `\"test\"`,\n  `'test'`,\n  `\"te\\\\\"st\"`,\n  `'te\\\\'st'`,\n  `\"te'st\"`,\n  `'te\"st'`\n];\n\nfor (let t of passingTests) {\n  p.test(`\"${t}\" should result in a string literal token `, (assert) => {\n    try {\n      const {type, rawValue} = stringLiteral().lexeme(sourceStream(t));\n      assert.equal(type, categories.StringLiteral, `\"${t}\" should have the string literal token type`);\n      assert.equal(rawValue, t, `should match the input`);\n    } catch (e) {\n      console.log(e);\n      assert.fail();\n    }\n  });\n}\n\nexport default p;","import zora from 'zora';\nimport {categories} from \"../src/tokens\";\nimport {whiteSpace} from \"../src/scanners\";\nimport {sourceStream} from \"../src/source\";\n\nconst p = zora();\n\nconst passingTests = [\n  String.fromCodePoint(0x0009), // character tabulation,\n  String.fromCodePoint(0x000b), // Line Tabulation,\n  String.fromCodePoint(0x000c), // form feed,\n  String.fromCodePoint(0x0020), // space\n  String.fromCodePoint(0x00a0), // no break space,\n  String.fromCodePoint(0xfeff) // zero with no break space,\n];\n\nfor (let t of passingTests) {\n  p.test(`\"${t}\" should result in a white space token instruction `, (assert) => {\n    try {\n      const {type, rawValue} = whiteSpace().lexeme(sourceStream(t));\n      assert.equal(type, categories.WhiteSpace, `\"${t}\" should have the white space token category`);\n      assert.equal(rawValue, t, `should match the input`);\n    } catch (e) {\n      console.log(e);\n      assert.fail();\n    }\n  });\n}\n\nexport default p;","import zora from 'zora';\nimport {categories} from \"../src/tokens\";\nimport {lineTerminator} from \"../src/scanners\";\nimport {sourceStream} from \"../src/source\";\n\nconst p = zora();\n\nconst passingTests = [\n  String.fromCodePoint(0x000A), //\tLINE FEED (LF)\t<LF>\n  String.fromCodePoint(0x000D), //\tCARRIAGE RETURN (CR)\t<CR>\n  String.fromCodePoint(0x2028), //\tLINE SEPARATOR\t<LS>\n  String.fromCodePoint(0x2029) //\tPARAGRAPH SEPARATOR\t<PS>\n];\n\nfor (let t of passingTests) {\n  p.test(`\"${t}\" should result in a line terminator token instruction `, (assert) => {\n    try {\n      const {type, rawValue} = lineTerminator().lexeme(sourceStream(t));\n      assert.equal(type, categories.LineTerminator, `\"${t}\" should have the line terminator token category`);\n      assert.equal(rawValue, t, `should match the input`);\n    } catch (e) {\n      console.log(e);\n      assert.fail();\n    }\n  });\n}\n\nexport default p;","import zora from 'zora';\nimport {categories} from \"../src/tokens\";\nimport {sourceStream} from \"../src/source\";\nimport {default as scanner} from \"../src/scanners\";\nimport {syntacticFlags} from \"../src/utils\";\n\nconst p = zora();\n\np.test('scanner should detect a white space', assert => {\n  const {type} = scanner(sourceStream(' '));\n  assert.equal(type, categories.WhiteSpace, 'should have set the type to whitespace');\n});\n\np.test('scanner should detect single line comment', assert => {\n  const {type} = scanner(sourceStream(`// foo bar`), ~syntacticFlags.allowRegexp);\n  assert.equal(type, categories.SingleLineComment, 'should have set the type to single line comment');\n});\n\np.test('scanner should detect multi line comment', assert => {\n  const {type} = scanner(sourceStream('/* foo bar */'), ~syntacticFlags.allowRegexp);\n  assert.equal(type, categories.MultiLineComment, 'should have set the type to multi line comment');\n});\n\np.test('scanner should detect with context a regexp literal', assert => {\n  const {type} = scanner(sourceStream('/test/ig'), syntacticFlags.allowRegexp);\n  assert.equal(type, categories.RegularExpressionLiteral, 'should have set the type to regexp literal');\n});\n\np.test('scanner should detect a division operator if context does not fit regexp literal goal', assert => {\n  const {type} = scanner(sourceStream('/test/ig'), ~syntacticFlags.allowRegexp);\n  assert.equal(type, categories.Punctuator, 'should have set the type to punctuator');\n});\n\np.test('scanner should detect a numeric starting by a dot', assert => {\n  const {type} = scanner(sourceStream('.34'), ~syntacticFlags.allowRegexp);\n  assert.equal(type, categories.NumericLiteral, 'should have set the type to Numeric literal');\n});\n\np.test('scanner should detect a period punctuator if not followed by numbers', assert => {\n  const {type} = scanner(sourceStream(`.dfo`), ~syntacticFlags.allowRegexp);\n  assert.equal(type, categories.Punctuator, 'should have set the type to punctuator literal');\n});\n\np.test('scanner should detect punctuator', assert => {\n  const {type} = scanner(sourceStream('<='), ~syntacticFlags.allowRegexp);\n  assert.equal(type, categories.Punctuator, 'should have set the type to punctuator');\n});\n\np.test('scanner should detect identifier', assert => {\n  const {type} = scanner(sourceStream('foo'), ~syntacticFlags.allowRegexp);\n  assert.equal(type, categories.Identifier, 'should have set the type to Identifier');\n});\n\np.test('scanner should detect line Terminator', assert => {\n  const {type} = scanner(sourceStream(`\n  `), false);\n  assert.equal(type, categories.LineTerminator, 'should have set the type to Line terminator');\n});\n\np.test('scanner should detect numeric literal', assert => {\n  const {type} = scanner(sourceStream(`34.5`), ~syntacticFlags.allowRegexp);\n  assert.equal(type, categories.NumericLiteral, 'should have set the type to Numeric literal');\n});\n\np.test('scanner should detect a string literal starting with single quote', assert => {\n  const {type} = scanner(sourceStream(`'test'`), ~syntacticFlags.allowRegexp);\n  assert.equal(type, categories.StringLiteral, 'should have set the type to String literal');\n});\n\np.test('scanner should detect a string literal starting with double quote', assert => {\n  const {type} = scanner(sourceStream(`\"test\"`), ~syntacticFlags.allowRegexp);\n  assert.equal(type, categories.StringLiteral, 'should have set the type to String literal');\n});\n\np.test('scanner should detect a template literal', assert => {\n  const {type} = scanner(sourceStream(\"`foo bar`\"), ~syntacticFlags.allowRegexp);\n  assert.equal(type, categories.Template, 'should have set the type to Template literal');\n});\n\nexport default p;","import zora from 'zora';\nimport {templateHeadOrLiteral} from \"../src/scanners\";\nimport {categories} from \"../src/tokens\";\nimport {sourceStream} from \"../src/source\";\n\nconst p = zora();\n\nconst passingTests = [\n  '`foo bar`',\n  '`fo\"o\" bar`',\n  '`fo\\\\`o bar`',\n  '`fo\\\\`o bar \\n foo bar bis \\n another line`',\n];\n\nfor (let t of passingTests) {\n  p.test(`\"${t}\" should result in a template literal token `, (assert) => {\n    try {\n      const {type, rawValue} = templateHeadOrLiteral().lexeme(sourceStream(t));\n      assert.equal(type, categories.Template, `\"${t}\" should have the string literal token type`);\n      assert.equal(rawValue, t, `should match the input`);\n    } catch (e) {\n      console.log(e);\n      assert.fail();\n    }\n  });\n}\n\nexport default p;","import {sourceStream} from \"./source\";\nimport {allowRegexpAfter, categories} from \"./tokens\";\nimport {syntacticFlags, lazyFilterWith, lazyMapWith} from \"./utils\";\nimport {default as defaultScanner} from './scanners';\nimport {default as defaultRegistry} from './tokens';\n\n/* Note\n\nwe could greatly improve perf by directly yielding filtered (and evaluated token?) at the scanner level instead of passing every lexeme through a lazy stream combinators pipe chain,\nhowever we would lost the great flexibility we have here !\n\nfor example if we simply ignored white space, line terminators, etc.\nour filter combinator would have to run much less (at least for big files)\n\nbottom line: we value more modularity and flexibility of the system over performance\n\ntodo: later we can give ability to the consumer to configure the scanner to perform better\n\n*/\n\n\n//return an iterable sequence of lexemes (note it can only be consumed once like a generator)\n//The consumer (like a parser) will have to handle the syntactic state and the token evaluation by itself\nexport const lexemes = (code, scanner) => {\n  let context = syntacticFlags.allowRegexp | syntacticFlags.allowRightBrace;\n  let previousContext = context;\n  const source = sourceStream(code);\n  const holdContext = fn => _ => {\n    previousContext = context;\n    fn();\n  };\n  return {\n    * [Symbol.iterator] () {\n      while (true) {\n        if (source.done === true) {\n          return;\n        }\n        yield scanner(source, context);\n      }\n    },\n    allowRegexp: holdContext(() => {\n      context |= syntacticFlags.allowRegexp;\n    }),\n    disallowRegexp: holdContext(() => {\n      context &= ~syntacticFlags.allowRegexp;\n    }),\n    allowRightBrace: holdContext(() => { // as punctuator vs template middle/tail\n      context |= syntacticFlags.allowRightBrace;\n    }),\n    disallowRightBrace: holdContext(() => {\n      context &= ~syntacticFlags.allowRightBrace;\n    }),\n    loc () {\n      return source.loc();\n    }\n  }\n};\n\nlet defaultFilter = t => t.type >= 4;\nconst defaultOptions = {\n  scanner: defaultScanner,\n  tokenRegistry: defaultRegistry,\n  evaluate: defaultRegistry.evaluate,\n  filter: defaultFilter\n};\n\n// a standalone tokenizer (ie uses some heuristics based on the last meaningful token to know how to scan a slash)\n// https://stackoverflow.com/questions/5519596/when-parsing-javascript-what-determines-the-meaning-of-a-slash\nexport const tokenize = function* (code, {scanner = defaultScanner, tokenRegistry = defaultRegistry, filter, evaluate} = defaultOptions) {\n  const filterFunc = lazyFilterWith(filter || defaultFilter);\n  const mapFunc = lazyMapWith(evaluate || tokenRegistry.evaluate);\n  const filterMap = iter => mapFunc(filterFunc(iter));\n  const stream = lexemes(code, scanner);\n\n  let substitutionStack = []; //pending braces\n\n  for (let t of filterMap(stream)) {\n    yield t;\n    //meaningful tokens\n    if (Object.is(t.type, t) || t.type >= 4) {\n\n      //heuristic for regexp context\n      if (allowRegexpAfter.includes(t.rawValue)) {\n        stream.allowRegexp();\n      } else {\n        stream.disallowRegexp();\n      }\n\n      //template literal substitution\n      if (t.type === categories.TemplateHead || t.type === categories.TemplateMiddle) {\n        substitutionStack.push(0);\n        stream.disallowRightBrace();\n        stream.allowRegexp();\n      } else if (t.type === categories.TemplateTail) {\n        substitutionStack.pop();\n      }\n\n      //without context we need to backtrack braces\n      if (substitutionStack.length) {\n\n        const lastSubstitutionIndex = substitutionStack.length - 1;\n\n        if (t.rawValue === '{') {\n          substitutionStack[lastSubstitutionIndex] = substitutionStack[lastSubstitutionIndex] + 1;\n          stream.allowRightBrace();\n        }\n\n        if (t.rawValue === '}') {\n          let pending = substitutionStack[lastSubstitutionIndex] = substitutionStack[lastSubstitutionIndex] - 1;\n          if (pending === 0) {\n            stream.disallowRightBrace();\n          }\n        }\n      }\n    }\n  }\n};","import {tokenize} from \"../src/index\";\nimport {categories, default as tokensRegistry} from '../src/tokens';\nimport zora from 'zora';\n\nexport default zora()\n  .test('should be able to switch syntactic context alone (for regexp)', t => {\n    const tokens = [...tokenize('foo = bar / 4')];\n    t.deepEqual(tokens.map(tok => tok.type), [\n      categories.Identifier,\n      tokensRegistry.get('='),\n      categories.Identifier,\n      tokensRegistry.get('/'),\n      categories.NumericLiteral\n    ]);\n  })\n  .test('should be able to switch syntactic context alone (for regexp)', t => {\n    const tokens = [...tokenize('foo = /bar/g')];\n    t.deepEqual(tokens.map(tok => tok.type), [\n      categories.Identifier,\n      tokensRegistry.get('='),\n      categories.RegularExpressionLiteral\n    ]);\n  })\n  .test('should be able to switch syntactic context alone (for template literals)', t => {\n    const tokens = [...tokenize(\"`foo ${bar + bim}blah`\")];\n    t.deepEqual(tokens.map(tok => tok.type), [\n      categories.TemplateHead,\n      categories.Identifier,\n      tokensRegistry.get('+'),\n      categories.Identifier,\n      categories.TemplateTail\n    ]);\n  })\n  .test('should be able to switch syntactic context alone (for template literals)', t => {\n    const tokens = [...tokenize(\"if(foo){ bar } else { bim }\")];\n    t.deepEqual(tokens.map(tok => tok.type), [\n      tokensRegistry.get('if'),\n      tokensRegistry.get('('),\n      categories.Identifier,\n      tokensRegistry.get(')'),\n      tokensRegistry.get('{'),\n      categories.Identifier,\n      tokensRegistry.get('}'),\n      tokensRegistry.get('else'),\n      tokensRegistry.get('{'),\n      categories.Identifier,\n      tokensRegistry.get('}'),\n    ]);\n  })\n  .test('should be able to switch syntactic context alone (for template literals)', t => {\n    const tokens = [...tokenize(\"`foo ${bar + bim}blah ${bar} woot`\")];\n    t.deepEqual(tokens.map(tok => tok.type), [\n      categories.TemplateHead,\n      categories.Identifier,\n      tokensRegistry.get('+'),\n      categories.Identifier,\n      categories.TemplateMiddle,\n      categories.Identifier,\n      categories.TemplateTail\n    ]);\n  })\n  .test('should be able to switch syntactic context alone (for template literals)', t => {\n    const tokens = [...tokenize(\"`foo ${({bim:'blah'})}`\")];\n    t.deepEqual(tokens.map(tok => tok.type), [\n      categories.TemplateHead,\n      tokensRegistry.get('('),\n      tokensRegistry.get('{'),\n      categories.Identifier,\n      tokensRegistry.get(':'),\n      categories.StringLiteral,\n      tokensRegistry.get('}'),\n      tokensRegistry.get(')'),\n      categories.TemplateTail\n    ]);\n  });\n\n\n\n","import comments from './comments';\nimport identifiers from './identifiers';\nimport punctuators from './punctuators';\nimport numerics from './numerics';\nimport regexps from './regexps';\nimport strings from './strings';\nimport whiteSpaces from './whitespaces';\nimport lineTerminators from './lineTerminators';\nimport scanner from './scanner';\nimport templates from './templates';\nimport tokenizer from './selfTokenizer';\n\nimport zora from 'zora';\n\nzora()\n  .test(comments)\n  .test(identifiers)\n  .test(punctuators)\n  .test(numerics)\n  .test(regexps)\n  .test(strings)\n  .test(whiteSpaces)\n  .test(lineTerminators)\n  .test(templates)\n  .test(scanner)\n  .test(tokenizer)\n  .run();"],"names":["singleLineComment","chars.SINGLE_LINE_COMMENT_START","multiLineComment","chars.CHAR_STAR","chars.CHAR_SLASH","chars.MULTI_LINE_COMMENT_START","chars.CHAR_BACKSLASH","chars.CHAR_SINGLE_QUOTE","chars.CHAR_DOUBLE_QUOTE","chars.SPREAD","chars.CHAR_BRACE_CLOSE","chars.CHAR_DOT","chars.CHAR_LEFT_BRACKET","chars.CHAR_RIGHT_BRACKET","chars.CHAR_TEMPLATE_QUOTE","chars.CHAR_DOLLAR","chars.CHAR_BRACE_OPEN","zora","scanner","singleLineCommentScanner","multiLineCommentScanner","p","passingTests","tokenRegistry","tokensRegistry","comments","identifiers","punctuators","numerics","regexps","strings","whiteSpaces","lineTerminators","templates"],"mappings":";;;AAAA,SAAS,oBAAoB,CAAC,EAAE,EAAE,MAAM,EAAE;CACzC,OAAO,MAAM,GAAG,EAAE,OAAO,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,OAAO,CAAC,EAAE,MAAM,CAAC,OAAO,CAAC;CAC5E;;AAED,IAAI,IAAI,GAAG,oBAAoB,CAAC,UAAU,MAAM,EAAE,OAAO,EAAE;AAC3D,OAAO,GAAG,MAAM,CAAC,OAAO,GAAG,OAAO,MAAM,CAAC,IAAI,KAAK,UAAU;IACxD,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC;;AAEvB,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC;AACpB,SAAS,IAAI,EAAE,GAAG,EAAE;EAClB,IAAI,IAAI,GAAG,EAAE,CAAC;EACd,KAAK,IAAI,GAAG,IAAI,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;EACpC,OAAO,IAAI,CAAC;CACb;CACA,CAAC,CAAC;;AAEH,IAAI,YAAY,GAAG,oBAAoB,CAAC,UAAU,MAAM,EAAE,OAAO,EAAE;AACnE,IAAI,sBAAsB,GAAG,CAAC,UAAU;EACtC,OAAO,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC;CACjD,GAAG,IAAI,oBAAoB,CAAC;;AAE7B,OAAO,GAAG,MAAM,CAAC,OAAO,GAAG,sBAAsB,GAAG,SAAS,GAAG,WAAW,CAAC;;AAE5E,OAAO,CAAC,SAAS,GAAG,SAAS,CAAC;AAC9B,SAAS,SAAS,CAAC,MAAM,EAAE;EACzB,OAAO,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,oBAAoB,CAAC;CACvE;;AAED,OAAO,CAAC,WAAW,GAAG,WAAW,CAAC;AAClC,SAAS,WAAW,CAAC,MAAM,CAAC;EAC1B,OAAO,MAAM;IACX,OAAO,MAAM,IAAI,QAAQ;IACzB,OAAO,MAAM,CAAC,MAAM,IAAI,QAAQ;IAChC,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,EAAE,QAAQ,CAAC;IACtD,CAAC,MAAM,CAAC,SAAS,CAAC,oBAAoB,CAAC,IAAI,CAAC,MAAM,EAAE,QAAQ,CAAC;IAC7D,KAAK,CAAC;CACT;CACA,CAAC,CAAC;;AAEH,IAAI,KAAK,GAAG,oBAAoB,CAAC,UAAU,MAAM,EAAE;AACnD,IAAI,MAAM,GAAG,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC;;;;AAInC,IAAI,SAAS,GAAG,MAAM,CAAC,OAAO,GAAG,UAAU,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE;EACjE,IAAI,CAAC,IAAI,EAAE,IAAI,GAAG,EAAE,CAAC;;EAErB,IAAI,MAAM,KAAK,QAAQ,EAAE;IACvB,OAAO,IAAI,CAAC;;GAEb,MAAM,IAAI,MAAM,YAAY,IAAI,IAAI,QAAQ,YAAY,IAAI,EAAE;IAC7D,OAAO,MAAM,CAAC,OAAO,EAAE,KAAK,QAAQ,CAAC,OAAO,EAAE,CAAC;;;;GAIhD,MAAM,IAAI,CAAC,MAAM,IAAI,CAAC,QAAQ,IAAI,OAAO,MAAM,IAAI,QAAQ,IAAI,OAAO,QAAQ,IAAI,QAAQ,EAAE;IAC3F,OAAO,IAAI,CAAC,MAAM,GAAG,MAAM,KAAK,QAAQ,GAAG,MAAM,IAAI,QAAQ,CAAC;;;;;;;;GAQ/D,MAAM;IACL,OAAO,QAAQ,CAAC,MAAM,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC;GACzC;CACF,CAAC;;AAEF,SAAS,iBAAiB,CAAC,KAAK,EAAE;EAChC,OAAO,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,CAAC;CAC9C;;AAED,SAAS,QAAQ,EAAE,CAAC,EAAE;EACpB,IAAI,CAAC,CAAC,IAAI,OAAO,CAAC,KAAK,QAAQ,IAAI,OAAO,CAAC,CAAC,MAAM,KAAK,QAAQ,EAAE,OAAO,KAAK,CAAC;EAC9E,IAAI,OAAO,CAAC,CAAC,IAAI,KAAK,UAAU,IAAI,OAAO,CAAC,CAAC,KAAK,KAAK,UAAU,EAAE;IACjE,OAAO,KAAK,CAAC;GACd;EACD,IAAI,CAAC,CAAC,MAAM,GAAG,CAAC,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE,OAAO,KAAK,CAAC;EAC3D,OAAO,IAAI,CAAC;CACb;;AAED,SAAS,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE;EAC5B,IAAI,CAAC,EAAE,GAAG,CAAC;EACX,IAAI,iBAAiB,CAAC,CAAC,CAAC,IAAI,iBAAiB,CAAC,CAAC,CAAC;IAC9C,OAAO,KAAK,CAAC;;EAEf,IAAI,CAAC,CAAC,SAAS,KAAK,CAAC,CAAC,SAAS,EAAE,OAAO,KAAK,CAAC;;;EAG9C,IAAI,YAAY,CAAC,CAAC,CAAC,EAAE;IACnB,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE;MACpB,OAAO,KAAK,CAAC;KACd;IACD,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACnB,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACnB,OAAO,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;GAC9B;EACD,IAAI,QAAQ,CAAC,CAAC,CAAC,EAAE;IACf,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE;MAChB,OAAO,KAAK,CAAC;KACd;IACD,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,MAAM,EAAE,OAAO,KAAK,CAAC;IACxC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;MAC7B,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,OAAO,KAAK,CAAC;KACjC;IACD,OAAO,IAAI,CAAC;GACb;EACD,IAAI;IACF,IAAI,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC;QACZ,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;GAClB,CAAC,OAAO,CAAC,EAAE;IACV,OAAO,KAAK,CAAC;GACd;;;EAGD,IAAI,EAAE,CAAC,MAAM,IAAI,EAAE,CAAC,MAAM;IACxB,OAAO,KAAK,CAAC;;EAEf,EAAE,CAAC,IAAI,EAAE,CAAC;EACV,EAAE,CAAC,IAAI,EAAE,CAAC;;EAEV,KAAK,CAAC,GAAG,EAAE,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;IACnC,IAAI,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;MAChB,OAAO,KAAK,CAAC;GAChB;;;EAGD,KAAK,CAAC,GAAG,EAAE,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;IACnC,GAAG,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;IACZ,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,EAAE,OAAO,KAAK,CAAC;GACpD;EACD,OAAO,OAAO,CAAC,KAAK,OAAO,CAAC,CAAC;CAC9B;CACA,CAAC,CAAC;;AAEH,IAAI,MAAM,GAAG,CAAC,OAAO,KAAK;EACxB,MAAM,mBAAmB,GAAG,CAAC,EAAE,KAAK,CAAC,GAAG,IAAI,KAAK;IAC/C,MAAM,YAAY,GAAG,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC;IACjC,OAAO,CAAC,YAAY,CAAC,CAAC;IACtB,OAAO,YAAY,CAAC;GACrB,CAAC;;EAEF,OAAO;IACL,EAAE,EAAE,mBAAmB,CAAC,CAAC,GAAG,EAAE,OAAO,GAAG,kBAAkB,MAAM;MAC9D,IAAI,EAAE,OAAO,CAAC,GAAG,CAAC;MAClB,QAAQ,EAAE,QAAQ;MAClB,MAAM,EAAE,GAAG;MACX,QAAQ,EAAE,IAAI;MACd,OAAO;KACR,CAAC,CAAC;IACH,SAAS,EAAE,mBAAmB,CAAC,CAAC,MAAM,EAAE,QAAQ,EAAE,OAAO,GAAG,sBAAsB,MAAM;MACtF,IAAI,EAAE,KAAK,CAAC,MAAM,EAAE,QAAQ,CAAC;MAC7B,MAAM;MACN,QAAQ;MACR,OAAO;MACP,QAAQ,EAAE,WAAW;KACtB,CAAC,CAAC;IACH,KAAK,EAAE,mBAAmB,CAAC,CAAC,MAAM,EAAE,QAAQ,EAAE,OAAO,GAAG,iBAAiB,MAAM;MAC7E,IAAI,EAAE,MAAM,KAAK,QAAQ;MACzB,MAAM;MACN,QAAQ;MACR,OAAO;MACP,QAAQ,EAAE,OAAO;KAClB,CAAC,CAAC;IACH,KAAK,EAAE,mBAAmB,CAAC,CAAC,GAAG,EAAE,OAAO,GAAG,sBAAsB,MAAM;MACrE,IAAI,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC;MACnB,QAAQ,EAAE,OAAO;MACjB,MAAM,EAAE,GAAG;MACX,QAAQ,EAAE,OAAO;MACjB,OAAO;KACR,CAAC,CAAC;IACH,YAAY,EAAE,mBAAmB,CAAC,CAAC,MAAM,EAAE,QAAQ,EAAE,OAAO,GAAG,0BAA0B,MAAM;MAC7F,IAAI,EAAE,CAAC,KAAK,CAAC,MAAM,EAAE,QAAQ,CAAC;MAC9B,MAAM;MACN,QAAQ;MACR,OAAO;MACP,QAAQ,EAAE,cAAc;KACzB,CAAC,CAAC;IACH,QAAQ,EAAE,mBAAmB,CAAC,CAAC,MAAM,EAAE,QAAQ,EAAE,OAAO,GAAG,qBAAqB,MAAM;MACpF,IAAI,EAAE,MAAM,KAAK,QAAQ;MACzB,MAAM;MACN,QAAQ;MACR,OAAO;MACP,QAAQ,EAAE,UAAU;KACrB,CAAC,CAAC;IACH,MAAM,EAAE,mBAAmB,CAAC,CAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,KAAK;MACvD,IAAI,MAAM,EAAE,IAAI,EAAE,MAAM,CAAC;MACzB,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;QAChC,CAAC,QAAQ,EAAE,OAAO,CAAC,GAAG,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;OAC3C;MACD,IAAI;QACF,IAAI,EAAE,CAAC;OACR,CAAC,OAAO,KAAK,EAAE;QACd,MAAM,GAAG,CAAC,KAAK,CAAC,CAAC;OAClB;MACD,IAAI,GAAG,MAAM,KAAK,SAAS,CAAC;MAC5B,MAAM,GAAG,MAAM,IAAI,MAAM,CAAC,KAAK,CAAC;MAChC,IAAI,QAAQ,YAAY,MAAM,EAAE;QAC9B,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,QAAQ,CAAC,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,OAAO,CAAC,CAAC;QACxE,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;OAC7B,MAAM,IAAI,OAAO,QAAQ,KAAK,UAAU,IAAI,MAAM,EAAE;QACnD,IAAI,GAAG,MAAM,YAAY,QAAQ,CAAC;QAClC,MAAM,GAAG,MAAM,CAAC,WAAW,CAAC;OAC7B;MACD,OAAO;QACL,IAAI;QACJ,QAAQ;QACR,MAAM;QACN,QAAQ,EAAE,QAAQ;QAClB,OAAO,EAAE,OAAO,IAAI,cAAc;OACnC,CAAC;KACH,CAAC;IACF,YAAY,EAAE,mBAAmB,CAAC,CAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,KAAK;MAC7D,IAAI,MAAM,CAAC;MACX,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;QAChC,CAAC,QAAQ,EAAE,OAAO,CAAC,GAAG,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;OAC3C;MACD,IAAI;QACF,IAAI,EAAE,CAAC;OACR,CAAC,OAAO,KAAK,EAAE;QACd,MAAM,GAAG,CAAC,KAAK,CAAC,CAAC;OAClB;MACD,OAAO;QACL,IAAI,EAAE,MAAM,KAAK,SAAS;QAC1B,QAAQ,EAAE,iBAAiB;QAC3B,MAAM,EAAE,MAAM,IAAI,MAAM,CAAC,KAAK;QAC9B,QAAQ,EAAE,cAAc;QACxB,OAAO,EAAE,OAAO,IAAI,kBAAkB;OACvC,CAAC;KACH,CAAC;IACF,IAAI,EAAE,mBAAmB,CAAC,CAAC,MAAM,GAAG,aAAa,MAAM;MACrD,IAAI,EAAE,KAAK;MACX,MAAM,EAAE,aAAa;MACrB,QAAQ,EAAE,iBAAiB;MAC3B,OAAO,EAAE,MAAM;MACf,QAAQ,EAAE,MAAM;KACjB,CAAC,CAAC;GACJ,CAAC;CACH,CAAC;;AAEF,IAAI,IAAI,GAAG,CAAC,CAAC,WAAW,EAAE,IAAI,EAAE,IAAI,GAAG,KAAK,CAAC,GAAG,EAAE,KAAK;EACrD,MAAM,UAAU,GAAG,EAAE,CAAC;EACtB,MAAM,OAAO,GAAG,CAAC,GAAG,IAAI,KAAK,UAAU,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;;EAEhG,MAAM,QAAQ,GAAG;IACf,GAAG,EAAE;MACH,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;MACvB,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;SAC1C,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE,aAAa,EAAE,IAAI,CAAC,GAAG,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;KAChE;GACF,CAAC;;EAEF,MAAM,CAAC,gBAAgB,CAAC,QAAQ,EAAE;IAChC,IAAI,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC;IACnB,UAAU,EAAE,CAAC,KAAK,EAAE,UAAU,CAAC;IAC/B,MAAM,EAAE;MACN,GAAG,EAAE;QACH,OAAO,UAAU,CAAC,MAAM;OACzB;KACF;IACD,WAAW,EAAE,CAAC,KAAK,EAAE,WAAW,CAAC;GAClC,CAAC,CAAC;;EAEH,OAAO,QAAQ,CAAC;CACjB,CAAC;;AAEF,MAAM,MAAM,GAAG,CAAC,CAAC,IAAI,EAAE,OAAO,EAAE,KAAK,CAAC,KAAK;EACzC,MAAM,MAAM,GAAG,IAAI,KAAK,IAAI,GAAG,IAAI,GAAG,QAAQ,CAAC;EAC/C,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;CACjD,CAAC;;AAEF,MAAM,OAAO,GAAG,MAAM;EACpB,OAAO,OAAO,OAAO,KAAK,WAAW,IAAI,OAAO,OAAO,CAAC,IAAI,KAAK,UAAU,CAAC;CAC7E,CAAC;;AAEF,IAAI,GAAG,GAAG,MAAM,cAAc;EAC5B,IAAI,KAAK,GAAG,CAAC,CAAC;EACd,IAAI,MAAM,GAAG,CAAC,CAAC;EACf,IAAI,OAAO,GAAG,CAAC,CAAC;EAChB,IAAI,OAAO,GAAG,CAAC,CAAC;;EAEhB,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;EAC5B,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC;EAC9B,IAAI;IACF,OAAO,IAAI,EAAE;MACX,MAAM,SAAS,GAAG,KAAK,CAAC;MACxB,IAAI,SAAS,CAAC,IAAI,KAAK,IAAI,EAAE;QAC3B,OAAO,EAAE,CAAC;OACX,MAAM;QACL,OAAO,EAAE,CAAC;OACX;MACD,SAAS,CAAC,KAAK,GAAG,KAAK,CAAC;MACxB,IAAI,SAAS,CAAC,EAAE,KAAK,MAAM,EAAE;QAC3B,OAAO,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,SAAS,CAAC,WAAW,CAAC,GAAG,EAAE,SAAS,CAAC,aAAa,CAAC,EAAE,CAAC,CAAC,CAAC;QACzE,MAAM,GAAG,SAAS,CAAC,EAAE,CAAC;OACvB;MACD,MAAM,CAAC,SAAS,CAAC,CAAC;MAClB,IAAI,SAAS,CAAC,IAAI,KAAK,IAAI,EAAE;QAC3B,OAAO,CAAC,GAAG,CAAC,CAAC;YACT,EAAE,SAAS,CAAC,QAAQ,CAAC;YACrB,EAAE,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;UACvC,EAAE,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;KACxC,CAAC,CAAC,CAAC;OACD;MACD,KAAK,EAAE,CAAC;KACT;GACF,CAAC,OAAO,CAAC,EAAE;IACV,OAAO,CAAC,GAAG,CAAC,+BAA+B,CAAC,CAAC;IAC7C,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IACf,IAAI,OAAO,EAAE,EAAE;MACb,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;KACjB;GACF;UACO;IACN,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,QAAQ,CAAC;IACxC,IAAI,KAAK,GAAG,CAAC,EAAE;MACb,OAAO,CAAC,GAAG,CAAC,CAAC;GAChB,EAAE,KAAK,GAAG,CAAC,CAAC;WACJ,EAAE,SAAS,CAAC;UACb,EAAE,OAAO,CAAC;UACV,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;KAClB;IACD,IAAI,OAAO,IAAI,OAAO,EAAE,EAAE;MACxB,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;KACjB;GACF;CACF,CAAC;;AAEF,IAAI,IAAI,GAAG,MAAM;EACf,MAAM,KAAK,GAAG,EAAE,CAAC;EACjB,MAAM,QAAQ,GAAG;IACf,IAAI,CAAC,WAAW,EAAE,IAAI,EAAE,IAAI,GAAG,EAAE,CAAC;MAChC,IAAI,CAAC,IAAI,IAAI,WAAW,CAAC,IAAI,EAAE;;QAE7B,KAAK,CAAC,IAAI,CAAC,GAAG,WAAW,CAAC,CAAC;OAC5B,MAAM;QACL,MAAM,SAAS,GAAG,CAAC,WAAW,EAAE,IAAI,KAAK,CAAC,CAAC,IAAI,IAAI,WAAW,CAAC,IAAI,IAAI,CAAC,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC,CAAC;QAChH,KAAK,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;OACpF;MACD,OAAO,QAAQ,CAAC;KACjB;IACD,IAAI,CAAC,WAAW,EAAE,IAAI,EAAE,IAAI,GAAG,EAAE,CAAC;MAChC,OAAO,QAAQ,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;KAC5E;IACD,MAAM,GAAG,CAAC,IAAI,GAAG,GAAG,EAAE,CAAC;MACrB,MAAM,YAAY,GAAG,IAAI,EAAE,CAAC;MAC5B,MAAM,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC;MACxC,MAAM,QAAQ,GAAG,OAAO,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;MAC7D,IAAI,EAAE,GAAG,CAAC,CAAC;MACX,YAAY,CAAC,IAAI,EAAE,CAAC;MACpB,IAAI;QACF,MAAM,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC;QAC3C,KAAK,IAAI,CAAC,IAAI,OAAO,EAAE;UACrB,MAAM,CAAC,UAAU,EAAE,aAAa,CAAC,GAAG,MAAM,CAAC,CAAC;UAC5C,KAAK,IAAI,MAAM,IAAI,UAAU,EAAE;YAC7B,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,aAAa,CAAC,CAAC,CAAC,CAAC;WAC/D;UACD,EAAE,EAAE,CAAC;SACN;OACF;MACD,OAAO,CAAC,EAAE;QACR,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;OACvB,SAAS;QACR,YAAY,CAAC,MAAM,EAAE,CAAC;OACvB;KACF;IACD,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE;MACjB,OAAO,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC;KACjC;GACF,CAAC;;EAEF,MAAM,CAAC,gBAAgB,CAAC,QAAQ,EAAE;IAChC,KAAK,EAAE,CAAC,KAAK,EAAE,KAAK,CAAC;IACrB,MAAM,EAAE;MACN,GAAG,EAAE;QACH,OAAO,KAAK,CAAC,MAAM;OACpB;KACF;GACF,CAAC,CAAC;;EAEH,OAAO,QAAQ,CAAC;CACjB;;AC9XM,MAAM,UAAU,GAAG;EACxB,UAAU,EAAE,CAAC;EACb,cAAc,EAAE,CAAC;EACjB,iBAAiB,EAAE,CAAC;EACpB,gBAAgB,EAAE,CAAC;EACnB,UAAU,EAAE,CAAC;EACb,UAAU,EAAE,CAAC;EACb,cAAc,EAAE,CAAC;EACjB,aAAa,EAAE,CAAC;EAChB,wBAAwB,EAAE,CAAC;EAC3B,QAAQ,EAAE,CAAC;EACX,YAAY,EAAE,EAAE;EAChB,cAAc,EAAE,EAAE;EAClB,YAAY,EAAE,EAAE;CACjB,CAAC;;;;AAIF,MAAM,QAAQ,GAAG,iNAAiN,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AAC9O,MAAM,qBAAqB,GAAG,CAAC,MAAM,CAAC,CAAC;AACvC,MAAM,gBAAgB,GAAG,QAAQ,CAAC,MAAM,CAAC,qBAAqB,EAAE,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC;;;AAG3F,AAAO,MAAM,WAAW,GAAG,CAAC,4IAA4I,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;;AAErL,AAAO,MAAM,gBAAgB,GAAG,+KAA+K,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;;AAE3N,MAAM,mBAAmB,GAAG,CAAC,MAAM,EAAE,KAAK,KAAK;EAC7C,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE;IACrD,IAAI,EAAE;MACJ,GAAG,CAAC,GAAG;QACL,OAAO,IAAI,CAAC;OACb;KACF;GACF,CAAC,EAAE;IACF,KAAK,EAAE,KAAK,KAAK,MAAM,CAAC,GAAG,KAAK,GAAG,MAAM;IACzC,QAAQ,EAAE,MAAM;IAChB,UAAU,EAAE,gBAAgB,CAAC,QAAQ,CAAC,MAAM,CAAC;GAC9C,CAAC,CAAC,CAAC;CACL,CAAC;;;AAGF,AAAO,MAAM,aAAa,GAAG,MAAM;EACjC,MAAM,gBAAgB,GAAG,WAAW,CAAC,MAAM,CAAC,QAAQ,EAAE,qBAAqB,CAAC;KACzE,GAAG,CAAC,MAAM,KAAK,CAAC,MAAM,EAAE,mBAAmB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;EAC1D,gBAAgB,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,mBAAmB,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;EACnE,gBAAgB,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,mBAAmB,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;EACnE,gBAAgB,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,mBAAmB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;EACtE,gBAAgB,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,mBAAmB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;;EAEzD,MAAM,QAAQ,GAAG,IAAI,GAAG,CAAC,gBAAgB,CAAC,CAAC;;EAE3C,OAAO;IACL,GAAG,CAAC,CAAC,GAAG,EAAE;MACR,OAAO,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC;KACzB;IACD,QAAQ,CAAC,CAAC,MAAM,EAAE;MAChB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE;QAClC,QAAQ,MAAM,CAAC,IAAI;UACjB,KAAK,UAAU,CAAC,aAAa;YAC3B,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE;cAC3B,KAAK,EAAE,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,EAAE,MAAM,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;cAC5D,UAAU,EAAE,KAAK;aAClB,CAAC,CAAC;UACL,KAAK,UAAU,CAAC,cAAc;YAC5B,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,KAAK,EAAE,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC,CAAC;UACpF,KAAK,UAAU,CAAC,wBAAwB;YACtC,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,UAAU,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;UACrG;YACE,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,UAAU,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC;SAC7E;OACF;MACD,OAAO,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;KACtC;IACD,QAAQ,CAAC,GAAG;MACV,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;KACpC;GACF;CACF,CAAC;;AAEF,sBAAe,aAAa,EAAE;;AChF9B;AACA,AAAO,MAAM,YAAY,GAAG,CAAC,IAAI,KAAK;EACpC,MAAM,oBAAoB,GAAG,6BAA6B,CAAC;EAC3D,IAAI,KAAK,GAAG,CAAC,CAAC;EACd,IAAI,GAAG,GAAG,CAAC,CAAC;EACZ,IAAI,IAAI,GAAG,CAAC,CAAC;;EAEb,MAAM,IAAI,GAAG,CAAC,MAAM,KAAK,WAAW,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;EAC5D,MAAM,UAAU,GAAG,CAAC,KAAK,GAAG,CAAC,KAAK,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;EAC5D,MAAM,SAAS,GAAG,CAAC,MAAM,GAAG,CAAC,KAAK,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC,CAAC;EACvD,MAAM,WAAW,GAAG,MAAM,UAAU,CAAC,CAAC,CAAC,CAAC;EACxC,MAAM,GAAG,GAAG,OAAO,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC;;EAEhC,MAAM,OAAO,GAAG,CAAC,MAAM,GAAG,CAAC,KAAK;IAC9B,IAAI,aAAa,GAAG,CAAC,CAAC;;;IAGtB,MAAM,OAAO,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC;;;IAGnC,OAAO,oBAAoB,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;MACzC,IAAI,IAAI,CAAC,CAAC;MACV,GAAG,GAAG,CAAC,CAAC;MACR,aAAa,GAAG,oBAAoB,CAAC,SAAS,CAAC;KAChD;IACD,GAAG,KAAK,MAAM,GAAG,aAAa,CAAC,CAAC;IAChC,KAAK,IAAI,MAAM,CAAC;GACjB,CAAC;;EAEF,MAAM,MAAM,GAAG;IACb,GAAG;IACH,IAAI;IACJ,UAAU;IACV,SAAS;;IAET,KAAK,CAAC,CAAC,MAAM,EAAE;MACb,MAAM,CAAC,SAAS,GAAG,KAAK,CAAC;MACzB,MAAM,CAAC,QAAQ,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;MACrC,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;MACzB,OAAO,QAAQ,CAAC;KACjB;;IAED,IAAI,CAAC,CAAC,MAAM,EAAE;MACZ,MAAM,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;MAClC,OAAO,CAAC,MAAM,CAAC,CAAC;MAChB,OAAO,CAAC,CAAC;KACV;GACF,CAAC;;EAEF,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,MAAM,EAAE;IACpC,GAAG,CAAC,GAAG;MACL,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,KAAK,CAAC,CAAC;KAC/B;GACF,CAAC,CAAC;EACH,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,OAAO,EAAE;IACrC,GAAG,CAAC,GAAG;MACL,OAAO,KAAK,CAAC;KACd;GACF,CAAC,CAAC;;EAEH,OAAO,MAAM,CAAC;CACf;;AC7DM,MAAM,SAAS,GAAG,GAAG,CAAC;AAC7B,AAAO,MAAM,UAAU,GAAG,GAAG,CAAC;AAC9B,AAAO,MAAM,wBAAwB,GAAG,IAAI,CAAC;AAC7C,AAAO,MAAM,yBAAyB,GAAG,IAAI,CAAC;AAC9C,AAAO,MAAM,cAAc,GAAG,IAAI,CAAC;AACnC,AAAO,MAAM,iBAAiB,GAAG,GAAG,CAAC;AACrC,AAAO,MAAM,iBAAiB,GAAG,GAAG,CAAC;AACrC,AAAO,MAAM,iBAAiB,GAAG,GAAG,CAAC;AACrC,AAAO,MAAM,kBAAkB,GAAG,GAAG,CAAC;AACtC,AAAO,MAAM,QAAQ,GAAG,GAAG,CAAC;AAC5B,AAAO,MAAM,MAAM,GAAG,KAAK,CAAC;AAC5B,AAAO,MAAM,mBAAmB,GAAG,GAAG,CAAC;AACvC,AAAO,MAAM,WAAW,GAAG,GAAG,CAAC;AAC/B,AAAO,MAAM,eAAe,GAAG,GAAG,CAAC;AACnC,AAAO,MAAM,gBAAgB,GAAG,GAAG;;ACd5B,MAAM,WAAW,GAAG,CAAC,EAAE,KAAK,WAAW,QAAQ,EAAE;EACtD,KAAK,IAAI,CAAC,IAAI,QAAQ,EAAE;IACtB,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC;GACb;CACF,CAAC;;AAEF,AAAO,MAAM,cAAc,GAAG,EAAE,IAAI,WAAW,QAAQ,EAAE;EACvD,KAAK,IAAI,CAAC,IAAI,QAAQ,EAAE;IACtB,IAAI,EAAE,CAAC,CAAC,CAAC,EAAE;MACT,MAAM,CAAC,CAAC;KACT;GACF;CACF,CAAC;;AAEF,AAAO,MAAM,cAAc,GAAG;EAC5B,WAAW,EAAE,CAAC,IAAI,CAAC;EACnB,eAAe,EAAE,CAAC,IAAI,CAAC;CACxB;;ACVD,MAAM,gBAAgB,GAAG,CAAC,MAAM,EAAE,QAAQ,KAAK,YAAY,KAAK,CAAC,IAAI,EAAE,QAAQ,EAAE,QAAQ,EAAE,YAAY,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACxH,MAAM,cAAc,GAAG,MAAM,IAAI,YAAY,IAAI,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;AAC3E,MAAM,oBAAoB,GAAG,CAAC,CAAC,IAAI,EAAE,MAAM,EAAE,QAAQ,CAAC,KAAK,MAAM;;EAE/D,MAAM,UAAU,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,CAAC;EACpC,MAAM,YAAY,GAAG,IAAI,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;EAC7C,OAAO;IACL,IAAI,EAAE,cAAc,CAAC,UAAU,CAAC;IAChC,MAAM,EAAE,gBAAgB,CAAC,YAAY,EAAE,QAAQ,CAAC;GACjD;CACF,CAAC;;AAEF,AAAO,MAAM,OAAO,GAAG,oBAAoB,CAAC;EAC1C,QAAQ,EAAE,UAAU,CAAC,cAAc;EACnC,IAAI,EAAE,CAAC,+DAA+D,CAAC;EACvE,MAAM,EAAE,CAAC,2FAA2F,CAAC;CACtG,CAAC,CAAC;;AAEH,AAAO,MAAM,WAAW,GAAG,oBAAoB,CAAC;EAC9C,QAAQ,EAAE,UAAU,CAAC,UAAU;EAC/B,IAAI,EAAE,CAAC,WAAW,CAAC;EACnB,MAAM,EAAE,CAAC,iBAAiB,CAAC;CAC5B,CAAC,CAAC;;AAEH,AAAO,MAAM,UAAU,GAAG,oBAAoB,CAAC;EAC7C,QAAQ,EAAE,UAAU,CAAC,UAAU;EAC/B,IAAI,EAAE,CAAC,iDAAiD,CAAC;EACzD,MAAM,EAAE,CAAC,6CAA6C,CAAC;CACxD,CAAC,CAAC;;AAEH,AAAO,MAAM,cAAc,GAAG,oBAAoB,CAAC;EACjD,QAAQ,EAAE,UAAU,CAAC,cAAc;EACnC,IAAI,EAAE,CAAC,mCAAmC,CAAC;EAC3C,MAAM,EAAE,CAAC,+BAA+B,CAAC;CAC1C,CAAC,CAAC;;AAEH,AAAO,MAAMA,mBAAiB,GAAG,MAAM;EACrC,MAAM,YAAY,GAAG,SAAS,CAAC;EAC/B,OAAO;IACL,IAAI,EAAE,CAAC,YAAY,KAAK,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,KAAKC,yBAA+B;IACtF,MAAM,EAAE,gBAAgB,CAAC,YAAY,EAAE,UAAU,CAAC,iBAAiB,CAAC;GACrE,CAAC;CACH,CAAC;;AAEF,AAAO,MAAMC,kBAAgB,GAAG,MAAM;EACpC,MAAM,MAAM,GAAG,CAAC,YAAY,EAAE,KAAK,GAAG,CAAC,KAAK;IAC1C,MAAM,IAAI,GAAG,YAAY,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IAC3C,KAAK,EAAE,CAAC;IACR,IAAI,IAAI,KAAKC,SAAe,EAAE;MAC5B,MAAM,UAAU,GAAG,YAAY,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;MACjD,IAAI,UAAU,KAAKC,UAAgB,EAAE;QACnC,OAAO;UACL,IAAI,EAAE,UAAU,CAAC,gBAAgB;UACjC,QAAQ,EAAE,YAAY,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;SACvC;OACF;KACF;IACD,OAAO,MAAM,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;GACpC,CAAC;EACF,OAAO;IACL,IAAI,CAAC,CAAC,YAAY,EAAE;MAClB,OAAO,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,KAAKC,wBAA8B,CAAC;KACtE;IACD,MAAM;GACP,CAAC;CACH,CAAC;;AAEF,MAAM,SAAS,GAAG,KAAK,IAAI;EACzB,MAAM,EAAE,GAAG,CAAC,YAAY,EAAE,KAAK,GAAG,CAAC,KAAK;IACtC,MAAM,IAAI,GAAG,YAAY,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IAC3C,KAAK,IAAI,CAAC,CAAC;IACX,IAAI,IAAI,KAAK,KAAK,EAAE;MAClB,OAAO;QACL,IAAI,EAAE,UAAU,CAAC,aAAa;QAC9B,QAAQ,EAAE,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC;OACnC,CAAC;KACH;IACD,IAAI,IAAI,KAAKC,cAAoB,EAAE;MACjC,KAAK,IAAI,CAAC,CAAC;KACZ;IACD,OAAO,EAAE,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;GAChC,CAAC;EACF,OAAO,EAAE,CAAC;CACX,CAAC;AACF,AAAO,MAAM,aAAa,GAAG,MAAM;EACjC,MAAM,WAAW,GAAG,SAAS,CAACC,iBAAuB,CAAC,CAAC;EACvD,MAAM,WAAW,GAAG,SAAS,CAACC,iBAAuB,CAAC,CAAC;EACvD,OAAO;IACL,IAAI,CAAC,CAAC,YAAY,EAAE;MAClB,MAAM,IAAI,GAAG,YAAY,CAAC,SAAS,EAAE,CAAC;MACtC,OAAO,IAAI,KAAKD,iBAAuB,IAAI,IAAI,KAAKC,iBAAuB,CAAC;KAC7E;IACD,MAAM,CAAC,CAAC,YAAY,EAAE;MACpB,MAAM,IAAI,GAAG,YAAY,CAAC,SAAS,EAAE,CAAC;MACtC,OAAO,IAAI,KAAKA,iBAAuB,GAAG,WAAW,CAAC,YAAY,CAAC,GAAG,WAAW,CAAC,YAAY,CAAC,CAAC;KACjG;GACF,CAAC;CACH,CAAC;;AAEF,AAAO,MAAM,WAAW,GAAG,CAAC,cAAc,GAAG,WAAW,KAAK;;EAE3D,MAAM,qBAAqB,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC;EACzE,MAAM,qBAAqB,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC;EACzE,MAAM,uBAAuB,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC;EAC3E,MAAM,sBAAsB,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC;;;EAG1E,MAAM,kBAAkB,GAAG,CAAC,GAAG,KAAK;IAClC,QAAQ,GAAG,CAAC,MAAM;MAChB,KAAK,CAAC;QACJ,OAAO,qBAAqB,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;MAC7C,KAAK,CAAC;QACJ,OAAO,uBAAuB,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;MAC/C,KAAK,CAAC;QACJ,OAAO,sBAAsB,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;MAC9C;QACE,OAAO,KAAK,CAAC;KAChB;GACF,CAAC;EACF,MAAM,MAAM,GAAG,CAAC,YAAY,EAAE,KAAK,GAAG,CAAC,KAAK;IAC1C,MAAM,WAAW,GAAG,YAAY,CAAC,UAAU,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;IACvD,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,IAAI,WAAW,CAAC,MAAM,KAAK,KAAK,GAAG,CAAC,mBAAmB;MACzF,OAAO;QACL,IAAI,EAAE,UAAU,CAAC,UAAU;QAC3B,QAAQ,EAAE,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC;OACnC,CAAC;KACH;IACD,OAAO,MAAM,CAAC,YAAY,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC;GACxC,CAAC;EACF,MAAM,aAAa,GAAG,YAAY,KAAK;IACrC,IAAI,EAAE,UAAU,CAAC,UAAU;IAC3B,QAAQ,EAAE,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,KAAKC,MAAY,IAAI,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC;GACtG,CAAC,CAAC;EACH,OAAO;IACL,IAAI,CAAC,CAAC,YAAY,EAAE,OAAO,EAAE;MAC3B,MAAM,IAAI,GAAG,YAAY,CAAC,SAAS,EAAE,CAAC;MACtC,QAAQ,IAAI;QACV,KAAKL,UAAgB;UACnB,OAAO,CAAC,OAAO,GAAG,cAAc,CAAC,WAAW,CAAC;QAC/C,KAAKM,gBAAsB;UACzB,OAAO,OAAO,GAAG,cAAc,CAAC,eAAe,CAAC;QAClD;UACE,OAAO,qBAAqB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;OAC/C;KACF;IACD,MAAM,EAAE,YAAY,IAAI,YAAY,CAAC,SAAS,EAAE,KAAKC,QAAc,GAAG,aAAa,CAAC,YAAY,CAAC,GAAG,MAAM,CAAC,YAAY,CAAC;GACzH,CAAC;CACH,CAAC;;AAEF,MAAM,cAAc,GAAG,CAAC,YAAY,EAAE,KAAK,GAAG,CAAC,KAAK;EAClD,MAAM,IAAI,GAAG,YAAY,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;EAC3C,KAAK,IAAI,CAAC,CAAC;EACX,QAAQ,IAAI;IACV,KAAKP,UAAgB;MACnB,OAAO,KAAK,CAAC;IACf,KAAKQ,iBAAuB,EAAE;;MAE5B,KAAK,GAAG,eAAe,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;MAC7C,MAAM;KACP;IACD,KAAKN,cAAoB,EAAE;MACzB,KAAK,IAAI,CAAC,CAAC;MACX,MAAM;KACP;GACF;EACD,OAAO,cAAc,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;CAC5C,CAAC;AACF,MAAM,eAAe,GAAG,CAAC,YAAY,EAAE,KAAK,KAAK;EAC/C,MAAM,IAAI,GAAG,YAAY,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;EAC3C,KAAK,IAAI,CAAC,CAAC;EACX,QAAQ,IAAI;IACV,KAAKO,kBAAwB;MAC3B,OAAO,KAAK,CAAC;IACf,KAAKP,cAAoB;MACvB,KAAK,IAAI,EAAC;GACb;EACD,OAAO,eAAe,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;CAC7C,CAAC;;AAEF,MAAM,cAAc,GAAG,OAAO,CAAC;AAC/B,MAAM,eAAe,GAAG,CAAC,YAAY,EAAE,KAAK,KAAK;EAC/C,MAAM,IAAI,GAAG,YAAY,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;EAC3C,IAAI,CAAC,IAAI,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;IACvC,OAAO,KAAK,CAAC;GACd;EACD,OAAO,eAAe,CAAC,YAAY,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC;CACjD,CAAC;;AAEF,AAAO,MAAM,iBAAiB,GAAG,MAAM;EACrC,OAAO;IACL,IAAI,CAAC,CAAC,YAAY,EAAE,OAAO,EAAE;MAC3B,MAAM,IAAI,GAAG,YAAY,CAAC,SAAS,EAAE,CAAC;MACtC,OAAO,CAAC,OAAO,GAAG,cAAc,CAAC,WAAW,KAAK,IAAI,KAAKF,UAAgB,CAAC;KAC5E;IACD,MAAM,CAAC,CAAC,YAAY,EAAE;MACpB,MAAM,IAAI,GAAG,cAAc,CAAC,YAAY,CAAC,CAAC;MAC1C,MAAM,SAAS,GAAG,eAAe,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;MACtD,MAAM,QAAQ,GAAG,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;MAC9C,OAAO;QACL,IAAI,EAAE,UAAU,CAAC,wBAAwB;QACzC,QAAQ;QACR,OAAO,EAAE,QAAQ,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,GAAG,CAAC,CAAC;QACrC,KAAK,EAAE,QAAQ,CAAC,MAAM,CAAC,IAAI,EAAE,SAAS,GAAG,IAAI,CAAC;OAC/C,CAAC;KACH;GACF,CAAC;CACH,CAAC;;AAEF,MAAM,cAAc,GAAG,CAAC,MAAM,GAAG,UAAU,CAAC,QAAQ,EAAE,QAAQ,GAAG,UAAU,CAAC,YAAY,KAAK;EAC3F,MAAM,EAAE,GAAG,CAAC,YAAY,EAAE,KAAK,GAAG,CAAC,KAAK;IACtC,MAAM,IAAI,GAAG,YAAY,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IAC3C,KAAK,IAAI,CAAC,CAAC;IACX,IAAI,IAAI,KAAKU,mBAAyB,EAAE;MACtC,OAAO;QACL,IAAI,EAAE,MAAM;QACZ,QAAQ,EAAE,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC;OACnC,CAAC;KACH;;IAED,IAAI,IAAI,KAAKC,WAAiB,IAAI,YAAY,CAAC,SAAS,CAAC,KAAK,CAAC,KAAKC,eAAqB,EAAE;MACzF,OAAO;QACL,IAAI,EAAE,QAAQ;QACd,QAAQ,EAAE,YAAY,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;OACvC,CAAC;KACH;;IAED,IAAI,IAAI,KAAKV,cAAoB,EAAE;MACjC,KAAK,IAAI,CAAC,CAAC;KACZ;;IAED,OAAO,EAAE,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;;GAEhC,CAAC;EACF,OAAO,EAAE,CAAC;CACX,CAAC;AACF,MAAM,cAAc,GAAG,cAAc,EAAE,CAAC;AACxC,AAAO,MAAM,qBAAqB,GAAG,MAAM;EACzC,OAAO;IACL,IAAI,CAAC,CAAC,YAAY,EAAE;MAClB,MAAM,IAAI,GAAG,YAAY,CAAC,SAAS,EAAE,CAAC;MACtC,OAAO,IAAI,KAAKQ,mBAAyB,CAAC;KAC3C;IACD,MAAM,CAAC,CAAC,YAAY,EAAE;MACpB,OAAO,cAAc,CAAC,YAAY,CAAC,CAAC;KACrC;GACF,CAAC;CACH,CAAC;;AAEF,MAAM,YAAY,GAAG,cAAc,CAAC,UAAU,CAAC,YAAY,EAAE,UAAU,CAAC,cAAc,CAAC,CAAC;AACxF,AAAO,MAAM,oBAAoB,GAAG,MAAM;EACxC,OAAO;IACL,IAAI,CAAC,CAAC,YAAY,EAAE,OAAO,EAAE;MAC3B,MAAM,IAAI,GAAG,YAAY,CAAC,SAAS,EAAE,CAAC;MACtC,OAAO,IAAI,KAAKJ,gBAAsB,KAAK,CAAC,OAAO,GAAG,cAAc,CAAC,eAAe,CAAC,CAAC;KACvF;IACD,MAAM,CAAC,CAAC,YAAY,EAAE;MACpB,OAAO,YAAY,CAAC,YAAY,CAAC,CAAC;KACnC;GACF;CACF,CAAC;;AAEF,AAAO,MAAM,wBAAwB,GAAG;EACtC,UAAU;EACV,cAAc;EACd,OAAO;EACPV,mBAAiB;EACjBE,kBAAgB;EAChB,WAAW;EACX,WAAW;EACX,iBAAiB;EACjB,aAAa;EACb,qBAAqB;EACrB,oBAAoB;CACrB,CAAC;;AAEF,AAAO,MAAM,OAAO,GAAG,CAAC,YAAY,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK;EAChF,OAAO,CAAC,MAAM,EAAE,OAAO,KAAK;IAC1B,MAAM,IAAI,GAAG,YAAY,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,CAAC,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC;IAC/D,IAAI,IAAI,KAAK,KAAK,CAAC,EAAE;MACnB,MAAM,IAAI,KAAK,CAAC,CAAC,gCAAgC,EAAE,MAAM,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC;KAC1E;IACD,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;GAC5B,CAAC;CACH,CAAC;;AAEF,qBAAe,OAAO,EAAE,CAAC;;AC5RzB,MAAM,CAAC,GAAGe,IAAI,EAAE,CAAC;;AAEjB,MAAMjB,oBAAiB,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE,+BAA+B,CAAC,CAAC;AACrE,MAAME,mBAAgB,GAAG,CAAC,0CAA0C,EAAE,yCAAyC,CAAC,CAAC;;AAEjH,KAAK,IAAI,CAAC,IAAIF,oBAAiB,EAAE;EAC/B,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,gDAAgD,CAAC,EAAE,CAAC,MAAM,KAAK;IAC1E,IAAI;MACF,MAAMkB,UAAO,GAAGC,mBAAwB,EAAE,CAAC;MAC3C,MAAM,MAAM,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;MAC/B,MAAM,CAAC,IAAI,EAAE,QAAQ,CAAC,GAAGD,UAAO,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;MAChD,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,iBAAiB,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,gDAAgD,CAAC,CAAC,CAAC;MAC1G,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,sBAAsB,CAAC,CAAC,CAAC;KACrD,CAAC,OAAO,CAAC,EAAE;MACV,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;MACf,MAAM,CAAC,IAAI,EAAE,CAAC;KACf;GACF,CAAC,CAAC;CACJ;;AAED,KAAK,IAAI,CAAC,IAAIhB,mBAAgB,EAAE;EAC9B,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,+CAA+C,CAAC,EAAE,CAAC,MAAM,KAAK;IACzE,IAAI;MACF,MAAMgB,UAAO,GAAGE,kBAAuB,EAAE,CAAC;MAC1C,MAAM,MAAM,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;MAC/B,MAAM,CAAC,IAAI,EAAE,QAAQ,CAAC,GAAGF,UAAO,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;MAChD,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,gBAAgB,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,kDAAkD,CAAC,CAAC,CAAC;MAC3G,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,sBAAsB,CAAC,CAAC,CAAC;KACrD,CAAC,OAAO,CAAC,EAAE;MACV,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;MACf,MAAM,CAAC,IAAI,EAAE,CAAC;KACf;GACF,CAAC,CAAC;CACJ;;ACnCD,MAAMG,GAAC,GAAGJ,IAAI,EAAE,CAAC;;AAEjB,MAAM,YAAY,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,UAAU,CAAC,CAAC;;AAElF,KAAK,IAAI,CAAC,IAAI,YAAY,EAAE;EAC1BI,GAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,uCAAuC,CAAC,EAAE,CAAC,MAAM,KAAK;IACjE,IAAI;MACF,MAAM,MAAM,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC;MAC/B,MAAM,CAAC,IAAI,EAAE,QAAQ,CAAC,GAAG,WAAW,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;MACtD,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,+CAA+C,CAAC,CAAC,CAAC;MAClG,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,sBAAsB,CAAC,CAAC,CAAC;KACrD,CAAC,OAAO,CAAC,EAAE;MACV,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;MACf,MAAM,CAAC,IAAI,EAAE,CAAC;KACf;GACF,CAAC,CAAC;CACJ;;ACjBD,MAAMA,GAAC,GAAGJ,IAAI,EAAE,CAAC;AACjB,MAAMK,cAAY,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;AACxT,KAAK,IAAI,CAAC,IAAIA,cAAY,EAAE;EAC1BD,GAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,sCAAsC,CAAC,EAAE,CAAC,MAAM,KAAK;IAChE,IAAI;MACF,MAAM,CAAC,IAAI,EAAE,QAAQ,CAAC,GAAG,WAAW,EAAE,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;MACtE,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,uCAAuC,CAAC,CAAC,CAAC;MAC1F,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,sBAAsB,CAAC,CAAC,CAAC;KACrD,CAAC,OAAO,CAAC,EAAE;MACV,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;MACf,MAAM,CAAC,IAAI,EAAE,CAAC;KACf;GACF,CAAC,CAAC;CACJ;;ACbD,MAAMA,GAAC,GAAGJ,IAAI,EAAE,CAAC;;AAEjB,MAAMK,cAAY,GAAG;EACnB,QAAQ;EACR,QAAQ;EACR,QAAQ;EACR,QAAQ;EACR,WAAW;EACX,WAAW;EACX,KAAK;EACL,KAAK;EACL,KAAK;EACL,OAAO;EACP,SAAS;EACT,QAAQ;EACR,QAAQ;EACR,QAAQ;EACR,OAAO;EACP,OAAO;EACP,OAAO;EACP,cAAc;EACd,cAAc;EACd,aAAa;EACb,aAAa;EACb,cAAc;EACd,cAAc;EACd,OAAO;EACP,OAAO;EACP,MAAM;EACN,MAAM;EACN,OAAO;EACP,OAAO;CACR,CAAC;;AAEF,KAAK,IAAI,CAAC,IAAIA,cAAY,EAAE;EAC1BD,GAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,2CAA2C,CAAC,EAAE,CAAC,MAAM,KAAK;IACrE,IAAI;MACF,MAAM,CAAC,IAAI,EAAE,QAAQ,CAAC,GAAG,OAAO,EAAE,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;MAC3D,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,4CAA4C,CAAC,CAAC,CAAC;MACnG,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,sBAAsB,CAAC,CAAC,CAAC;KACrD,CAAC,OAAO,CAAC,EAAE;MACV,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;MACf,MAAM,CAAC,IAAI,EAAE,CAAC;KACf;GACF,CAAC,CAAC;CACJ;;AC5CD,MAAMA,GAAC,GAAGJ,IAAI,EAAE,CAAC;;AAEjB,MAAMK,cAAY,GAAG;EACnB,CAAC,OAAO,CAAC;EACT,CAAC,SAAS,CAAC;EACX,CAAC,SAAS,CAAC;EACX,CAAC,WAAW,CAAC;EACb,CAAC,YAAY,CAAC;EACd,CAAC,cAAc,CAAC;EAChB,CAAC,cAAc,CAAC;CACjB,CAAC;;AAEF,KAAK,IAAI,CAAC,IAAIA,cAAY,EAAE;EAC1BD,GAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,yCAAyC,CAAC,EAAE,CAAC,MAAM,KAAK;IACnE,IAAI;MACF,MAAM,CAAC,IAAI,EAAE,QAAQ,CAAC,GAAG,iBAAiB,EAAE,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;MAC1E,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,wBAAwB,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,2CAA2C,CAAC,CAAC,CAAC;MAC5G,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,sBAAsB,CAAC,CAAC,CAAC;KACrD,CAAC,OAAO,CAAC,EAAE;MACV,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;MACf,MAAM,CAAC,IAAI,EAAE,CAAC;KACf;GACF,CAAC,CAAC;CACJ;;ACxBD,MAAMA,GAAC,GAAGJ,IAAI,EAAE,CAAC;;AAEjB,MAAMK,cAAY,GAAG;EACnB,CAAC,MAAM,CAAC;EACR,CAAC,MAAM,CAAC;EACR,CAAC,SAAS,CAAC;EACX,CAAC,SAAS,CAAC;EACX,CAAC,OAAO,CAAC;EACT,CAAC,OAAO,CAAC;CACV,CAAC;;AAEF,KAAK,IAAI,CAAC,IAAIA,cAAY,EAAE;EAC1BD,GAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,0CAA0C,CAAC,EAAE,CAAC,MAAM,KAAK;IACpE,IAAI;MACF,MAAM,CAAC,IAAI,EAAE,QAAQ,CAAC,GAAG,aAAa,EAAE,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;MACjE,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,aAAa,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,2CAA2C,CAAC,CAAC,CAAC;MACjG,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,sBAAsB,CAAC,CAAC,CAAC;KACrD,CAAC,OAAO,CAAC,EAAE;MACV,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;MACf,MAAM,CAAC,IAAI,EAAE,CAAC;KACf;GACF,CAAC,CAAC;CACJ;;ACtBD,MAAMA,GAAC,GAAGJ,IAAI,EAAE,CAAC;;AAEjB,MAAMK,cAAY,GAAG;EACnB,MAAM,CAAC,aAAa,CAAC,MAAM,CAAC;EAC5B,MAAM,CAAC,aAAa,CAAC,MAAM,CAAC;EAC5B,MAAM,CAAC,aAAa,CAAC,MAAM,CAAC;EAC5B,MAAM,CAAC,aAAa,CAAC,MAAM,CAAC;EAC5B,MAAM,CAAC,aAAa,CAAC,MAAM,CAAC;EAC5B,MAAM,CAAC,aAAa,CAAC,MAAM,CAAC;CAC7B,CAAC;;AAEF,KAAK,IAAI,CAAC,IAAIA,cAAY,EAAE;EAC1BD,GAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,mDAAmD,CAAC,EAAE,CAAC,MAAM,KAAK;IAC7E,IAAI;MACF,MAAM,CAAC,IAAI,EAAE,QAAQ,CAAC,GAAG,UAAU,EAAE,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;MAC9D,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,4CAA4C,CAAC,CAAC,CAAC;MAC/F,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,sBAAsB,CAAC,CAAC,CAAC;KACrD,CAAC,OAAO,CAAC,EAAE;MACV,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;MACf,MAAM,CAAC,IAAI,EAAE,CAAC;KACf;GACF,CAAC,CAAC;CACJ;;ACtBD,MAAMA,GAAC,GAAGJ,IAAI,EAAE,CAAC;;AAEjB,MAAMK,cAAY,GAAG;EACnB,MAAM,CAAC,aAAa,CAAC,MAAM,CAAC;EAC5B,MAAM,CAAC,aAAa,CAAC,MAAM,CAAC;EAC5B,MAAM,CAAC,aAAa,CAAC,MAAM,CAAC;EAC5B,MAAM,CAAC,aAAa,CAAC,MAAM,CAAC;CAC7B,CAAC;;AAEF,KAAK,IAAI,CAAC,IAAIA,cAAY,EAAE;EAC1BD,GAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,uDAAuD,CAAC,EAAE,CAAC,MAAM,KAAK;IACjF,IAAI;MACF,MAAM,CAAC,IAAI,EAAE,QAAQ,CAAC,GAAG,cAAc,EAAE,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;MAClE,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,gDAAgD,CAAC,CAAC,CAAC;MACvG,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,sBAAsB,CAAC,CAAC,CAAC;KACrD,CAAC,OAAO,CAAC,EAAE;MACV,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;MACf,MAAM,CAAC,IAAI,EAAE,CAAC;KACf;GACF,CAAC,CAAC;CACJ;;ACnBD,MAAMA,GAAC,GAAGJ,IAAI,EAAE,CAAC;;AAEjBI,GAAC,CAAC,IAAI,CAAC,qCAAqC,EAAE,MAAM,IAAI;EACtD,MAAM,CAAC,IAAI,CAAC,GAAGH,cAAO,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC;EAC1C,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,UAAU,EAAE,wCAAwC,CAAC,CAAC;CACrF,CAAC,CAAC;;AAEHG,GAAC,CAAC,IAAI,CAAC,2CAA2C,EAAE,MAAM,IAAI;EAC5D,MAAM,CAAC,IAAI,CAAC,GAAGH,cAAO,CAAC,YAAY,CAAC,CAAC,UAAU,CAAC,CAAC,EAAE,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;EAChF,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,iBAAiB,EAAE,iDAAiD,CAAC,CAAC;CACrG,CAAC,CAAC;;AAEHG,GAAC,CAAC,IAAI,CAAC,0CAA0C,EAAE,MAAM,IAAI;EAC3D,MAAM,CAAC,IAAI,CAAC,GAAGH,cAAO,CAAC,YAAY,CAAC,eAAe,CAAC,EAAE,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;EACnF,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,gBAAgB,EAAE,gDAAgD,CAAC,CAAC;CACnG,CAAC,CAAC;;AAEHG,GAAC,CAAC,IAAI,CAAC,qDAAqD,EAAE,MAAM,IAAI;EACtE,MAAM,CAAC,IAAI,CAAC,GAAGH,cAAO,CAAC,YAAY,CAAC,UAAU,CAAC,EAAE,cAAc,CAAC,WAAW,CAAC,CAAC;EAC7E,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,wBAAwB,EAAE,4CAA4C,CAAC,CAAC;CACvG,CAAC,CAAC;;AAEHG,GAAC,CAAC,IAAI,CAAC,uFAAuF,EAAE,MAAM,IAAI;EACxG,MAAM,CAAC,IAAI,CAAC,GAAGH,cAAO,CAAC,YAAY,CAAC,UAAU,CAAC,EAAE,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;EAC9E,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,UAAU,EAAE,wCAAwC,CAAC,CAAC;CACrF,CAAC,CAAC;;AAEHG,GAAC,CAAC,IAAI,CAAC,mDAAmD,EAAE,MAAM,IAAI;EACpE,MAAM,CAAC,IAAI,CAAC,GAAGH,cAAO,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;EACzE,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,cAAc,EAAE,6CAA6C,CAAC,CAAC;CAC9F,CAAC,CAAC;;AAEHG,GAAC,CAAC,IAAI,CAAC,sEAAsE,EAAE,MAAM,IAAI;EACvF,MAAM,CAAC,IAAI,CAAC,GAAGH,cAAO,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;EAC1E,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,UAAU,EAAE,gDAAgD,CAAC,CAAC;CAC7F,CAAC,CAAC;;AAEHG,GAAC,CAAC,IAAI,CAAC,kCAAkC,EAAE,MAAM,IAAI;EACnD,MAAM,CAAC,IAAI,CAAC,GAAGH,cAAO,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;EACxE,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,UAAU,EAAE,wCAAwC,CAAC,CAAC;CACrF,CAAC,CAAC;;AAEHG,GAAC,CAAC,IAAI,CAAC,kCAAkC,EAAE,MAAM,IAAI;EACnD,MAAM,CAAC,IAAI,CAAC,GAAGH,cAAO,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;EACzE,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,UAAU,EAAE,wCAAwC,CAAC,CAAC;CACrF,CAAC,CAAC;;AAEHG,GAAC,CAAC,IAAI,CAAC,uCAAuC,EAAE,MAAM,IAAI;EACxD,MAAM,CAAC,IAAI,CAAC,GAAGH,cAAO,CAAC,YAAY,CAAC,CAAC;EACrC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;EACX,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,cAAc,EAAE,6CAA6C,CAAC,CAAC;CAC9F,CAAC,CAAC;;AAEHG,GAAC,CAAC,IAAI,CAAC,uCAAuC,EAAE,MAAM,IAAI;EACxD,MAAM,CAAC,IAAI,CAAC,GAAGH,cAAO,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;EAC1E,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,cAAc,EAAE,6CAA6C,CAAC,CAAC;CAC9F,CAAC,CAAC;;AAEHG,GAAC,CAAC,IAAI,CAAC,mEAAmE,EAAE,MAAM,IAAI;EACpF,MAAM,CAAC,IAAI,CAAC,GAAGH,cAAO,CAAC,YAAY,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;EAC5E,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,aAAa,EAAE,4CAA4C,CAAC,CAAC;CAC5F,CAAC,CAAC;;AAEHG,GAAC,CAAC,IAAI,CAAC,mEAAmE,EAAE,MAAM,IAAI;EACpF,MAAM,CAAC,IAAI,CAAC,GAAGH,cAAO,CAAC,YAAY,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;EAC5E,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,aAAa,EAAE,4CAA4C,CAAC,CAAC;CAC5F,CAAC,CAAC;;AAEHG,GAAC,CAAC,IAAI,CAAC,0CAA0C,EAAE,MAAM,IAAI;EAC3D,MAAM,CAAC,IAAI,CAAC,GAAGH,cAAO,CAAC,YAAY,CAAC,WAAW,CAAC,EAAE,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;EAC/E,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,QAAQ,EAAE,8CAA8C,CAAC,CAAC;CACzF,CAAC,CAAC;;ACxEH,MAAMG,GAAC,GAAGJ,IAAI,EAAE,CAAC;;AAEjB,MAAMK,cAAY,GAAG;EACnB,WAAW;EACX,aAAa;EACb,cAAc;EACd,6CAA6C;CAC9C,CAAC;;AAEF,KAAK,IAAI,CAAC,IAAIA,cAAY,EAAE;EAC1BD,GAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,4CAA4C,CAAC,EAAE,CAAC,MAAM,KAAK;IACtE,IAAI;MACF,MAAM,CAAC,IAAI,EAAE,QAAQ,CAAC,GAAG,qBAAqB,EAAE,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;MACzE,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,2CAA2C,CAAC,CAAC,CAAC;MAC5F,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,sBAAsB,CAAC,CAAC,CAAC;KACrD,CAAC,OAAO,CAAC,EAAE;MACV,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;MACf,MAAM,CAAC,IAAI,EAAE,CAAC;KACf;GACF,CAAC,CAAC;CACJ;;ACnBD;;;;;;;;;;;;;;;;;AAiBA,AAAO,MAAM,OAAO,GAAG,CAAC,IAAI,EAAEH,UAAO,KAAK;EACxC,IAAI,OAAO,GAAG,cAAc,CAAC,WAAW,GAAG,cAAc,CAAC,eAAe,CAAC;EAC1E,AACA,MAAM,MAAM,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;EAClC,MAAM,WAAW,GAAG,EAAE,IAAI,CAAC,IAAI;IAC7B,AACA,EAAE,EAAE,CAAC;GACN,CAAC;EACF,OAAO;IACL,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;MACrB,OAAO,IAAI,EAAE;QACX,IAAI,MAAM,CAAC,IAAI,KAAK,IAAI,EAAE;UACxB,OAAO;SACR;QACD,MAAMA,UAAO,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;OAChC;KACF;IACD,WAAW,EAAE,WAAW,CAAC,MAAM;MAC7B,OAAO,IAAI,cAAc,CAAC,WAAW,CAAC;KACvC,CAAC;IACF,cAAc,EAAE,WAAW,CAAC,MAAM;MAChC,OAAO,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC;KACxC,CAAC;IACF,eAAe,EAAE,WAAW,CAAC,MAAM;MACjC,OAAO,IAAI,cAAc,CAAC,eAAe,CAAC;KAC3C,CAAC;IACF,kBAAkB,EAAE,WAAW,CAAC,MAAM;MACpC,OAAO,IAAI,CAAC,cAAc,CAAC,eAAe,CAAC;KAC5C,CAAC;IACF,GAAG,CAAC,GAAG;MACL,OAAO,MAAM,CAAC,GAAG,EAAE,CAAC;KACrB;GACF;CACF,CAAC;;AAEF,IAAI,aAAa,GAAG,CAAC,IAAI,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC;AACrC,MAAM,cAAc,GAAG;EACrB,OAAO,EAAE,cAAc;EACvB,aAAa,EAAE,eAAe;EAC9B,QAAQ,EAAE,eAAe,CAAC,QAAQ;EAClC,MAAM,EAAE,aAAa;CACtB,CAAC;;;;AAIF,AAAO,MAAM,QAAQ,GAAG,WAAW,IAAI,EAAE,UAACA,UAAO,GAAG,cAAc,iBAAEK,gBAAa,GAAG,eAAe,EAAE,MAAM,EAAE,QAAQ,CAAC,GAAG,cAAc,EAAE;EACvI,MAAM,UAAU,GAAG,cAAc,CAAC,MAAM,IAAI,aAAa,CAAC,CAAC;EAC3D,MAAM,OAAO,GAAG,WAAW,CAAC,QAAQ,IAAIA,gBAAa,CAAC,QAAQ,CAAC,CAAC;EAChE,MAAM,SAAS,GAAG,IAAI,IAAI,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC;EACpD,MAAM,MAAM,GAAG,OAAO,CAAC,IAAI,EAAEL,UAAO,CAAC,CAAC;;EAEtC,IAAI,iBAAiB,GAAG,EAAE,CAAC;;EAE3B,KAAK,IAAI,CAAC,IAAI,SAAS,CAAC,MAAM,CAAC,EAAE;IAC/B,MAAM,CAAC,CAAC;;IAER,IAAI,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,IAAI,CAAC,EAAE;;;MAGvC,IAAI,gBAAgB,CAAC,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,EAAE;QACzC,MAAM,CAAC,WAAW,EAAE,CAAC;OACtB,MAAM;QACL,MAAM,CAAC,cAAc,EAAE,CAAC;OACzB;;;MAGD,IAAI,CAAC,CAAC,IAAI,KAAK,UAAU,CAAC,YAAY,IAAI,CAAC,CAAC,IAAI,KAAK,UAAU,CAAC,cAAc,EAAE;QAC9E,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAC1B,MAAM,CAAC,kBAAkB,EAAE,CAAC;QAC5B,MAAM,CAAC,WAAW,EAAE,CAAC;OACtB,MAAM,IAAI,CAAC,CAAC,IAAI,KAAK,UAAU,CAAC,YAAY,EAAE;QAC7C,iBAAiB,CAAC,GAAG,EAAE,CAAC;OACzB;;;MAGD,IAAI,iBAAiB,CAAC,MAAM,EAAE;;QAE5B,MAAM,qBAAqB,GAAG,iBAAiB,CAAC,MAAM,GAAG,CAAC,CAAC;;QAE3D,IAAI,CAAC,CAAC,QAAQ,KAAK,GAAG,EAAE;UACtB,iBAAiB,CAAC,qBAAqB,CAAC,GAAG,iBAAiB,CAAC,qBAAqB,CAAC,GAAG,CAAC,CAAC;UACxF,MAAM,CAAC,eAAe,EAAE,CAAC;SAC1B;;QAED,IAAI,CAAC,CAAC,QAAQ,KAAK,GAAG,EAAE;UACtB,IAAI,OAAO,GAAG,iBAAiB,CAAC,qBAAqB,CAAC,GAAG,iBAAiB,CAAC,qBAAqB,CAAC,GAAG,CAAC,CAAC;UACtG,IAAI,OAAO,KAAK,CAAC,EAAE;YACjB,MAAM,CAAC,kBAAkB,EAAE,CAAC;WAC7B;SACF;OACF;KACF;GACF;CACF;;AChHD,gBAAeD,IAAI,EAAE;GAClB,IAAI,CAAC,+DAA+D,EAAE,CAAC,IAAI;IAC1E,MAAM,MAAM,GAAG,CAAC,GAAG,QAAQ,CAAC,eAAe,CAAC,CAAC,CAAC;IAC9C,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,EAAE;MACvC,UAAU,CAAC,UAAU;MACrBO,eAAc,CAAC,GAAG,CAAC,GAAG,CAAC;MACvB,UAAU,CAAC,UAAU;MACrBA,eAAc,CAAC,GAAG,CAAC,GAAG,CAAC;MACvB,UAAU,CAAC,cAAc;KAC1B,CAAC,CAAC;GACJ,CAAC;GACD,IAAI,CAAC,+DAA+D,EAAE,CAAC,IAAI;IAC1E,MAAM,MAAM,GAAG,CAAC,GAAG,QAAQ,CAAC,cAAc,CAAC,CAAC,CAAC;IAC7C,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,EAAE;MACvC,UAAU,CAAC,UAAU;MACrBA,eAAc,CAAC,GAAG,CAAC,GAAG,CAAC;MACvB,UAAU,CAAC,wBAAwB;KACpC,CAAC,CAAC;GACJ,CAAC;GACD,IAAI,CAAC,0EAA0E,EAAE,CAAC,IAAI;IACrF,MAAM,MAAM,GAAG,CAAC,GAAG,QAAQ,CAAC,wBAAwB,CAAC,CAAC,CAAC;IACvD,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,EAAE;MACvC,UAAU,CAAC,YAAY;MACvB,UAAU,CAAC,UAAU;MACrBA,eAAc,CAAC,GAAG,CAAC,GAAG,CAAC;MACvB,UAAU,CAAC,UAAU;MACrB,UAAU,CAAC,YAAY;KACxB,CAAC,CAAC;GACJ,CAAC;GACD,IAAI,CAAC,0EAA0E,EAAE,CAAC,IAAI;IACrF,MAAM,MAAM,GAAG,CAAC,GAAG,QAAQ,CAAC,6BAA6B,CAAC,CAAC,CAAC;IAC5D,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,EAAE;MACvCA,eAAc,CAAC,GAAG,CAAC,IAAI,CAAC;MACxBA,eAAc,CAAC,GAAG,CAAC,GAAG,CAAC;MACvB,UAAU,CAAC,UAAU;MACrBA,eAAc,CAAC,GAAG,CAAC,GAAG,CAAC;MACvBA,eAAc,CAAC,GAAG,CAAC,GAAG,CAAC;MACvB,UAAU,CAAC,UAAU;MACrBA,eAAc,CAAC,GAAG,CAAC,GAAG,CAAC;MACvBA,eAAc,CAAC,GAAG,CAAC,MAAM,CAAC;MAC1BA,eAAc,CAAC,GAAG,CAAC,GAAG,CAAC;MACvB,UAAU,CAAC,UAAU;MACrBA,eAAc,CAAC,GAAG,CAAC,GAAG,CAAC;KACxB,CAAC,CAAC;GACJ,CAAC;GACD,IAAI,CAAC,0EAA0E,EAAE,CAAC,IAAI;IACrF,MAAM,MAAM,GAAG,CAAC,GAAG,QAAQ,CAAC,oCAAoC,CAAC,CAAC,CAAC;IACnE,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,EAAE;MACvC,UAAU,CAAC,YAAY;MACvB,UAAU,CAAC,UAAU;MACrBA,eAAc,CAAC,GAAG,CAAC,GAAG,CAAC;MACvB,UAAU,CAAC,UAAU;MACrB,UAAU,CAAC,cAAc;MACzB,UAAU,CAAC,UAAU;MACrB,UAAU,CAAC,YAAY;KACxB,CAAC,CAAC;GACJ,CAAC;GACD,IAAI,CAAC,0EAA0E,EAAE,CAAC,IAAI;IACrF,MAAM,MAAM,GAAG,CAAC,GAAG,QAAQ,CAAC,yBAAyB,CAAC,CAAC,CAAC;IACxD,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,EAAE;MACvC,UAAU,CAAC,YAAY;MACvBA,eAAc,CAAC,GAAG,CAAC,GAAG,CAAC;MACvBA,eAAc,CAAC,GAAG,CAAC,GAAG,CAAC;MACvB,UAAU,CAAC,UAAU;MACrBA,eAAc,CAAC,GAAG,CAAC,GAAG,CAAC;MACvB,UAAU,CAAC,aAAa;MACxBA,eAAc,CAAC,GAAG,CAAC,GAAG,CAAC;MACvBA,eAAc,CAAC,GAAG,CAAC,GAAG,CAAC;MACvB,UAAU,CAAC,YAAY;KACxB,CAAC,CAAC;GACJ,CAAC,CAAC;;AC5DLP,IAAI,EAAE;GACH,IAAI,CAACQ,CAAQ,CAAC;GACd,IAAI,CAACC,GAAW,CAAC;GACjB,IAAI,CAACC,GAAW,CAAC;GACjB,IAAI,CAACC,GAAQ,CAAC;GACd,IAAI,CAACC,GAAO,CAAC;GACb,IAAI,CAACC,GAAO,CAAC;GACb,IAAI,CAACC,GAAW,CAAC;GACjB,IAAI,CAACC,GAAe,CAAC;GACrB,IAAI,CAACC,GAAS,CAAC;GACf,IAAI,CAACf,GAAO,CAAC;GACb,IAAI,CAAC,SAAS,CAAC;GACf,GAAG,EAAE;;;;"}