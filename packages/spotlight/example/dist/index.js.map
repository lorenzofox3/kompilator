{"version":3,"file":"index.js","sources":["../../../tokenizer/src/source.js","../../../tokenizer/src/tokens.js","../../../tokenizer/src/utils.js","../../../tokenizer/src/chars.js","../../../tokenizer/src/scanners.js","../../../tokenizer/src/index.js","../../src/index.js","../index.js"],"sourcesContent":["//todo put track loc as an option ?\nexport const sourceStream = (code) => {\n  const lineTerminatorRegexp = /[\\u000a\\u000d\\u2028\\u2029]/g;\n  let index = 0;\n  let col = 0;\n  let line = 1;\n\n  const test = (regexp) => nextStretch().search(regexp) === 0;\n  const nextSubStr = (count = 1) => code.substr(index, count);\n  const seeNextAt = (offset = 0) => code[index + offset];\n  const nextStretch = () => nextSubStr(3); //we need three chars to be really sure of the current lexical production (0x3...)\n  const loc = () => ({col, line});\n\n  const advance = (number = 1) => {\n    let lastLineIndex = 0;\n    // console.log(`col: ${col}`);\n    // console.log(`line: ${line}`);\n    const stretch = nextSubStr(number);\n    // console.log(`symbols: ${stretch}`);\n    // console.log('-------')\n    while (lineTerminatorRegexp.test(stretch)) {\n      line += 1;\n      col = 0;\n      lastLineIndex = lineTerminatorRegexp.lastIndex;\n    }\n    col += (number - lastLineIndex);\n    index += number;\n  };\n\n  const stream = {\n    loc,\n    test,\n    nextSubStr,\n    seeNextAt,\n    //advance stream\n    match (regexp) {\n      regexp.lastIndex = index;\n      const [rawValue] = regexp.exec(code);\n      advance(rawValue.length);\n      return rawValue;\n    },\n    //advance stream\n    read (length) {\n      const s = this.nextSubStr(length);\n      advance(length);\n      return s;\n    }\n  };\n\n  Object.defineProperty(stream, 'done', {\n    get () {\n      return code[index] === void 0;\n    }\n  });\n  Object.defineProperty(stream, 'index', {\n    get () {\n      return index;\n    }\n  });\n\n  return stream;\n};","export const categories = {\n  WhiteSpace: 0,\n  LineTerminator: 1,\n  SingleLineComment: 2,\n  MultiLineComment: 3,\n  Punctuator: 4,\n  Identifier: 5,\n  NumericLiteral: 6,\n  StringLiteral: 7,\n  RegularExpressionLiteral: 8,\n  Template: 9,\n  TemplateHead: 10,\n  TemplateMiddle: 11,\n  TemplateTail: 12\n};\n\n//defined as keywords\n//todo check async, let ?\nconst keywords = 'await break case catch class const continue debugger default delete do else export extends finally for function if import in instanceof new return super switch this throw try typeof var void while with yield'.split(' ');\nconst futureReservedKeyword = ['enum'];\nconst reservedKeywords = keywords.concat(futureReservedKeyword, ['null', 'true', 'false']);\n\n//defined as punctuators\nexport const puncutators = `{ ( ) [ ] . ... ; , < > <= >= == != === !== + - * % ** ++ -- << >> >>> & | ^ ! ~ && || ? : = += -= *= %= **= <<= >>= >>>= &= |= ^= => / /= }`.split(' ');\n\nexport const allowRegexpAfter = 'case delete do else in instanceof new return throw typeof void { ( [ . ; , < > <= >= == != === !== + - * << >> >>> & | ^ ! ~ && || ? : = += -= *= %= <<= >>= >>>= &= |= ^= /='.split(' ');\n\nconst createLanguageToken = (symbol, value) => {\n  return Object.freeze(Object.assign(Object.create(null, {\n    type: {\n      get () {\n        return this; //type is an alias to itself (so we can use in Maps as we would to for other categories such literals, etc)\n      }\n    }\n  }), {\n    value: value !== void  0 ? value : symbol,\n    rawValue: symbol,\n    isReserved: reservedKeywords.includes(symbol)\n  }));\n};\n\n//create a token table\nexport const tokenRegistry = () => {\n  const ecmaScriptTokens = puncutators.concat(keywords, futureReservedKeyword)\n    .map(symbol => ([symbol, createLanguageToken(symbol)]));\n  ecmaScriptTokens.push(['null', createLanguageToken('null', null)]);\n  ecmaScriptTokens.push(['true', createLanguageToken('true', true)]);\n  ecmaScriptTokens.push(['false', createLanguageToken('false', false)]);\n  ecmaScriptTokens.push(['of', createLanguageToken('of')]);\n\n  const tokenMap = new Map(ecmaScriptTokens);\n\n  return {\n    get (key) {\n      return tokenMap.get(key)\n    },\n    evaluate (lexeme) {\n      if (!tokenMap.has(lexeme.rawValue)) {\n        switch (lexeme.type) {\n          case categories.StringLiteral:\n            return Object.assign(lexeme, {\n              value: lexeme.rawValue.substr(1, lexeme.rawValue.length - 2),\n              isReserved: false\n            });\n          case categories.NumericLiteral:\n            return Object.assign(lexeme, {value: Number(lexeme.rawValue), isReserved: false});\n          case categories.RegularExpressionLiteral:\n            return Object.assign(lexeme, {isReserved: false, value: new RegExp(lexeme.pattern, lexeme.flags)});\n          default:\n            return Object.assign(lexeme, {isReserved: false, value: lexeme.rawValue});\n        }\n      }\n      return tokenMap.get(lexeme.rawValue);\n    },\n    addToken () {\n      throw new Error('not implemented');\n    }\n  }\n};\n\nexport default tokenRegistry();","export const lazyMapWith = (fn) => function* (iterator) {\n  for (let i of iterator) {\n    yield fn(i);\n  }\n};\n\nexport const lazyFilterWith = fn => function* (iterator) {\n  for (let i of iterator) {\n    if (fn(i)) {\n      yield i;\n    }\n  }\n};\n\nexport const syntacticFlags = {\n  allowRegexp: 1 << 0,\n  inTemplateSubstitution: 1 << 1\n};","export const CHAR_STAR = '*';\nexport const CHAR_SLASH = '/';\nexport const MULTI_LINE_COMMENT_START = '/*';\nexport const SINGLE_LINE_COMMENT_START = '//';\nexport const CHAR_BACKSLASH = '\\\\';\nexport const CHAR_SINGLE_QUOTE = \"'\";\nexport const CHAR_DOUBLE_QUOTE = '\"';\nexport const CHAR_LEFT_BRACKET = '[';\nexport const CHAR_RIGHT_BRACKET = ']';\nexport const CHAR_DOT = '.';\nexport const SPREAD = '...';\nexport const CHAR_TEMPLATE_QUOTE = '`';\nexport const CHAR_DOLLAR = '$';\nexport const CHAR_BRACE_OPEN = '{';\nexport const CHAR_BRACE_CLOSE = '}';","import {\n  categories,\n  puncutators\n} from \"./tokens\";\nimport * as chars from \"./chars\";\nimport {syntacticFlags} from \"./utils\";\n\nconst lexemeFromRegExp = (regExp, category) => sourceStream => ({type: category, rawValue: sourceStream.match(regExp)});\nconst testFromRegExp = regExp => sourceStream => sourceStream.test(regExp);\nconst productionFromRegexp = ({test, lexeme, category}) => () => {\n  //we create regexp dynamically so they are not global to every instance of the scanner\n  const testRegexp = new RegExp(test);\n  const lexemeRegexp = new RegExp(lexeme, 'y');\n  return {\n    test: testFromRegExp(testRegexp),\n    lexeme: lexemeFromRegExp(lexemeRegexp, category)\n  }\n};\n\nexport const numbers = productionFromRegexp({\n  category: categories.NumericLiteral,\n  test: `^(?:[1-9]|\\\\.\\\\d|0[1-9]?|0[xX][0-9a-fA-F]|0[bB][01]|0[oO][0-7])`,\n  lexeme: `0[xX][0-9a-fA-F]+|0[bB][01]+|0[oO][0-7]+|(?:(?:\\\\d+(?:\\\\.\\\\d*)?|\\\\.\\\\d+)(?:[eE][-+]?\\\\d+)?)`\n});\n\nexport const identifiers = productionFromRegexp({\n  category: categories.Identifier,\n  test: `^[$_a-zA-Z]`,\n  lexeme: `[$_a-zA-Z][$\\\\w]*`\n});\n\nexport const whiteSpace = productionFromRegexp({\n  category: categories.WhiteSpace,\n  test: `^(?:[\\\\u0009\\\\u000b\\\\u000c\\\\u0020\\\\u00a0\\\\ufeff])`,\n  lexeme: `[\\\\u0009\\\\u000b\\\\u000c\\\\u0020\\\\u00a0\\\\ufeff]+`\n});\n\nexport const lineTerminator = productionFromRegexp({\n  category: categories.LineTerminator,\n  test: `^(?:[\\\\u000a\\\\u000d\\\\u2028\\\\u2029])`,\n  lexeme: `[\\\\u000a\\\\u000d\\\\u2028\\\\u2029]+`\n});\n\nexport const singleLineComment = () => {\n  const lexemeRegExp = /\\/\\/.*/y;\n  return {\n    test: (sourceStream) => sourceStream.nextSubStr(2) === chars.SINGLE_LINE_COMMENT_START,\n    lexeme: lexemeFromRegExp(lexemeRegExp, categories.SingleLineComment)\n  };\n};\n\nexport const multiLineComment = () => {\n  const lexeme = (sourceStream, count = 2) => {\n    const next = sourceStream.seeNextAt(count);\n    count++;\n    if (next === chars.CHAR_STAR) {\n      const secondNext = sourceStream.seeNextAt(count);\n      if (secondNext === chars.CHAR_SLASH) {\n        return {\n          type: categories.MultiLineComment,\n          rawValue: sourceStream.read(count + 1)\n        }\n      }\n    }\n    return lexeme(sourceStream, count);\n  };\n  return {\n    test (sourceStream) {\n      return sourceStream.nextSubStr(2) === chars.MULTI_LINE_COMMENT_START;\n    },\n    lexeme\n  };\n};\n\nconst fromQuote = quote => {\n  const fn = (sourceStream, count = 1) => {\n    const next = sourceStream.seeNextAt(count);\n    count += 1;\n    if (next === quote) {\n      return {\n        type: categories.StringLiteral,\n        rawValue: sourceStream.read(count)\n      };\n    }\n    if (next === chars.CHAR_BACKSLASH) {\n      count += 1;\n    }\n    return fn(sourceStream, count);\n  };\n  return fn;\n};\nexport const stringLiteral = () => {\n  const singleQuote = fromQuote(chars.CHAR_SINGLE_QUOTE);\n  const doubleQuote = fromQuote(chars.CHAR_DOUBLE_QUOTE);\n  return {\n    test (sourceStream) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_SINGLE_QUOTE || next === chars.CHAR_DOUBLE_QUOTE;\n    },\n    lexeme (sourceStream) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_DOUBLE_QUOTE ? doubleQuote(sourceStream) : singleQuote(sourceStream);\n    }\n  };\n};\n\nexport const punctuators = (punctuatorList = puncutators) => {\n\n  const sizeOnePunctuatorList = punctuatorList.filter(p => p.length === 1);\n  const sizeTwoPunctuatorList = punctuatorList.filter(p => p.length === 2);\n  const sizeThreePunctuatorList = punctuatorList.filter(p => p.length === 3);\n  const sizeFourPunctuatorList = punctuatorList.filter(p => p.length === 4);\n\n  //micro optimization (this function will run often)\n  const isInPunctuatorList = (str) => {\n    switch (str.length) {\n      case 2:\n        return sizeTwoPunctuatorList.includes(str);\n      case 3:\n        return sizeThreePunctuatorList.includes(str);\n      case 4:\n        return sizeFourPunctuatorList.includes(str);\n      default:\n        return false;\n    }\n  };\n  const lexeme = (sourceStream, count = 1) => {\n    const nextStretch = sourceStream.nextSubStr(count + 1);\n    if (!isInPunctuatorList(nextStretch) || nextStretch.length !== count + 1 /*End of file */) {\n      return {\n        type: categories.Punctuator,\n        rawValue: sourceStream.read(count)\n      };\n    }\n    return lexeme(sourceStream, count + 1);\n  };\n  const lexemeFromDot = sourceStream => ({\n    type: categories.Punctuator,\n    rawValue: (sourceStream.nextSubStr(3) === chars.SPREAD) ? sourceStream.read(3) : sourceStream.read(1)\n  });\n  return {\n    test (sourceStream, context) {\n      const next = sourceStream.seeNextAt();\n      switch (next) {\n        case chars.CHAR_SLASH:\n          return ~context & syntacticFlags.allowRegexp;\n        case chars.CHAR_BRACE_CLOSE:\n          return ~context & syntacticFlags.inTemplateSubstitution;\n        default:\n          return sizeOnePunctuatorList.includes(next);\n      }\n    },\n    lexeme: sourceStream => sourceStream.seeNextAt() === chars.CHAR_DOT ? lexemeFromDot(sourceStream) : lexeme(sourceStream)\n  };\n};\n\nconst scanRegExpBody = (sourceStream, count = 1) => {\n  const next = sourceStream.seeNextAt(count);\n  count += 1;\n  switch (next) {\n    case chars.CHAR_SLASH:\n      return count;\n    case chars.CHAR_LEFT_BRACKET: {\n      // slash are \"escaped\" in a regexp class\n      count = scanRegExpClass(sourceStream, count);//+1\n      break;\n    }\n    case chars.CHAR_BACKSLASH: {\n      count += 1;\n      break;\n    }\n  }\n  return scanRegExpBody(sourceStream, count);\n};\nconst scanRegExpClass = (sourceStream, count) => {\n  const next = sourceStream.seeNextAt(count);\n  count += 1;\n  switch (next) {\n    case chars.CHAR_RIGHT_BRACKET:\n      return count;\n    case chars.CHAR_BACKSLASH:\n      count += 1\n  }\n  return scanRegExpClass(sourceStream, count);\n};\n\nconst identifierPart = /[$\\w]/;\nconst scanRegExpFlags = (sourceStream, count) => {\n  const next = sourceStream.seeNextAt(count);\n  if (!next || !identifierPart.test(next)) {\n    return count;\n  }\n  return scanRegExpFlags(sourceStream, count + 1);\n};\n\nexport const regularExpression = () => {\n  return {\n    test (sourceStream, context) {\n      const next = sourceStream.seeNextAt();\n      return (context & syntacticFlags.allowRegexp) && next === chars.CHAR_SLASH;\n    },\n    lexeme (sourceStream) {\n      const body = scanRegExpBody(sourceStream);\n      const withFlags = scanRegExpFlags(sourceStream, body);\n      const rawValue = sourceStream.read(withFlags);\n      return {\n        type: categories.RegularExpressionLiteral,\n        rawValue,\n        pattern: rawValue.substr(1, body - 2),\n        flags: rawValue.substr(body, withFlags - body)\n      };\n    }\n  };\n};\n\nconst templateOrPart = (onExit = categories.Template, onFollow = categories.TemplateHead) => {\n  const fn = (sourceStream, count = 1) => {\n    const next = sourceStream.seeNextAt(count);\n    count += 1;\n    if (next === chars.CHAR_TEMPLATE_QUOTE) {\n      return {\n        type: onExit,\n        rawValue: sourceStream.read(count)\n      };\n    }\n\n    if (next === chars.CHAR_DOLLAR && sourceStream.seeNextAt(count) === chars.CHAR_BRACE_OPEN) {\n      return {\n        type: onFollow,\n        rawValue: sourceStream.read(count + 1)\n      };\n    }\n\n    if (next === chars.CHAR_BACKSLASH) {\n      count += 1;\n    }\n\n    return fn(sourceStream, count);\n\n  };\n  return fn;\n};\nconst headOrTemplate = templateOrPart();\nexport const templateHeadOrLiteral = () => {\n  return {\n    test (sourceStream) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_TEMPLATE_QUOTE;\n    },\n    lexeme (sourceStream) {\n      return headOrTemplate(sourceStream);\n    }\n  };\n};\n\nconst middleOrTail = templateOrPart(categories.TemplateTail, categories.TemplateMiddle);\nexport const templateTailOrMiddle = () => {\n  return {\n    test (sourceStream, context) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_BRACE_CLOSE && (context & syntacticFlags.inTemplateSubstitution);\n    },\n    lexeme (sourceStream) {\n      return middleOrTail(sourceStream);\n    }\n  }\n};\n\nexport const ECMAScriptLexicalGrammar = [\n  whiteSpace,\n  lineTerminator,\n  numbers,\n  singleLineComment,\n  multiLineComment,\n  punctuators,\n  identifiers,\n  regularExpression,\n  stringLiteral,\n  templateHeadOrLiteral,\n  templateTailOrMiddle\n];\n\nexport const scanner = (lexicalRules = ECMAScriptLexicalGrammar.map(g => g())) => {\n  return (source, context) => {\n    const rule = lexicalRules.find(lr => lr.test(source, context));\n    if (rule === void 0) {\n      throw new Error(`could not understand the symbol ${source.seeNextAt()}`);\n    }\n    return rule.lexeme(source);\n  };\n};\n\nexport default scanner();\n","import {sourceStream} from \"./source\";\nimport {allowRegexpAfter, categories} from \"./tokens\";\nimport {syntacticFlags, lazyFilterWith, lazyMapWith} from \"./utils\";\nimport {default as defaultScanner} from './scanners';\nimport {default as defaultRegistry} from './tokens';\nimport * as chars from \"./chars\";\n\n/* Note\n\nwe could greatly improve perf by directly yielding filtered (and evaluated token?) at the scanner level instead of passing every lexeme through a lazy stream combinators pipe chain,\nhowever we would lost the great flexibility we have here !\n\nfor example if we simply ignored white space, line terminators, etc.\nour filter combinator would have to run much less (at least for big files)\n\nbottom line: we value more modularity and flexibility of the system over performance\n\ntodo: later we can give ability to the consumer to configure the scanner to perform better\n\n*/\n\n\n//return an iterable sequence of lexemes (note it can only be consumed once like a generator)\n//The consumer (like a parser) will have to handle the syntactic state and the token evaluation by itself\nexport const lexemes = (code, scanner) => {\n  let context = syntacticFlags.allowRegexp;\n  const source = sourceStream(code);\n  return {\n    * [Symbol.iterator] () {\n      while (true) {\n        if (source.done === true) {\n          return;\n        }\n        yield scanner(source, context);\n      }\n    },\n    allowRegexp () {\n      context |= syntacticFlags.allowRegexp;\n    },\n    disallowRegexp () {\n      context &= ~syntacticFlags.allowRegexp;\n    },\n    allowRightBracePunctuator () {\n      context |= syntacticFlags.inTemplateSubstitution;\n    },\n    disallow () {\n      context &= ~syntacticFlags.inTemplateSubstitution;\n    },\n    loc () {\n      return source.loc();\n    }\n  }\n};\n\nlet defaultFilter = t => t.type >= 4;\nconst defaultOptions = {\n  scanner: defaultScanner,\n  tokenRegistry: defaultRegistry,\n  evaluate: defaultRegistry.evaluate,\n  filter: defaultFilter\n};\n\n// a standalone tokenizer (ie uses some heuristics based on the last meaningful token to know how to scan a slash)\n// https://stackoverflow.com/questions/5519596/when-parsing-javascript-what-determines-the-meaning-of-a-slash\nexport const tokenize = function* (code, {scanner = defaultScanner, tokenRegistry = defaultRegistry, filter, evaluate} = defaultOptions) {\n  const filterFunc = lazyFilterWith(filter || defaultFilter);\n  const mapFunc = lazyMapWith(evaluate || tokenRegistry.evaluate);\n  const filterMap = iter => mapFunc(filterFunc(iter));\n  const stream = lexemes(code, scanner);\n\n  let isInSubstitution = false;\n  let pendingBracePairs = 0;\n\n  for (let t of filterMap(stream)) {\n    yield t;\n    //meaningful tokens\n    if (Object.is(t.type, t) || t.type >= 4) {\n\n      //heuristic for regexp context\n      if (allowRegexpAfter.includes(t.rawValue)) {\n        stream.allowRegexp();\n      } else {\n        stream.disallowRegexp();\n      }\n\n      if (isInSubstitution === true && t.rawValue === chars.CHAR_BRACE_OPEN) {\n        pendingBracePairs++;\n        stream.exitTemplateSubstitution();\n      }\n\n      if (isInSubstitution === true && t.rawValue === chars.CHAR_BRACE_CLOSE) {\n        pendingBracePairs--;\n        if (pendingBracePairs === 0) {\n          stream.enterTemplateSubstitution();\n        }\n      }\n\n      //template literal substitution\n      if (t.type === categories.TemplateHead || t.type === categories.TemplateMiddle) {\n        isInSubstitution = true;\n        pendingBracePairs = 0;\n        stream.allowRegexp();\n        stream.enterTemplateSubstitution();\n      } else if (t.type === categories.TemplateTail) {\n        isInSubstitution = false;\n        stream.exitTemplateSubstitution();\n      }\n    }\n  }\n};","import {tokenize} from \"@kompilator/tokenizer\";\nimport {categories, tokenRegistry} from \"../../tokenizer/src/tokens\";\n\nconst classNames = {\n  keyword: 'sl-k',\n  punctuator: 'sl-p',\n  comment: 'sl-c',\n  identifier: 'sl-i',\n  literal: 'sl-l',\n};\nconst lineTerminatorRegex = /[\\u000a\\u000d\\u2028\\u2029]/;\n\n// we use our own token registry so we can refer to it when mapping tokens to classNames\nconst defaultTokenRegistry = tokenRegistry();\n\nconst freshLine = () => {\n  const line = document.createElement('div');\n  line.classList.add('sl-line');\n  return line;\n};\n\nconst withLine = ({count}) => function* (iterable) {\n  let i, fragment, line;\n\n  const reset = () => {\n    i = 0;\n    fragment = document.createDocumentFragment();\n    line = freshLine();\n  };\n\n  reset();\n\n  for (let {node, token} of iterable) {\n\n    if (token.type !== categories.LineTerminator) {\n      line.appendChild(node);\n    } else {\n      i++;\n      fragment.appendChild(line);\n      line = freshLine();\n    }\n\n    if (i >= count) {\n      yield fragment;\n      reset();\n    }\n  }\n\n  //remaining\n  fragment.appendChild(line);\n  yield fragment;\n};\n\nexport const spotlight = ({tokens = defaultTokenRegistry, lineCount = 100} = {\n  tokens: defaultTokenRegistry,\n  lineCount: 100\n}) => {\n\n  const block = withLine({count: lineCount});\n\n  function* highlight (code) {\n    //we return every lexemes (including white spaces, etc) so we can respect the code format\n    for (let t of tokenize(code, {tokenRegistry: tokens, filter: () => true})) {\n      let node = t.type === categories.WhiteSpace || t.type === categories.LineTerminator ?\n        document.createTextNode(t.rawValue) :\n        document.createElement('span');\n      switch (t.type) {\n        case categories.WhiteSpace:\n        case categories.LineTerminator:\n          break;\n        case categories.SingleLineComment: {\n          node.classList.add(classNames.comment);\n          break;\n        }\n        case categories.MultiLineComment: {\n          //we split by lines\n          const split = t.rawValue.split(lineTerminatorRegex);\n          for (let i = 0; i < split.length; i++) {\n            const n = document.createElement('span');\n            n.classList.add(classNames.comment);\n            n.textContent = split[i];\n            yield {node: n, token: t};\n            if (i + 1 < split.length) {\n              yield {node: document.createTextNode('\\n'), token: {type: categories.LineTerminator}};\n            }\n          }\n          continue;\n        }\n        case categories.NumericLiteral:\n        case categories.StringLiteral:\n        case categories.RegularExpressionLiteral:\n        case tokens.get('null'):\n        case tokens.get('true'):\n        case tokens.get('false'): {\n          node.classList.add(classNames.literal);\n          break;\n        }\n        case categories.Identifier: {\n          node.classList.add(classNames.identifier);\n          break;\n        }\n        default: {\n          const className = t.isReserved ? classNames.keyword : classNames.punctuator;\n          node.classList.add(className);\n        }\n      }\n      node.textContent = t.rawValue;\n      yield {token: t, node};\n    }\n  }\n\n  return code => block(highlight(code))[Symbol.iterator]();\n};\n\n//default highlight;\nconst highlight = spotlight();\nconst defaultSelector = 'code.sl-js';\n\n//bootstrap takes all <code> elements matching a css selector and highlight its content by chunk (to let the browser render by parts)\nexport const bootstrap = ({selector = defaultSelector} = {selector: defaultSelector}) => {\n\n  //sequentially highlight code (in the order of the document)\n  for (let t of document.querySelectorAll(selector)) {\n    const code = t.textContent;\n    t.innerHTML = '';\n    const blocks = highlight(code)[Symbol.iterator]();\n\n    const append = () => {\n\n      const {value, done} = blocks.next();\n\n      if (value) {\n        t.append(value);\n      }\n\n      if (done === false) {\n        setTimeout(append, 60); //let a window of time for the browser to render\n      }\n    };\n    append();\n  }\n};","import {spotlight, bootstrap} from \"../src/index\";\n\n(async function () {\n\n  // 1. automatic bootstrap\n  bootstrap({selector: '#bootstrap'});\n\n  // 2. interesting use case: using intersection observer api to render very long file efficiently\n  const lineCount = 200;\n  const highlight = spotlight({lineCount: lineCount});\n  const container = document.getElementById('long-file');\n  const resp = await fetch('./jquery.js'); // > 8000 lines\n  const text = await resp.text();\n\n  const stream = highlight(text)[Symbol.iterator]();\n\n  container.innerHTML = '';\n\n  container.append(stream.next().value);\n\n  let strech = 1;\n  let sentinel = container.children[Math.floor(lineCount / 2)];\n\n  const options = {\n    threshold: 0\n  };\n\n  const observer = new IntersectionObserver(([entry]) => {\n\n    if (entry.isIntersecting) {\n\n      const {value, done} = stream.next();\n      strech++;\n      if (value) {\n        container.append(value);\n      }\n      if (done === true) {\n        observer.disconnect();\n      } else {\n        observer.unobserve(sentinel);\n        let sentinelIndex = Math.floor((strech - 1) * lineCount + lineCount / 4);\n        console.log('sentinel index: ' + sentinelIndex);\n        sentinel = container.children[sentinelIndex];\n        observer.observe(sentinel);\n      }\n    }\n  }, options);\n\n  observer.observe(sentinel);\n\n})();"],"names":["chars.SINGLE_LINE_COMMENT_START","chars.CHAR_STAR","chars.CHAR_SLASH","chars.MULTI_LINE_COMMENT_START","chars.CHAR_BACKSLASH","chars.CHAR_SINGLE_QUOTE","chars.CHAR_DOUBLE_QUOTE","chars.SPREAD","chars.CHAR_BRACE_CLOSE","chars.CHAR_DOT","chars.CHAR_LEFT_BRACKET","chars.CHAR_RIGHT_BRACKET","chars.CHAR_TEMPLATE_QUOTE","chars.CHAR_DOLLAR","chars.CHAR_BRACE_OPEN","scanner","tokenRegistry"],"mappings":"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"}