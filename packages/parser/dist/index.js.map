{"version":3,"file":"index.js","sources":["../../tokenizer/src/utils.js","../../tokenizer/src/source.js","../../tokenizer/src/tokens.js","../../tokenizer/src/chars.js","../../tokenizer/src/scanners.js","../../tokenizer/src/index.js","../src/utils.js","../src/ast.js","../src/expressions.js","../src/array.js","../src/function.js","../src/object.js","../src/statements.js","../src/class.js","../src/tokens.js","../src/source.js","../src/index.js"],"sourcesContent":["export const lazyMapWith = (fn) => function* (iterator) {\n  for (let i of iterator) {\n    yield fn(i);\n  }\n};\n\nexport const lazyFilterWith = fn => function* (iterator) {\n  for (let i of iterator) {\n    if (fn(i)) {\n      yield i;\n    }\n  }\n};\n\nexport const syntacticFlags = {\n  allowRegexp: 1 << 0,\n  allowRightBrace: 1 << 1\n};","//todo put track loc as an option ?\nexport const sourceStream = (code) => {\n  const lineTerminatorRegexp = /[\\u000a\\u000d\\u2028\\u2029]/g;\n  let index = 0;\n  let col = 0;\n  let line = 1;\n\n  const test = (regexp) => nextStretch().search(regexp) === 0;\n  const nextSubStr = (count = 1) => code.substr(index, count);\n  const seeNextAt = (offset = 0) => code[index + offset];\n  const nextStretch = () => nextSubStr(3); //we need three chars to be really sure of the current lexical production (0x3...)\n  const loc = () => ({col, line});\n\n  const advance = (number = 1) => {\n    let lastLineIndex = 0;\n    // console.log(`col: ${col}`);\n    // console.log(`line: ${line}`);\n    const stretch = nextSubStr(number);\n    // console.log(`symbols: ${stretch}`);\n    // console.log('-------')\n    while (lineTerminatorRegexp.test(stretch)) {\n      line += 1;\n      col = 0;\n      lastLineIndex = lineTerminatorRegexp.lastIndex;\n    }\n    col += (number - lastLineIndex);\n    index += number;\n  };\n\n  const stream = {\n    loc,\n    test,\n    nextSubStr,\n    seeNextAt,\n    //advance stream\n    match (regexp) {\n      regexp.lastIndex = index;\n      const [rawValue] = regexp.exec(code);\n      advance(rawValue.length);\n      return rawValue;\n    },\n    //advance stream\n    read (length) {\n      const s = this.nextSubStr(length);\n      advance(length);\n      return s;\n    }\n  };\n\n  Object.defineProperty(stream, 'done', {\n    get () {\n      return code[index] === void 0;\n    }\n  });\n  Object.defineProperty(stream, 'index', {\n    get () {\n      return index;\n    }\n  });\n\n  return stream;\n};","export const categories = {\n  WhiteSpace: 0,\n  LineTerminator: 1,\n  SingleLineComment: 2,\n  MultiLineComment: 3,\n  Punctuator: 4,\n  Identifier: 5,\n  NumericLiteral: 6,\n  StringLiteral: 7,\n  RegularExpressionLiteral: 8,\n  Template: 9,\n  TemplateHead: 10,\n  TemplateMiddle: 11,\n  TemplateTail: 12\n};\n\n//defined as keywords\n//todo check async, let, static ?\nconst keywords = 'await break case catch class const continue debugger default delete do else export extends finally for function if import in instanceof new return super switch this throw try typeof var void while with yield'.split(' ');\nconst futureReservedKeyword = ['enum'];\nconst reservedKeywords = keywords.concat(futureReservedKeyword, ['null', 'true', 'false']);\n\n//defined as punctuators\nexport const puncutators = `{ ( ) [ ] . ... ; , < > <= >= == != === !== + - * % ** ++ -- << >> >>> & | ^ ! ~ && || ? : = += -= *= %= **= <<= >>= >>>= &= |= ^= => / /= }`.split(' ');\n\nexport const allowRegexpAfter = 'case delete do else in instanceof new return throw typeof void { ( [ . ; , < > <= >= == != === !== + - * << >> >>> & | ^ ! ~ && || ? : = += -= *= %= <<= >>= >>>= &= |= ^= /='.split(' ');\n\nconst createLanguageToken = (symbol, value) => {\n  return Object.freeze(Object.assign(Object.create(null, {\n    type: {\n      get () {\n        return this; //type is an alias to itself (so we can use in Maps as we would to for other categories such literals, etc)\n      }\n    }\n  }), {\n    value: value !== void  0 ? value : symbol,\n    rawValue: symbol,\n    isReserved: reservedKeywords.includes(symbol)\n  }));\n};\n\n//create a token table\nexport const tokenRegistry = () => {\n  const ecmaScriptTokens = puncutators.concat(keywords, futureReservedKeyword)\n    .map(symbol => ([symbol, createLanguageToken(symbol)]));\n  ecmaScriptTokens.push(['null', createLanguageToken('null', null)]);\n  ecmaScriptTokens.push(['true', createLanguageToken('true', true)]);\n  ecmaScriptTokens.push(['false', createLanguageToken('false', false)]);\n  ecmaScriptTokens.push(['of', createLanguageToken('of')]);\n  ecmaScriptTokens.push(['let', createLanguageToken('let')]);\n  ecmaScriptTokens.push(['get', createLanguageToken('get')]);\n  ecmaScriptTokens.push(['set', createLanguageToken('set')]);\n  ecmaScriptTokens.push(['static', createLanguageToken('static')]);\n\n  const tokenMap = new Map(ecmaScriptTokens);\n\n  return {\n    get (key) {\n      return tokenMap.get(key)\n    },\n    evaluate (lexeme) {\n      if (!tokenMap.has(lexeme.rawValue)) {\n        switch (lexeme.type) {\n          case categories.StringLiteral:\n            return Object.assign(lexeme, {\n              value: lexeme.rawValue.substr(1, lexeme.rawValue.length - 2),\n              isReserved: false\n            });\n          case categories.NumericLiteral:\n            return Object.assign(lexeme, {value: Number(lexeme.rawValue), isReserved: false});\n          case categories.RegularExpressionLiteral:\n            return Object.assign(lexeme, {isReserved: false, value: new RegExp(lexeme.pattern, lexeme.flags)});\n          default:\n            return Object.assign(lexeme, {isReserved: false, value: lexeme.rawValue});\n        }\n      }\n      return tokenMap.get(lexeme.rawValue);\n    },\n    addToken () {\n      throw new Error('not implemented');\n    }\n  }\n};\n\nexport default tokenRegistry();","export const CHAR_STAR = '*';\nexport const CHAR_SLASH = '/';\nexport const MULTI_LINE_COMMENT_START = '/*';\nexport const SINGLE_LINE_COMMENT_START = '//';\nexport const CHAR_BACKSLASH = '\\\\';\nexport const CHAR_SINGLE_QUOTE = \"'\";\nexport const CHAR_DOUBLE_QUOTE = '\"';\nexport const CHAR_LEFT_BRACKET = '[';\nexport const CHAR_RIGHT_BRACKET = ']';\nexport const CHAR_DOT = '.';\nexport const SPREAD = '...';\nexport const CHAR_TEMPLATE_QUOTE = '`';\nexport const CHAR_DOLLAR = '$';\nexport const CHAR_BRACE_OPEN = '{';\nexport const CHAR_BRACE_CLOSE = '}';","import {\n  categories,\n  puncutators\n} from \"./tokens\";\nimport * as chars from \"./chars\";\nimport {syntacticFlags} from \"./utils\";\n\nconst lexemeFromRegExp = (regExp, category) => sourceStream => ({type: category, rawValue: sourceStream.match(regExp)});\nconst testFromRegExp = regExp => sourceStream => sourceStream.test(regExp);\nconst productionFromRegexp = ({test, lexeme, category}) => () => {\n  //we create regexp dynamically so they are not global to every instance of the scanner\n  const testRegexp = new RegExp(test);\n  const lexemeRegexp = new RegExp(lexeme, 'y');\n  return {\n    test: testFromRegExp(testRegexp),\n    lexeme: lexemeFromRegExp(lexemeRegexp, category)\n  }\n};\n\nexport const numbers = productionFromRegexp({\n  category: categories.NumericLiteral,\n  test: `^(?:[1-9]|\\\\.\\\\d|0[1-9]?|0[xX][0-9a-fA-F]|0[bB][01]|0[oO][0-7])`,\n  lexeme: `0[xX][0-9a-fA-F]+|0[bB][01]+|0[oO][0-7]+|(?:(?:\\\\d+(?:\\\\.\\\\d*)?|\\\\.\\\\d+)(?:[eE][-+]?\\\\d+)?)`\n});\n\nexport const identifiers = productionFromRegexp({\n  category: categories.Identifier,\n  test: `^[$_a-zA-Z]`,\n  lexeme: `[$_a-zA-Z][$\\\\w]*`\n});\n\nexport const whiteSpace = productionFromRegexp({\n  category: categories.WhiteSpace,\n  test: `^(?:[\\\\u0009\\\\u000b\\\\u000c\\\\u0020\\\\u00a0\\\\ufeff])`,\n  lexeme: `[\\\\u0009\\\\u000b\\\\u000c\\\\u0020\\\\u00a0\\\\ufeff]+`\n});\n\nexport const lineTerminator = productionFromRegexp({\n  category: categories.LineTerminator,\n  test: `^(?:[\\\\u000a\\\\u000d\\\\u2028\\\\u2029])`,\n  lexeme: `[\\\\u000a\\\\u000d\\\\u2028\\\\u2029]+`\n});\n\nexport const singleLineComment = () => {\n  const lexemeRegExp = /\\/\\/.*/y;\n  return {\n    test: (sourceStream) => sourceStream.nextSubStr(2) === chars.SINGLE_LINE_COMMENT_START,\n    lexeme: lexemeFromRegExp(lexemeRegExp, categories.SingleLineComment)\n  };\n};\n\nexport const multiLineComment = () => {\n  const lexeme = (sourceStream, count = 2) => {\n    const next = sourceStream.seeNextAt(count);\n    count++;\n    if (next === chars.CHAR_STAR) {\n      const secondNext = sourceStream.seeNextAt(count);\n      if (secondNext === chars.CHAR_SLASH) {\n        return {\n          type: categories.MultiLineComment,\n          rawValue: sourceStream.read(count + 1)\n        }\n      }\n    }\n    return lexeme(sourceStream, count);\n  };\n  return {\n    test (sourceStream) {\n      return sourceStream.nextSubStr(2) === chars.MULTI_LINE_COMMENT_START;\n    },\n    lexeme\n  };\n};\n\nconst fromQuote = quote => {\n  const fn = (sourceStream, count = 1) => {\n    const next = sourceStream.seeNextAt(count);\n    count += 1;\n    if (next === quote) {\n      return {\n        type: categories.StringLiteral,\n        rawValue: sourceStream.read(count)\n      };\n    }\n    if (next === chars.CHAR_BACKSLASH) {\n      count += 1;\n    }\n    return fn(sourceStream, count);\n  };\n  return fn;\n};\nexport const stringLiteral = () => {\n  const singleQuote = fromQuote(chars.CHAR_SINGLE_QUOTE);\n  const doubleQuote = fromQuote(chars.CHAR_DOUBLE_QUOTE);\n  return {\n    test (sourceStream) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_SINGLE_QUOTE || next === chars.CHAR_DOUBLE_QUOTE;\n    },\n    lexeme (sourceStream) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_DOUBLE_QUOTE ? doubleQuote(sourceStream) : singleQuote(sourceStream);\n    }\n  };\n};\n\nexport const punctuators = (punctuatorList = puncutators) => {\n\n  const sizeOnePunctuatorList = punctuatorList.filter(p => p.length === 1);\n  const sizeTwoPunctuatorList = punctuatorList.filter(p => p.length === 2);\n  const sizeThreePunctuatorList = punctuatorList.filter(p => p.length === 3);\n  const sizeFourPunctuatorList = punctuatorList.filter(p => p.length === 4);\n\n  //micro optimization (this function will run often)\n  const isInPunctuatorList = (str) => {\n    switch (str.length) {\n      case 2:\n        return sizeTwoPunctuatorList.includes(str);\n      case 3:\n        return sizeThreePunctuatorList.includes(str);\n      case 4:\n        return sizeFourPunctuatorList.includes(str);\n      default:\n        return false;\n    }\n  };\n  const lexeme = (sourceStream, count = 1) => {\n    const nextStretch = sourceStream.nextSubStr(count + 1);\n    if (!isInPunctuatorList(nextStretch) || nextStretch.length !== count + 1 /*End of file */) {\n      return {\n        type: categories.Punctuator,\n        rawValue: sourceStream.read(count)\n      };\n    }\n    return lexeme(sourceStream, count + 1);\n  };\n  const lexemeFromDot = sourceStream => ({\n    type: categories.Punctuator,\n    rawValue: (sourceStream.nextSubStr(3) === chars.SPREAD) ? sourceStream.read(3) : sourceStream.read(1)\n  });\n  return {\n    test (sourceStream, context) {\n      const next = sourceStream.seeNextAt();\n      switch (next) {\n        case chars.CHAR_SLASH:\n          return ~context & syntacticFlags.allowRegexp;\n        case chars.CHAR_BRACE_CLOSE:\n          return context & syntacticFlags.allowRightBrace;\n        default:\n          return sizeOnePunctuatorList.includes(next);\n      }\n    },\n    lexeme: sourceStream => sourceStream.seeNextAt() === chars.CHAR_DOT ? lexemeFromDot(sourceStream) : lexeme(sourceStream)\n  };\n};\n\nconst scanRegExpBody = (sourceStream, count = 1) => {\n  const next = sourceStream.seeNextAt(count);\n  count += 1;\n  switch (next) {\n    case chars.CHAR_SLASH:\n      return count;\n    case chars.CHAR_LEFT_BRACKET: {\n      // slash are \"escaped\" in a regexp class\n      count = scanRegExpClass(sourceStream, count);//+1\n      break;\n    }\n    case chars.CHAR_BACKSLASH: {\n      count += 1;\n      break;\n    }\n  }\n  return scanRegExpBody(sourceStream, count);\n};\nconst scanRegExpClass = (sourceStream, count) => {\n  const next = sourceStream.seeNextAt(count);\n  count += 1;\n  switch (next) {\n    case chars.CHAR_RIGHT_BRACKET:\n      return count;\n    case chars.CHAR_BACKSLASH:\n      count += 1\n  }\n  return scanRegExpClass(sourceStream, count);\n};\n\nconst identifierPart = /[$\\w]/;\nconst scanRegExpFlags = (sourceStream, count) => {\n  const next = sourceStream.seeNextAt(count);\n  if (!next || !identifierPart.test(next)) {\n    return count;\n  }\n  return scanRegExpFlags(sourceStream, count + 1);\n};\n\nexport const regularExpression = () => {\n  return {\n    test (sourceStream, context) {\n      const next = sourceStream.seeNextAt();\n      return (context & syntacticFlags.allowRegexp) && next === chars.CHAR_SLASH;\n    },\n    lexeme (sourceStream) {\n      const body = scanRegExpBody(sourceStream);\n      const withFlags = scanRegExpFlags(sourceStream, body);\n      const rawValue = sourceStream.read(withFlags);\n      return {\n        type: categories.RegularExpressionLiteral,\n        rawValue,\n        pattern: rawValue.substr(1, body - 2),\n        flags: rawValue.substr(body, withFlags - body)\n      };\n    }\n  };\n};\n\nconst templateOrPart = (onExit = categories.Template, onFollow = categories.TemplateHead) => {\n  const fn = (sourceStream, count = 1) => {\n    const next = sourceStream.seeNextAt(count);\n    count += 1;\n    if (next === chars.CHAR_TEMPLATE_QUOTE) {\n      return {\n        type: onExit,\n        rawValue: sourceStream.read(count)\n      };\n    }\n\n    if (next === chars.CHAR_DOLLAR && sourceStream.seeNextAt(count) === chars.CHAR_BRACE_OPEN) {\n      return {\n        type: onFollow,\n        rawValue: sourceStream.read(count + 1)\n      };\n    }\n\n    if (next === chars.CHAR_BACKSLASH) {\n      count += 1;\n    }\n\n    return fn(sourceStream, count);\n\n  };\n  return fn;\n};\nconst headOrTemplate = templateOrPart();\nexport const templateHeadOrLiteral = () => {\n  return {\n    test (sourceStream) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_TEMPLATE_QUOTE;\n    },\n    lexeme (sourceStream) {\n      return headOrTemplate(sourceStream);\n    }\n  };\n};\n\nconst middleOrTail = templateOrPart(categories.TemplateTail, categories.TemplateMiddle);\nexport const templateTailOrMiddle = () => {\n  return {\n    test (sourceStream, context) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_BRACE_CLOSE && (~context & syntacticFlags.allowRightBrace);\n    },\n    lexeme (sourceStream) {\n      return middleOrTail(sourceStream);\n    }\n  }\n};\n\nexport const ECMAScriptLexicalGrammar = [\n  whiteSpace,\n  lineTerminator,\n  numbers,\n  singleLineComment,\n  multiLineComment,\n  punctuators,\n  identifiers,\n  regularExpression,\n  stringLiteral,\n  templateHeadOrLiteral,\n  templateTailOrMiddle\n];\n\nexport const scanner = (lexicalRules = ECMAScriptLexicalGrammar.map(g => g())) => {\n  return (source, context) => {\n    const rule = lexicalRules.find(lr => lr.test(source, context));\n    if (rule === void 0) {\n      throw new Error(`could not understand the symbol ${source.seeNextAt()}`);\n    }\n    return rule.lexeme(source);\n  };\n};\n\nexport default scanner();\n","import {sourceStream} from \"./source\";\nimport {allowRegexpAfter, categories} from \"./tokens\";\nimport {syntacticFlags, lazyFilterWith, lazyMapWith} from \"./utils\";\nimport {default as defaultScanner} from './scanners';\nimport {default as defaultRegistry} from './tokens';\n\n/* Note\n\nwe could greatly improve perf by directly yielding filtered (and evaluated token?) at the scanner level instead of passing every lexeme through a lazy stream combinators pipe chain,\nhowever we would lost the great flexibility we have here !\n\nfor example if we simply ignored white space, line terminators, etc.\nour filter combinator would have to run much less (at least for big files)\n\nbottom line: we value more modularity and flexibility of the system over performance\n\ntodo: later we can give ability to the consumer to configure the scanner to perform better\n\n*/\n\n\n//return an iterable sequence of lexemes (note it can only be consumed once like a generator)\n//The consumer (like a parser) will have to handle the syntactic state and the token evaluation by itself\nexport const lexemes = (code, scanner) => {\n  let context = syntacticFlags.allowRegexp | syntacticFlags.allowRightBrace;\n  let previousContext = context;\n  const source = sourceStream(code);\n  const holdContext = fn => _ => {\n    previousContext = context;\n    fn();\n  };\n  return {\n    * [Symbol.iterator] () {\n      while (true) {\n        if (source.done === true) {\n          return;\n        }\n        yield scanner(source, context);\n      }\n    },\n    restoreContext () {\n      context = previousContext\n    },\n    allowRegexp: holdContext(() => {\n      context |= syntacticFlags.allowRegexp;\n    }),\n    disallowRegexp: holdContext(() => {\n      context &= ~syntacticFlags.allowRegexp;\n    }),\n    allowRightBrace: holdContext(() => { // as punctuator vs template middle/tail\n      context |= syntacticFlags.allowRightBrace;\n    }),\n    disallowRightBrace: holdContext(() => {\n      context &= ~syntacticFlags.allowRightBrace;\n    }),\n    loc () {\n      return source.loc();\n    }\n  }\n};\n\nlet defaultFilter = t => t.type >= 4;\nconst defaultOptions = {\n  scanner: defaultScanner,\n  tokenRegistry: defaultRegistry,\n  evaluate: defaultRegistry.evaluate,\n  filter: defaultFilter\n};\n\n// a standalone tokenizer (ie uses some heuristics based on the last meaningful token to know how to scan a slash)\n// https://stackoverflow.com/questions/5519596/when-parsing-javascript-what-determines-the-meaning-of-a-slash\nexport const tokenize = function* (code, {scanner = defaultScanner, tokenRegistry = defaultRegistry, filter, evaluate} = defaultOptions) {\n  const filterFunc = lazyFilterWith(filter || defaultFilter);\n  const mapFunc = lazyMapWith(evaluate || tokenRegistry.evaluate);\n  const filterMap = iter => mapFunc(filterFunc(iter));\n  const stream = lexemes(code, scanner);\n\n  let substitutionStack = []; //pending braces\n\n  for (let t of filterMap(stream)) {\n    yield t;\n    //meaningful tokens\n    if (Object.is(t.type, t) || t.type >= 4) {\n\n      //heuristic for regexp context\n      if (allowRegexpAfter.includes(t.rawValue)) {\n        stream.allowRegexp();\n      } else {\n        stream.disallowRegexp();\n      }\n\n      //template literal substitution\n      if (t.type === categories.TemplateHead || t.type === categories.TemplateMiddle) {\n        substitutionStack.push(0);\n        stream.disallowRightBrace();\n        stream.allowRegexp();\n      } else if (t.type === categories.TemplateTail) {\n        substitutionStack.pop();\n      }\n\n      //without context we need to backtrack braces\n      if (substitutionStack.length) {\n\n        const lastSubstitutionIndex = substitutionStack.length - 1;\n\n        if (t.rawValue === '{') {\n          substitutionStack[lastSubstitutionIndex] = substitutionStack[lastSubstitutionIndex] + 1;\n          stream.allowRightBrace();\n        }\n\n        if (t.rawValue === '}') {\n          let pending = substitutionStack[lastSubstitutionIndex] = substitutionStack[lastSubstitutionIndex] - 1;\n          if (pending === 0) {\n            stream.disallowRightBrace();\n          }\n        }\n      }\n    }\n  }\n};","export const composeArrityTwo = (factory, fn) => (a, b) => factory(fn(a, b));\nexport const composeArrityOne = (factory, fn) => _ => factory(fn(_));\nexport const composeArrityThree = (factory, fn) => (a, b, c) => factory(fn(a, b, c));","const nodeFactory = (defaultOrType, proto = null) => {\n  const defaultObj = typeof defaultOrType === 'string' ? {type: defaultOrType} : defaultOrType;\n  return obj => Object.assign(Object.create(proto), defaultObj, obj);\n};\n\nconst yieldArgument = {\n  * [Symbol.iterator] () {\n    yield this.argument;\n  }\n};\nconst yieldLeftRight = {\n  * [Symbol.iterator] () {\n    yield this.left;\n    yield this.right;\n  }\n};\nconst yieldExpression = {\n  * [Symbol.iterator] () {\n    yield this.expression;\n  }\n};\nconst delegateBody = {\n  * [Symbol.iterator] () {\n    yield* this.body;\n  }\n};\nconst delegateElements = {\n  * [Symbol.iterator] () {\n    yield* this.elements;\n  }\n};\nconst delegateProperties = {\n  * [Symbol.iterator] () {\n    yield* this.properties;\n  }\n};\nconst iterateFunction = {\n  * [Symbol.iterator] () {\n    yield this.id;\n    yield* this.params;\n    yield this.body;\n  }\n};\nconst iterateCall = {\n  * [Symbol.iterator] () {\n    yield this.callee;\n    yield* this.arguments;\n  }\n};\nconst iterateProperty = {\n  * [Symbol.iterator] () {\n    yield this.key;\n    yield this.value;\n  }\n};\nconst iterateCondition = {\n  * [Symbol.iterator] () {\n    yield this.test;\n    yield this.consequent;\n    yield this.alternate;\n  }\n};\n\n//pefix nodes\nexport const UnaryExpression = nodeFactory('UnaryExpression', yieldArgument);\nexport const ThisExpression = nodeFactory('ThisExpression');\nexport const Literal = nodeFactory('Literal');\nexport const Identifier = nodeFactory('Identifier');\nexport const UpdateExpression = nodeFactory('UpdateExpression', yieldArgument);\nexport const FunctionExpression = nodeFactory({\n  type: 'FunctionExpression',\n  id: null,\n  async: false,\n  generator: false\n}, iterateFunction);\nexport const ClassExpression = nodeFactory('ClassExpression', delegateBody);\nexport const NewExpression = nodeFactory('NewExpression', iterateCall);\nexport const SpreadElement = nodeFactory('SpreadElement', yieldArgument);\nexport const ArrayExpression = nodeFactory('ArrayExpression', delegateElements);\nexport const ObjectExpression = nodeFactory('ObjectExpression', delegateProperties);\nexport const Property = nodeFactory({\n  type: 'Property',\n  shorthand: false,\n  computed: false,\n  kind: 'init',\n  method: false,\n  value: null\n}, iterateProperty);\n\n//infix nodes\nconst asBinary = type => nodeFactory(type, yieldLeftRight);\nexport const AssignmentExpression = asBinary('AssignmentExpression');\nexport const BinaryExpression = asBinary('BinaryExpression');\nexport const LogicalExpression = asBinary('LogicalExpression');\n\nexport const MemberExpression = nodeFactory('MemberExpression', {\n  * [Symbol.iterator] () {\n    yield this.object;\n    yield this.property;\n  }\n});\nexport const ConditionalExpression = nodeFactory('ConditionalExpression', iterateCondition);\nexport const CallExpression = nodeFactory('CallExpression', iterateCall);\n\nexport const SequenceExpression = nodeFactory('SequenceExpression', {\n  * [Symbol.iterator] () {\n    yield* this.expressions;\n  }\n});\n\n//statements nodes\nexport const IfStatement = nodeFactory('IfStatement', iterateCondition);\nexport const BlockStatement = nodeFactory('BlockStatement', delegateBody);\nexport const ExpressionStatement = nodeFactory('ExpressionStatement', yieldExpression);\nexport const EmptyStatement = nodeFactory('EmptyStatement');\nexport const DebuggerStatement = nodeFactory('DebuggerStatement');\nconst withArgument = (type) => nodeFactory(type, yieldArgument);\nexport const ReturnStatement = withArgument('ReturnStatement');\nexport const BreakStatement = withArgument('BreakStatement');\nexport const ContinueStatement = withArgument('ContinueStatement');\n\nexport const WithStatement = nodeFactory('WithStatement', {\n  * [Symbol.iterator] () {\n    yield this.object;\n    yield this.body;\n  }\n});\nexport const SwitchStatement = nodeFactory('SwitchStatement', {\n  * [Symbol.iterator] () {\n    yield this.discriminant;\n    yield* this.cases;\n  }\n});\nexport const SwitchCase = nodeFactory('SwitchCase', {\n  * [Symbol.iterator] () {\n    yield this.test;\n    yield* this.consequent;\n  }\n});\nexport const ThrowStatement = nodeFactory('ThrowStatement', yieldExpression);\nexport const TryStatement = nodeFactory('TryStatement', {\n  * [Symbol.iterator] () {\n    yield this.block;\n    yield this.handler;\n    yield this.finalizer;\n  }\n});\nexport const CatchClause = nodeFactory('CatchClause', {\n  * [Symbol.iterator] () {\n    yield this.param;\n    yield this.body;\n  }\n});\nexport const WhileStatement = nodeFactory('WhileStatement', {\n  * [Symbol.iterator] () {\n    yield this.test;\n    yield this.body;\n  }\n});\nexport const DoWhileStatement = nodeFactory('DoWhileStatement', {\n  * [Symbol.iterator] () {\n    yield this.body;\n    yield this.test;\n  }\n});\nexport const ForInStatement = nodeFactory('ForInStatement', yieldLeftRight);\nexport const ForStatement = nodeFactory('ForStatement', {\n  * [Symbol.iterator] () {\n    yield this.init;\n    yield this.test;\n    yield this.update;\n  }\n});\nexport const ForOfStatement = nodeFactory('ForOfStatement', yieldLeftRight);\nexport const LabeledStatement = nodeFactory('LabeledStatement', {\n  * [Symbol.iterator] () {\n    yield this.body;\n  }\n});\n\nexport const Program = nodeFactory('Program', delegateBody);\n\n//declarations\nexport const AssignmentPattern = nodeFactory('AssignmentPattern', yieldLeftRight);\nexport const FunctionDeclaration = nodeFactory({\n  type: 'FunctionDeclaration',\n  async: false,\n  generator: false\n}, iterateFunction);\nexport const VariableDeclarator = nodeFactory('VariableDeclarator', {\n  * [Symbol.iterator] () {\n    yield this.id;\n    yield this.init;\n  }\n});\nexport const VariableDeclaration = nodeFactory('VariableDeclaration', {\n  * [Symbol.iterator] () {\n    yield* this.declarations;\n  }\n});\nexport const ArrayPattern = nodeFactory('ArrayPattern', delegateElements);\nexport const RestElement = nodeFactory('RestElement', yieldArgument);\nexport const ObjectPattern = nodeFactory('ObjectPattern', delegateProperties);\nexport const Class = nodeFactory('ClassDeclaration', {\n  * [Symbol.iterator] () {\n    yield this.id;\n    yield this.superClass;\n    yield this.body;\n  }\n});\nexport const ClassBody = nodeFactory('ClassBody', delegateBody);\nexport const MethodDefinition = nodeFactory('MethodDefinition', iterateProperty);\nexport const Super = nodeFactory('Super');\n\n//walk & traverse\nexport function* traverse (node) {\n  yield node;\n  if (node && node[Symbol.iterator]) {\n    for (let child of node) {\n      yield* traverse(child);\n    }\n  }\n}\n\nexport const visitWithAncestors = visitor => node => {\n\n};\nexport const visit = (...visitors) => {\n  const aggregatedVisitor = visitors.reduce((acc, curr) => {\n    for (let nodeType of Object.keys(curr)) {\n      const fns = acc[nodeType] || [];\n      fns.push(curr[nodeType]);\n      acc[nodeType] = fns;\n    }\n    return acc;\n  }, {});\n\n  return node => {\n    for (let n of traverse(node)) {\n      if (n) {\n        if (aggregatedVisitor[n.type]) {\n          for (let vfunc of aggregatedVisitor[n.type]) {\n            vfunc(n);\n          }\n        }\n      }\n    }\n  };\n};\n\n","import {\n  composeArrityOne as Prefix,\n  composeArrityThree as Infix\n} from \"./utils\";\nimport * as ast from \"./ast\";\n\n// expressions based on Javascript operators whether they are \"prefix\" or \"infix\"\n// Note: Functions and Class expressions, Object literals and Array literals are in their own files\n\n//prefix\nconst asValue = (type, key) => Prefix(type, (parser) => {\n  const {value: token} = parser.next();\n  return key ? {[key]: token.value} : {};\n});\nconst asUnaryExpression = (type) => Prefix(type, (parser) => {\n  const {value: token} = parser.next();\n  return {\n    operator: token.value,\n    argument: parser.expression(parser.getPrefixPrecedence(token)),\n    prefix: true\n  };\n});\nexport const parseGroupExpression = (parser) => {\n  parser.expect('(');\n  const exp = parser.expression();\n  parser.expect(')');\n  return exp;\n};\nexport const parseUnaryExpression = asUnaryExpression(ast.UnaryExpression);\nexport const parseThisExpression = asValue(ast.ThisExpression);\nexport const parseLiteralExpression = asValue(ast.Literal, 'value');\nexport const parseIdentifierExpression = asValue(ast.Identifier, 'name');\nexport const parseRegularExpressionLiteral = Prefix(ast.Literal, parser => {\n  const {value: regexp} = parser.next();\n  return {\n    value: regexp.value,\n    regex: {\n      pattern: regexp.value.source,\n      flags: regexp.value.flags\n    }\n  }\n});\nexport const parseUpdateExpressionAsPrefix = asUnaryExpression(ast.UpdateExpression);\nexport const parseNewExpression = Prefix(ast.NewExpression, parser => {\n  const {value: newToken} = parser.expect('new');\n  const callee = parser.expression(parser.getPrefixPrecedence(newToken));\n  return {\n    callee: callee.callee ? callee.callee : callee,\n    arguments: callee.arguments ? callee.arguments : []\n  };\n});\n\n//infix\nconst asBinaryExpression = type => Infix(type, (parser, left, operator) => {\n  return {\n    left,\n    right: parser.expression(parser.getInfixPrecedence(operator)),\n    operator: operator.value\n  };\n});\nexport const parseAssignmentExpression = asBinaryExpression(ast.AssignmentExpression);\nexport const parseBinaryExpression = asBinaryExpression(ast.BinaryExpression);\nexport const parseLogicalExpression = asBinaryExpression(ast.LogicalExpression);\nexport const parseMemberAccessExpression = Infix(ast.MemberExpression, (parser, left, operator) => {\n  const computed = operator === parser.get('[');\n  const node = {\n    object: left,\n    computed: computed,\n    property: computed ? parser.expression() : parseIdentifierExpression(parser)\n  };\n  if (computed) {\n    parser.expect(']');\n  }\n  return node;\n});\nexport const parseUpdateExpression = Infix(ast.UpdateExpression, (parser, left, operator) => ({\n  argument: left,\n  operator: operator.value,\n  prefix: false\n}));\nexport const parseConditionalExpression = Infix(ast.ConditionalExpression, (parser, test) => {\n  const node = {\n    test\n  };\n  const commaPrecedence = parser.getInfixPrecedence(parser.get(','));\n  node.consequent = parser.expression(commaPrecedence);\n  parser.expect(':');\n  node.alternate = parser.expression(commaPrecedence);\n  return node;\n});\nexport const parseSequenceExpression = Infix(ast.SequenceExpression, (parser, left) => {\n  let node = left;\n  const comma = parser.get(',');\n  const next = parser.expression(parser.getInfixPrecedence(comma));\n  if (left.type === 'SequenceExpression') {\n    left.expressions.push(next);\n  } else {\n    node = {\n      expressions: [left, next]\n    }\n  }\n  return node;\n});","import {ArrayExpression, ArrayPattern, RestElement, SpreadElement} from \"./ast\";\nimport {composeArrityOne, composeArrityTwo} from \"./utils\";\nimport {parseAssignmentPattern, parseBindingIdentifierOrPattern} from \"./statements\";\n\n// \"array\" parsing is shared across various components:\n// - as array literals\n// - as array pattern\n\nexport const parseRestElement = composeArrityOne(RestElement, parser => {\n  parser.expect('...');\n  return {\n    argument: parseBindingIdentifierOrPattern(parser)\n  };\n});\nexport const parseSpreadExpression = composeArrityOne(SpreadElement, parser => {\n  parser.expect('...');\n  return {\n    argument: parser.expression(parser.getPrefixPrecedence(parser.get('...')))\n  };\n});\n\nconst parseArrayElision = (parser, elements) => {\n  const {value: next} = parser.lookAhead();\n\n  if (next !== parser.get(',')) {\n    return elements;\n  }\n\n  elements.push(null);\n  parser.eat();\n\n  return parseArrayElision(parser, elements);\n};\nconst arrayElements = (parseEllipsis, process) => {\n  const fn = (parser, elements = []) => {\n    const {value: next} = parser.lookAhead();\n    const comma = parser.get(',');\n\n    if (next === parser.get(']')) {\n      return elements;\n    }\n\n    if (next === parser.get('...')) {\n      elements.push(parseEllipsis(parser));\n      parser.eventually(',');\n      return fn(parser, elements);\n    }\n\n    if (next === comma) {\n      parseArrayElision(parser, elements);\n      return fn(parser, elements);\n    }\n\n    process(parser, elements);\n\n    return fn(parser, elements);\n  };\n  return fn;\n};\nconst parseArrayElements = arrayElements(parseSpreadExpression, (parser, elements) => {\n  elements.push(parser.expression(parser.getInfixPrecedence(parser.get(','))));\n  parser.eventually(',');\n});\nconst parseArrayElementsBindingPattern = arrayElements(parseRestElement, (parser, elements) => {\n  let element = parseBindingIdentifierOrPattern(parser);\n  if (parser.eventually('=')) {\n    element = parseAssignmentPattern(parser, element);\n  }\n  elements.push(element);\n  parser.eventually(',');\n});\n\nexport const parseArrayBindingPattern = composeArrityTwo(ArrayPattern, parser => {\n  parser.expect('[');\n  const node = {\n    elements: parseArrayElementsBindingPattern(parser)\n  };\n  parser.expect(']');\n  return node;\n});\nexport const parseArrayLiteralExpression = composeArrityOne(ArrayExpression, (parser) => {\n  parser.expect('[');\n  const node = {\n    elements: parseArrayElements(parser)\n  };\n  parser.expect(']');\n  return node;\n});","import * as ast from './ast';\nimport {parseIdentifierExpression} from \"./expressions\";\nimport {parseBlockStatement,parseAssignmentPattern, parseBindingIdentifierOrPattern} from \"./statements\";\nimport {composeArrityOne, composeArrityTwo} from \"./utils\";\nimport {parseSpreadExpression,parseRestElement} from \"./array\";\n\n// \"function\" parsing is shared across multiple components and deserves its own module to mutualize code more easily:\n// - as statement aka function declaration\n// - as expression\n// - as arrow function (expression)\n// - as method (within object or class body)\n// - as function call\n\nexport const parseFormalParameters = (parser, parameters = []) => {\n  const {value: next} = parser.lookAhead();\n  const comma = parser.get(',');\n\n  if (next === parser.get(')')) {\n    return parameters;\n  }\n\n  if (next === parser.get('...')) {\n    parameters.push(parseRestElement(parser));\n    return parameters; //rest parameter must be the last\n  }\n\n  //todo no elision & defaultParameters must be last ...\n  if (next !== comma) {\n    let param = parseBindingIdentifierOrPattern(parser);\n    if (parser.eventually('=')) {\n      param = parseAssignmentPattern(parser, param);\n    }\n    parameters.push(param);\n  } else {\n    parser.eat();\n  }\n  return parseFormalParameters(parser, parameters);\n};\nexport const asPropertyFunction = (parser, prop) => {\n  parser.expect('(');\n  const params = parseFormalParameters(parser);\n  parser.expect(')');\n  const body = parseBlockStatement(parser);\n  return Object.assign(prop, {\n    value: ast.FunctionExpression({\n      params,\n      body\n    })\n  });\n};\n\nconst parseParamsAndBody = parser => {\n  parser.expect('(');\n  const params = parseFormalParameters(parser);\n  parser.expect(')');\n  const body = parseBlockStatement(parser);\n  return {params, body};\n};\nexport const parseFunctionDeclaration = composeArrityOne(ast.FunctionDeclaration, parser => {\n  parser.expect('function');\n  const generator = parser.eventually('*');\n  const id = parseIdentifierExpression(parser);\n  return Object.assign({\n    id,\n    generator\n  }, parseParamsAndBody(parser));\n});\n\n//that is a prefix expression\nexport const parseFunctionExpression = composeArrityOne(ast.FunctionExpression, parser => {\n  parser.expect('function');\n  const generator = parser.eventually('*');\n  let id = null;\n  const {value: nextToken} = parser.lookAhead();\n  if (nextToken !== parser.get('(')) {\n    id = parseIdentifierExpression(parser);\n  }\n  return Object.assign({id, generator}, parseParamsAndBody(parser));\n});\n\n//that is an infix expression\nconst parseFunctionCallArguments = (parser, expressions = []) => {\n  const {value: next} = parser.lookAhead();\n  const comma = parser.get(',');\n\n  if (next === parser.get(')')) {\n    return expressions;\n  }\n\n  if (next === parser.get('...')) {\n    expressions.push(parseSpreadExpression(parser));\n    parser.eventually(',');\n    return expressions;\n  }\n\n  expressions.push(parser.expression(parser.getInfixPrecedence(comma)));\n  parser.eventually(','); //todo no elision allowed\n  return parseFunctionCallArguments(parser, expressions);\n};\nexport const parseCallExpression = composeArrityTwo(ast.CallExpression, (parser, callee) => {\n  const node = {\n    callee,\n    arguments: parseFunctionCallArguments(parser)\n  };\n  parser.expect(')');\n  return node;\n});\n\n","import {Property, ObjectExpression,ObjectPattern, Identifier} from \"./ast\"\nimport {composeArrityOne} from \"./utils\";\nimport {categories} from \"../../tokenizer/src/tokens\";\nimport {parseIdentifierExpression} from \"./expressions\";\nimport {asPropertyFunction} from \"./function\";\nimport {parseBindingIdentifierOrPattern, parseAssignmentPattern} from \"./statements\";\n\n// \"object\" parsing is shared across various components:\n// - as object literals\n// - as object pattern\n// - within class bodies as well\n\nconst parseComputedPropertyName = parser => {\n  parser.expect('[');\n  const key = parser.expression();\n  parser.expect(']');\n  return {\n    key,\n    computed: true\n  };\n};\nconst parseLiteralPropertyName = parser => ({key: parser.expression(20), computed: false});// max precedence => a literal or an identifier or a keyword\nexport const parsePropertyName = parser => {\n  const {value: next} = parser.lookAhead();\n  return next === parser.get('[') ?\n    parseComputedPropertyName(parser) :\n    parseLiteralPropertyName(parser)\n};\n\n\nconst parsePropertyDefinition = composeArrityOne(Property, parser => {\n  let {value: next} = parser.lookAhead();\n  let prop;\n  const {value: secondNext} = parser.lookAhead(1);\n\n  //binding reference\n  if (next.type === categories.Identifier && (secondNext === parser.get(',') || secondNext === parser.get('}'))) {\n    const key = parseIdentifierExpression(parser);\n    return {\n      shorthand: true,\n      key,\n      value: key\n    };\n  }\n\n  //can be a getter/setter or a shorthand binding or a property with init\n  if (next === parser.get('get') || next === parser.get('set')) {\n    const {value: accessor} = parser.next();\n    const {value: next} = parser.lookAhead();\n\n    if (next !== parser.get('(') && next !== parser.get(':')) {\n      prop = Object.assign(parsePropertyName(parser), {kind: accessor.rawValue});\n      return asPropertyFunction(parser, prop);\n    }\n\n    prop = {\n      key: Identifier({name: accessor.value})\n    };\n  }\n\n  prop = prop !== void 0 ? prop : parsePropertyName(parser);\n  next = parser.lookAhead().value;\n  if (next === parser.get('(')) {\n    //method\n    return asPropertyFunction(parser, Object.assign(prop, {method: true}));\n  } else if (next === parser.get(':')) {\n    //with initializer\n    parser.expect(':');\n    return Object.assign(prop, {\n      value: parser.expression(parser.getInfixPrecedence(parser.get(',')))\n    });\n  }\n\n  throw new Error(`Unexpected token: expected \":\" or \"(\" but got ${next.rawValue}`);\n\n});\nconst parsePropertyList = (parser, properties = []) => {\n  const {value: nextToken} = parser.lookAhead();\n  if (nextToken === parser.get('}')) {\n    return properties;\n  }\n  if (nextToken !== parser.get(',')) {\n    properties.push(parsePropertyDefinition(parser));\n  } else {\n    parser.eat();\n  }\n  return parsePropertyList(parser, properties);\n};\nexport const parseObjectLiteralExpression = composeArrityOne(ObjectExpression, parser => {\n  parser.expect('{');\n  const node = {\n    properties: parsePropertyList(parser)\n  };\n  parser.expect('}');\n  return node;\n});\n\nconst parseSingleNameBindingProperty = parser => {\n  const key = parseIdentifierExpression(parser);\n  let value = key;\n  let shorthand = false;\n  if (parser.eventually(':')) {\n    value = parseBindingIdentifierOrPattern(parser);\n  } else {\n    shorthand = true;\n    value = key;\n  }\n\n  if (parser.eventually('=')) {\n    value = parseAssignmentPattern(parser, value);\n  }\n  return {shorthand, key, value};\n};\nconst parsePropertyNameProperty = parser => {\n  const property = parsePropertyName(parser);\n  parser.expect(':');\n  return Object.assign(property, {\n    value: parseBindingIdentifierOrPattern(parser)\n  });\n};\nconst parseBindingProperty = parser => {\n  const {value: next} = parser.lookAhead();\n  const property = Property({});\n  return next.type === categories.Identifier ? //identifier but not reserved word\n    Object.assign(property, parseSingleNameBindingProperty(parser)) :\n    Object.assign(property, parsePropertyNameProperty(parser));\n};\nconst parseBindingPropertyList = (parser, properties = []) => {\n  const {value: next} = parser.lookAhead();\n  if (next === parser.get('}')) {\n    return properties;\n  }\n  if (next !== parser.get(',')) {\n    properties.push(parseBindingProperty(parser));\n  } else {\n    parser.eat(); //todo elision not allowed\n  }\n  return parseBindingPropertyList(parser, properties);\n};\nexport const parseObjectBindingPattern = composeArrityOne(ObjectPattern, parser => {\n  parser.expect('{');\n  const node = {\n    properties: parseBindingPropertyList(parser)\n  };\n  parser.expect('}');\n  return node;\n});\n\n","import * as ast from './ast';\nimport {parseIdentifierExpression} from \"./expressions\"\nimport {composeArrityTwo} from \"./utils\";\nimport {parseArrayBindingPattern} from \"./array\";\nimport {parseObjectBindingPattern} from \"./object\";\n\n// statements\n// Note: Function declarations,class declarations, array and object binding pattern are in they own files\n\nconst Statement = (factory, fn) => {\n  if (!fn) {\n    return factory;\n  } else {\n    return composeArrityTwo(factory, fn);\n  }\n};\n\nexport const parseStatementList = (parser, exit = ['}'], statements = []) => {\n  const exitTokens = exit.map(s => parser.get(s)); // todo exit is not consistent with expression parser\n  const {done, value: nextToken} = parser.lookAhead();\n  if (done || exitTokens.includes(nextToken)) {\n    return statements;\n  }\n  statements.push(parseStatement(parser));\n  return parseStatementList(parser, exit, statements);\n};\nexport const withEventualSemiColon = (fn) => parser => {\n  const node = fn(parser);\n  parser.eventually(';');\n  return node;\n};\nexport const parseExpressionOrLabeledStatement = parser => {\n  const {value: nextToken} = parser.lookAhead(1);\n  return nextToken === parser.get(':') ? parseLabeledStatement(parser) : withEventualSemiColon(parseExpressionStatement)(parser);\n};\nexport const parseStatement = (parser) => {\n  const {value: nextToken} = parser.lookAhead();\n  return parser.hasStatement(nextToken) ? parser.getStatement(nextToken)(parser) : withEventualSemiColon(parseExpressionStatement)(parser);\n};\n\nexport const parseIfStatement = Statement(ast.IfStatement, parser => {\n  parser.expect('if');\n  parser.expect('(');\n  const test = parser.expression();\n  parser.expect(')');\n  const consequent = parseStatement(parser);\n  let alternate = null;\n  if (parser.eventually('else')) {\n    alternate = parseStatement(parser);\n  }\n  return {\n    test,\n    consequent,\n    alternate\n  };\n});\n\nexport const parseBlockStatement = Statement(ast.BlockStatement, parser => {\n  parser.expect('{');\n  const node = {\n    body: parseStatementList(parser)\n  };\n  parser.expect('}');\n  return node;\n});\n\nexport const parseExpressionStatement = Statement(ast.ExpressionStatement, parser => ({\n  expression: parser.expression()\n}));\n\nexport const parseEmptyStatement = Statement(ast.EmptyStatement, parser => {\n  parser.expect(';');\n});\n\nexport const parseDebuggerStatement = Statement(ast.DebuggerStatement);\n\nexport const parseReturnStatement = Statement(ast.ReturnStatement, parser => {\n  parser.expect('return');\n  return {\n    argument: parser.expression()\n  };\n});\n\nexport const parseBreakStatement = Statement(ast.BreakStatement, parser => {\n  parser.expect('break');\n  return {\n    label: parser.expression(20)\n  };\n});\n\nexport const parseContinueStatement = Statement(ast.ContinueStatement, parser => {\n  parser.expect('continue');\n  return {\n    label: parser.expression(20)\n  };\n});\n\nexport const parseWithStatement = Statement(ast.WithStatement, parser => {\n  parser.expect('with');\n  parser.expect('(');\n  const object = parser.expression();\n  parser.expect(')');\n  return {\n    object,\n    body: parseStatement(parser)\n  };\n});\n\nexport const parseSwitchStatement = Statement(ast.SwitchStatement, parser => {\n  parser.expect('switch');\n  parser.expect('(');\n  const discriminant = parser.expression();\n  parser.expect(')');\n  parser.expect('{');\n  const cases = parseSwitchCases(parser);\n  parser.expect('}');\n  return {\n    discriminant,\n    cases\n  };\n});\n\nexport const parseSwitchCases = (parser, cases = []) => {\n  const {value: nextToken} = parser.lookAhead();\n  if (nextToken !== parser.get('case') && nextToken !== parser.get('default')) {\n    return cases;\n  }\n  parser.eat();\n  cases.push(parseSwitchCase(parser, nextToken));\n  return parseSwitchCases(parser, cases);\n};\n\nexport const parseSwitchCase = Statement(ast.SwitchCase, (parser, nextToken) => {\n  const {type} = nextToken;\n  const node = {\n    test: type === parser.get('case') ? parser.expression() : null\n  };\n  parser.expect(':');\n  node.consequent = parseStatementList(parser, ['}', 'case', 'default']);\n  return node;\n});\n\nexport const parseThrowStatement = Statement(ast.ThrowStatement, parser => {\n  parser.expect('throw');\n  return {\n    argument: parser.expression()\n  };\n});\n\nexport const parseTryStatement = Statement(ast.TryStatement, parser => {\n  parser.expect('try');\n  const node = {block: parseBlockStatement(parser), handler: null, finalizer: null};\n  if (parser.eventually('catch')) {\n    const handler = {type: 'CatchClause'};\n    parser.expect('(');\n    handler.param = parser.expression();\n    parser.expect(')');\n    handler.body = parseBlockStatement(parser);\n    node.handler = handler;\n  }\n  if (parser.eventually('finally')) {\n    node.finalizer = parseBlockStatement(parser);\n  }\n  return node;\n});\n\nexport const parseWhileStatement = Statement(ast.WhileStatement, parser => {\n  parser.expect('while');\n  parser.expect('(');\n  const node = {\n    test: parser.expression()\n  };\n  parser.expect(')');\n  node.body = parseStatement(parser);\n  return node;\n});\n\nexport const parseDoWhileStatement = Statement(ast.DoWhileStatement, parser => {\n  parser.expect('do');\n  const node = {\n    body: parseStatement(parser)\n  };\n  parser.expect('while');\n  parser.expect('(');\n  node.test = parser.expression();\n  parser.expect(')');\n  return node;\n});\n\nexport const parseAssignmentPattern = Statement(ast.AssignmentPattern, (parser, left) => {\n  return {\n    left,\n    right: parser.expression(parser.getInfixPrecedence(parser.get(',')))\n  };\n});\n\nexport const parseBindingIdentifierOrPattern = parser => {\n  const {value: next} = parser.lookAhead();\n  if (parser.get('{') === next) {\n    return parseObjectBindingPattern(parser);\n  } else if (parser.get('[') === next) {\n    return parseArrayBindingPattern(parser);\n  }\n  return parseIdentifierExpression(parser);\n};\n\nconst asVariableDeclaration = (keyword = 'var') => Statement(ast.VariableDeclaration, parser => {\n  parser.expect(keyword);\n  return {\n    kind: keyword,\n    declarations: parseVariableDeclarators(parser)\n  };\n});\nconst parseVariableDeclarator = Statement(ast.VariableDeclarator, (parser) => {\n  const comma = parser.get(',');\n  const node = {id: parseBindingIdentifierOrPattern(parser), init: null};\n  if (parser.eventually('=')) {\n    node.init = parser.expression(parser.getInfixPrecedence(comma));\n  }\n  return node;\n});\nexport const parseVariableDeclarators = (parser, declarators = []) => {\n  const node = parseVariableDeclarator(parser);\n  const comma = parser.get(',');\n  const {value: nextToken} = parser.lookAhead();\n\n  declarators.push(node);\n\n  if (nextToken !== comma) {\n    return declarators;\n  }\n  parser.eat();\n  return parseVariableDeclarators(parser, declarators);\n};\nexport const parseVariableDeclaration = asVariableDeclaration();\nexport const parseConstDeclaration = asVariableDeclaration('const');\nexport const parseLetDeclaration = asVariableDeclaration('let');\n\nconst getForDerivation = parser => {\n  const {value: nextToken} = parser.lookAhead();\n  switch (nextToken.type) {\n    case parser.get('in'):\n      return asForIn;\n    case parser.get('of'):\n      return asForOf;\n    default:\n      return asFor;\n  }\n};\n\nconst asFor = Statement(ast.ForStatement, (parser, init) => {\n  parser.expect(';');\n  const n = {\n    init,\n    test: parser.expression()\n  };\n  parser.expect(';');\n  n.update = parser.expression();\n  return n;\n});\nconst asForIn = Statement(ast.ForInStatement, (parser, left) => {\n  parser.expect('in');\n  return {\n    left,\n    right: parser.expression()\n  };\n});\nconst asForOf = Statement(ast.ForOfStatement, (parser, left) => {\n  parser.expect('of');\n  return {\n    left,\n    right: parser.expression()\n  };\n});\n\n//todo does not seem to fit all cases\nexport const parseForStatement = parser => {\n  parser.expect('for');\n  parser.expect('(');\n  const {value: token} = parser.lookAhead();\n  let startExpression, node;\n  if (token === parser.get('var')) {\n    startExpression = parseVariableDeclaration(parser);\n  } else if (token === parser.get('const')) {\n    startExpression = parseConstDeclaration(parser);\n  } else if (token === parser.get('let')) {\n    startExpression = parseLetDeclaration(parser);\n  } else {\n    startExpression = parser.expression(-1, [parser.get('in'), parser.get('of')]); //\"in\" is not an operator here !\n  }\n  const derivation = getForDerivation(parser);\n  node = derivation(parser, startExpression);\n  parser.expect(')');\n  node.body = parseStatement(parser);\n  return node;\n};\n\nexport const parseLabeledStatement = Statement(ast.LabeledStatement, parser => {\n  const node = {\n    label: parser.expression(20)\n  };\n  parser.expect(':');\n  node.body = parseStatement(parser);\n  return node;\n});","import {MethodDefinition, ClassBody, ClassExpression, Class} from \"./ast\";\nimport {composeArrityOne} from \"./utils\";\nimport {parseIdentifierExpression} from \"./expressions\";\nimport {categories} from \"../../tokenizer/src/tokens\";\nimport {asPropertyFunction} from \"./function\";\nimport {parsePropertyName} from \"./object\";\n\nconst parseClassMethod = composeArrityOne(MethodDefinition, (parser) => {\n  const isStatic = parser.eventually('static');\n  const {value: next} = parser.lookAhead();\n  const {value: secondNext} = parser.lookAhead(1);\n  let prop;\n\n  if (next === parser.get('get') || next === parser.get('set')) {\n    if (secondNext !== parser.get('(')) {\n      const {value: accessor} = parser.eat();\n      prop = Object.assign(parsePropertyName(parser), {kind: accessor.rawValue});\n    } else {\n      prop = {\n        key: parseIdentifierExpression(parser),\n        computed: false\n      }\n    }\n  }\n\n  prop = prop !== void 0 ? prop : parsePropertyName(parser);\n\n  if (prop.kind === void 0) {\n    prop.kind = prop.key.name === 'constructor' ? 'constructor' : 'method';\n  }\n\n  return Object.assign(asPropertyFunction(parser, prop), {static: isStatic});\n});\nconst parseClassElementList = (parser, elements = []) => {\n  const {value: next} = parser.lookAhead();\n  if (next === parser.get('}')) {\n    return elements;\n  }\n  if (next !== parser.get(';')) {\n    elements.push(parseClassMethod(parser));\n  } else {\n    parser.eat();\n  }\n  return parseClassElementList(parser, elements);\n};\nexport const parseClassBody = composeArrityOne(ClassBody, parser => {\n  parser.expect('{');\n  const node = {\n    body: parseClassElementList(parser)\n  };\n  parser.expect('}');\n  return node;\n});\n\nconst parseClassTail = (parser, id) => {\n  let superClass = null;\n\n  if (parser.eventually('extends')) {\n    superClass = parser.expression();\n  }\n\n  return {\n    id,\n    superClass,\n    body: parseClassBody(parser)\n  };\n};\n\nexport const parseClassDeclaration = composeArrityOne(Class, parser => {\n  parser.expect('class');\n  const id = parseIdentifierExpression(parser);\n  return parseClassTail(parser, id);\n});\n\nexport const parseClassExpression = composeArrityOne(ClassExpression, parser => {\n  parser.expect('class');\n  let id = null;\n  const {value: next} = parser.lookAhead();\n  if (next.type === categories.Identifier) {\n    id = parseIdentifierExpression(parser);\n  }\n  return parseClassTail(parser, id);\n});","import {tokenRegistry, categories} from \"../../tokenizer/src/tokens\";\nimport * as expressions from './expressions';\nimport * as statements from './statements';\nimport {parseArrayLiteralExpression, parseSpreadExpression} from \"./array\";\nimport {parseObjectLiteralExpression} from \"./object\";\nimport {parseClassDeclaration, parseClassExpression} from \"./class\";\nimport {parseFunctionExpression, parseFunctionDeclaration, parseCallExpression} from \"./function\";\n\nexport const ECMAScriptTokenRegistry = () => {\n  const registry = tokenRegistry();\n\n  /**\n   * EXPRESSIONS\n   */\n\n  const prefixMap = new Map();\n  //unary operators\n  prefixMap.set(registry.get('-'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('+'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('!'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('~'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('typeof'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('void'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('delete'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('...'), {parse: parseSpreadExpression, precedence: 1});\n  //update operators\n  prefixMap.set(registry.get('--'), {parse: expressions.parseUpdateExpressionAsPrefix, precedence: 16});\n  prefixMap.set(registry.get('++'), {parse: expressions.parseUpdateExpressionAsPrefix, precedence: 16});\n  //literals\n  prefixMap.set(categories.StringLiteral, {parse: expressions.parseLiteralExpression, precedence: -1});\n  prefixMap.set(categories.NumericLiteral, {parse: expressions.parseLiteralExpression, precedence: -1});\n  prefixMap.set(categories.RegularExpressionLiteral, {\n    parse: expressions.parseRegularExpressionLiteral,\n    precedence: -1\n  });\n  prefixMap.set(registry.get('null'), {parse: expressions.parseLiteralExpression, precedence: -1});\n  prefixMap.set(registry.get('false'), {parse: expressions.parseLiteralExpression, precedence: -1});\n  prefixMap.set(registry.get('true'), {parse: expressions.parseLiteralExpression, precedence: -1});\n  // prefixMap.set(categories.Template, {parse: expressions.parseTemplateLiteral, precedence: -1});\n  // prefixMap.set(categories.TemplateHead, {parse: expressions.parseTemplateLiteral, precedence: -1});\n  prefixMap.set(registry.get('['), {parse: parseArrayLiteralExpression, precedence: -1});\n  prefixMap.set(registry.get('{'), {parse: parseObjectLiteralExpression, precedence: -1});\n  //identifiers\n  prefixMap.set(registry.get('this'), {parse: expressions.parseThisExpression, precedence: -1});\n  prefixMap.set(categories.Identifier, {parse: expressions.parseIdentifierExpression, precedence: -1});\n  //functions\n  prefixMap.set(registry.get('function'), {parse: parseFunctionExpression, precedence: -1});\n  prefixMap.set(registry.get('class'), {parse: parseClassExpression, precedence: -1});\n  prefixMap.set(registry.get('new'), {parse: expressions.parseNewExpression, precedence: 18});\n  //group\n  prefixMap.set(registry.get('('), {parse: expressions.parseGroupExpression, precedence: 20});\n\n  const infixMap = new Map();\n  //sequence\n  infixMap.set(registry.get(','), {parse: expressions.parseSequenceExpression, precedence: 0});\n  //conditional\n  infixMap.set(registry.get('?'), {parse: expressions.parseConditionalExpression, precedence: 4});\n  //assignment operators\n  infixMap.set(registry.get('='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('+='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('-='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('*='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('/='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('%='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('<<='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('>>='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('>>>='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('&='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('^='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('|='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  //binary operators\n  infixMap.set(registry.get('=='), {parse: expressions.parseBinaryExpression, precedence: 10});\n  infixMap.set(registry.get('!='), {parse: expressions.parseBinaryExpression, precedence: 10});\n  infixMap.set(registry.get('==='), {parse: expressions.parseBinaryExpression, precedence: 10});\n  infixMap.set(registry.get('!=='), {parse: expressions.parseBinaryExpression, precedence: 10});\n  infixMap.set(registry.get('<'), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('<='), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('>'), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('>='), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('in'), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('instanceof'), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('<<'), {parse: expressions.parseBinaryExpression, precedence: 12});\n  infixMap.set(registry.get('>>'), {parse: expressions.parseBinaryExpression, precedence: 12});\n  infixMap.set(registry.get('>>>'), {parse: expressions.parseBinaryExpression, precedence: 12});\n  infixMap.set(registry.get('+'), {parse: expressions.parseBinaryExpression, precedence: 13});\n  infixMap.set(registry.get('-'), {parse: expressions.parseBinaryExpression, precedence: 13});\n  infixMap.set(registry.get('*'), {parse: expressions.parseBinaryExpression, precedence: 14});\n  infixMap.set(registry.get('/'), {parse: expressions.parseBinaryExpression, precedence: 14});\n  infixMap.set(registry.get('%'), {parse: expressions.parseBinaryExpression, precedence: 14});\n  infixMap.set(registry.get('**'), {parse: expressions.parseBinaryExpression, precedence: 15});\n  infixMap.set(registry.get('|'), {parse: expressions.parseBinaryExpression, precedence: 7});\n  infixMap.set(registry.get('^'), {parse: expressions.parseBinaryExpression, precedence: 8});\n  infixMap.set(registry.get('&'), {parse: expressions.parseBinaryExpression, precedence: 9});\n  //member access operator\n  infixMap.set(registry.get('.'), {parse: expressions.parseMemberAccessExpression, precedence: 19});\n  infixMap.set(registry.get('['), {parse: expressions.parseMemberAccessExpression, precedence: 19});\n  //logical operators\n  infixMap.set(registry.get('||'), {parse: expressions.parseLogicalExpression, precedence: 5});\n  infixMap.set(registry.get('&&'), {parse: expressions.parseLogicalExpression, precedence: 6});\n  //update operators\n  infixMap.set(registry.get('++'), {parse: expressions.parseUpdateExpression, precedence: 17});\n  infixMap.set(registry.get('--'), {parse: expressions.parseUpdateExpression, precedence: 17});\n  //call\n  infixMap.set(registry.get('('), {parse: parseCallExpression, precedence: 19});\n\n  /**\n   * STATEMENTS\n   */\n\n  const statementsMap = new Map();\n  statementsMap.set(registry.get('if'), statements.parseIfStatement);\n  statementsMap.set(registry.get(';'), statements.parseEmptyStatement);\n  statementsMap.set(registry.get('{'), statements.parseBlockStatement);\n  statementsMap.set(registry.get('for'), statements.parseForStatement);\n  statementsMap.set(registry.get('var'), statements.withEventualSemiColon(statements.parseVariableDeclaration));\n  statementsMap.set(registry.get('const'), statements.withEventualSemiColon(statements.parseConstDeclaration));\n  statementsMap.set(registry.get('let'), statements.withEventualSemiColon(statements.parseLetDeclaration));\n  statementsMap.set(registry.get('function'), parseFunctionDeclaration);\n  statementsMap.set(registry.get('class'), parseClassDeclaration);\n  statementsMap.set(registry.get('return'), statements.withEventualSemiColon(statements.parseReturnStatement));\n  statementsMap.set(registry.get('break'), statements.withEventualSemiColon(statements.parseBreakStatement));\n  statementsMap.set(registry.get('continue'), statements.withEventualSemiColon(statements.parseContinueStatement));\n  statementsMap.set(registry.get('throw'), statements.withEventualSemiColon(statements.parseThrowStatement));\n  statementsMap.set(registry.get('while'), statements.withEventualSemiColon(statements.parseWhileStatement));\n  statementsMap.set(registry.get('do'), statements.withEventualSemiColon(statements.parseDoWhileStatement));\n  statementsMap.set(registry.get('try'), statements.parseTryStatement);\n  statementsMap.set(registry.get('switch'), statements.parseSwitchStatement);\n  statementsMap.set(registry.get('with'), statements.parseWithStatement);\n  statementsMap.set(registry.get('debugger'), statements.withEventualSemiColon(statements.parseDebuggerStatement));\n  statementsMap.set(categories.Identifier, statements.parseExpressionOrLabeledStatement);\n\n  return Object.assign(registry, {\n    getInfix (token) {\n      return infixMap.get(token.type);\n    },\n    getPrefix (token) {\n      return prefixMap.get(token.type);\n    },\n    getStatement (token) {\n      return statementsMap.get(token.type);\n    },\n    hasPrefix (token) {\n      return prefixMap.has(token.type);\n    },\n    hasInfix (token) {\n      return infixMap.has(token.type)\n    },\n    hasStatement (token) {\n      return statementsMap.has(token.type);\n    }\n  });\n};\n\nexport default ECMAScriptTokenRegistry();","import {lazyMapWith, lazyFilterWith} from \"../../tokenizer/src/utils\"\nimport {lexemes} from \"../../tokenizer/src/index\";\nimport {default as ECMAScriptTokens} from './tokens';\nimport {default as ECMAScriptScanner} from \"../../tokenizer/src/scanners\"\n\n//forward method of arrity one (more efficient than using spread operator on arguments)\nexport const forwardArrityOne = (receiver, stream, ...methods) => {\n  for (let m of methods) {\n    receiver[m] = (arg) => stream[m](arg);\n  }\n  return receiver;\n};\n\n//a buffered token stream\nconst tokenStream = ({scanner, tokenRegistry, filter, evaluate}) => {\n  const filterFunc = lazyFilterWith(filter || (t => t.type >= 4));\n  const map = lazyMapWith(evaluate || tokenRegistry.evaluate);\n  const filterMap = it => map(filterFunc(it));\n\n  //as generator(only consumed once)\n  return (code) => {\n\n    const stream = lexemes(code, scanner);\n    const iterator = filterMap(stream)[Symbol.iterator]();\n    const buffer = [];\n    let lastLoc;\n\n    const next = () => iterator.next();\n\n    return forwardArrityOne({\n      [Symbol.iterator] () {\n        return this;\n      },\n      lookAhead (offset = 0) {\n        if (buffer.length > offset) {\n          return buffer[offset]\n        }\n        buffer.push(next());\n        return this.lookAhead(offset);\n      },\n      eventually (expected) {\n        const {value: token, done} = this.lookAhead();\n        if (!done && expected === token) {\n          this.eat();\n          return true;\n        }\n        return false;\n      },\n      expect (expected) {\n        const nextToken = this.next();\n        if (expected !== nextToken.value) {\n          throw new Error(`Unexpected token: expected \"${expected.rawValue}\" but got \"${nextToken.value.rawValue}\"`);\n        }\n        return nextToken;\n      },\n      next () {\n        return buffer.length ? buffer.shift() : next();\n      },\n      eat (number = 1) {\n        const n = this.next();\n        number -= 1;\n        return number < 1 ? n : this.eat(number);\n      }\n    }, stream, 'allowRegexp', 'disallowRegexp', 'allowRightBrace', 'disallowRightBrace');\n  };\n};\n\nexport default tokenStream({scanner: ECMAScriptScanner, tokenRegistry: ECMAScriptTokens});","import {default as stream, forwardArrityOne} from './source';\nimport {default as defaultRegistry} from './tokens';\nimport {parseStatementList} from \"./statements\";\nimport {Program, Identifier} from \"./ast\";\n\nexport const parserFactory = (tokens = defaultRegistry) => {\n\n  const getInfixPrecedence = operator => tokens.hasInfix(operator) ? tokens.getInfix(operator).precedence : -1;\n  const getPrefixPrecedence = operator => tokens.hasPrefix(operator) ? tokens.getPrefix(operator).precedence : -1;\n\n  const parseInfix = (parser, left, precedence, exits) => {\n    parser.disallowRegexp(); //regexp as a literal is a \"prefix operator\" so a \"/\" in infix position is a div punctuator\n    const {value: operator} = parser.lookAhead();\n    if (!operator || precedence >= getInfixPrecedence(operator) || exits.includes(operator.type)) {\n      return left;\n    }\n    parser.eat();\n    parser.allowRegexp();\n    const nextLeft = tokens.getInfix(operator).parse(parser, left, operator);\n    return parseInfix(parser, nextLeft, precedence, exits);\n  };\n\n  return code => {\n    const tokenStream = stream(code);\n    const parser = Object.assign(forwardArrityOne({\n        expect: symbol => tokenStream.expect(tokens.get(symbol)), //more convenient to have it from the symbol\n        eventually: symbol => tokenStream.eventually(tokens.get(symbol)), //more convenient to have it from the symbol\n        getInfixPrecedence,\n        getPrefixPrecedence,\n        expression (precedence = -1, exits = []) {\n          parser.allowRegexp(); //regexp as literal is a \"prefix operator\"\n          const {value: token} = parser.lookAhead();\n          if (!tokens.hasPrefix(token)) {\n            if (token.isReserved === true) { // reserved words are allowed as identifier names (such in member expressions)\n              parser.eat();\n              return Identifier({name: token.value});\n            }\n            return null;\n          }\n          const left = tokens.getPrefix(token).parse(parser);\n\n          return parseInfix(parser, left, precedence, exits);\n        },\n        program () {\n          return Program({\n            body: parseStatementList(parser)\n          });\n        },\n        module () {\n          throw new Error('not implemented');\n        },\n      }, tokenStream, 'lookAhead', 'next', 'eat', 'allowRegexp', 'disallowRegexp'),\n      tokens);\n\n    return parser;\n  };\n\n};\n\nexport const parseExpression = (expression) => {\n  const parse = parserFactory();\n  return parse(expression).expression();\n};\n\nexport const parseProgram = program => {\n  const parse = parserFactory();\n  return parse(program).program();\n};\n"],"names":["chars.SINGLE_LINE_COMMENT_START","chars.CHAR_STAR","chars.CHAR_SLASH","chars.MULTI_LINE_COMMENT_START","chars.CHAR_BACKSLASH","chars.CHAR_SINGLE_QUOTE","chars.CHAR_DOUBLE_QUOTE","chars.SPREAD","chars.CHAR_BRACE_CLOSE","chars.CHAR_DOT","chars.CHAR_LEFT_BRACKET","chars.CHAR_RIGHT_BRACKET","chars.CHAR_TEMPLATE_QUOTE","chars.CHAR_DOLLAR","chars.CHAR_BRACE_OPEN","scanner","tokenRegistry","Prefix","ast.UnaryExpression","ast.ThisExpression","ast.Literal","ast.Identifier","ast.UpdateExpression","ast.NewExpression","Infix","ast.AssignmentExpression","ast.BinaryExpression","ast.LogicalExpression","ast.MemberExpression","ast.ConditionalExpression","ast.SequenceExpression","ast.FunctionExpression","ast.FunctionDeclaration","ast.CallExpression","ast.IfStatement","ast.BlockStatement","ast.ExpressionStatement","ast.EmptyStatement","ast.DebuggerStatement","ast.ReturnStatement","ast.BreakStatement","ast.ContinueStatement","ast.WithStatement","ast.SwitchStatement","ast.SwitchCase","ast.ThrowStatement","ast.TryStatement","ast.WhileStatement","ast.DoWhileStatement","ast.AssignmentPattern","ast.VariableDeclaration","ast.VariableDeclarator","ast.ForStatement","ast.ForInStatement","ast.ForOfStatement","ast.LabeledStatement","expressions.parseUnaryExpression","expressions.parseUpdateExpressionAsPrefix","expressions.parseLiteralExpression","expressions.parseRegularExpressionLiteral","expressions.parseThisExpression","expressions.parseIdentifierExpression","expressions.parseNewExpression","expressions.parseGroupExpression","expressions.parseSequenceExpression","expressions.parseConditionalExpression","expressions.parseAssignmentExpression","expressions.parseBinaryExpression","expressions.parseMemberAccessExpression","expressions.parseLogicalExpression","expressions.parseUpdateExpression","statements.parseIfStatement","statements.parseEmptyStatement","statements.parseBlockStatement","statements.parseForStatement","statements.withEventualSemiColon","statements.parseVariableDeclaration","statements.parseConstDeclaration","statements.parseLetDeclaration","statements.parseReturnStatement","statements.parseBreakStatement","statements.parseContinueStatement","statements.parseThrowStatement","statements.parseWhileStatement","statements.parseDoWhileStatement","statements.parseTryStatement","statements.parseSwitchStatement","statements.parseWithStatement","statements.parseDebuggerStatement","statements.parseExpressionOrLabeledStatement","ECMAScriptScanner","defaultRegistry"],"mappings":"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"}