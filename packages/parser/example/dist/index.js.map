{"version":3,"file":"index.js","sources":["../../../tokenizer/src/utils.js","../../../tokenizer/src/source.js","../../../tokenizer/src/tokens.js","../../../tokenizer/src/chars.js","../../../tokenizer/src/scanners.js","../../../tokenizer/src/index.js","../../src/ast.js","../../src/statements.js","../../src/expressions.js","../../src/tokens.js","../../src/source.js","../../src/index.js","../index.js"],"sourcesContent":["export const lazyMapWith = (fn) => function* (iterator) {\n  for (let i of iterator) {\n    yield fn(i);\n  }\n};\n\nexport const lazyFilterWith = fn => function* (iterator) {\n  for (let i of iterator) {\n    if (fn(i)) {\n      yield i;\n    }\n  }\n};","//todo put track loc as an option ?\nexport const sourceStream = (code) => {\n  const lineTerminatorRegexp = /[\\u000a\\u000d\\u2028\\u2029]/g;\n  let index = 0;\n  let col = 0;\n  let line = 1;\n\n  const test = (regexp) => nextStretch().search(regexp) === 0;\n  const nextSubStr = (count = 1) => code.substr(index, count);\n  const seeNextAt = (offset = 0) => code[index + offset];\n  const nextStretch = () => nextSubStr(3); //we need three chars to be really sure of the current lexical production\n  const loc = () => ({col, line});\n\n  const advance = (number = 1) => {\n    let lastLineIndex = 0;\n    // console.log(`col: ${col}`);\n    // console.log(`line: ${line}`);\n    const stretch = nextSubStr(number);\n    // console.log(`symbols: ${stretch}`);\n    // console.log('-------')\n    while (lineTerminatorRegexp.test(stretch)) {\n      line += 1;\n      col = 0;\n      lastLineIndex = lineTerminatorRegexp.lastIndex;\n    }\n    col += (number - lastLineIndex);\n    index += number;\n  };\n\n  const stream = {\n    loc,\n    test,\n    nextSubStr,\n    seeNextAt,\n    //advance stream\n    match (regexp) {\n      regexp.lastIndex = index;\n      const [rawValue] = regexp.exec(code);\n      advance(rawValue.length);\n      return rawValue;\n    },\n    //advance stream\n    read (length) {\n      const s = this.nextSubStr(length);\n      advance(length);\n      return s;\n    }\n  };\n\n  Object.defineProperty(stream, 'done', {\n    get () {\n      return code[index] === void 0;\n    }\n  });\n  Object.defineProperty(stream, 'index', {\n    get () {\n      return index;\n    }\n  });\n\n  return stream;\n};","export const categories = {\n  WhiteSpace: 0,\n  LineTerminator: 1,\n  SingleLineComment: 2,\n  MultiLineComment: 3,\n  Punctuator: 4,\n  Identifier: 5,\n  NumericLiteral: 6,\n  StringLiteral: 7,\n  RegularExpressionLiteral: 8,\n  Template: 9,\n  TemplateHead: 10,\n  TemplateMiddle: 11,\n  TemplateTail: 12\n};\n\n//defined as keywords\n//todo check async, let ?\nconst keywords = 'await break case catch class const continue debugger default delete do else export extends finally for function if import in instanceof new return super switch this throw try typeof var void while with yield'.split(' ');\nconst futureReservedKeyword = ['enum'];\nconst reservedKeywords = keywords.concat(futureReservedKeyword, ['null', 'true', 'false']);\n\n//defined as punctuators\nexport const puncutators = `{ ( ) [ ] . ... ; , < > <= >= == != === !== + - * % ** ++ -- << >> >>> & | ^ ! ~ && || ? : = += -= *= %= **= <<= >>= >>>= &= |= ^= => / /= }`.split(' ');\n\nexport const allowRegexpAfter = 'case delete do else in instanceof new return throw typeof void { ( [ . ; , < > <= >= == != === !== + - * << >> >>> & | ^ ! ~ && || ? : = += -= *= %= <<= >>= >>>= &= |= ^= /='.split(' ');\n\nconst createLanguageToken = (symbol, value) => {\n  const token = Object.create(null, {\n    type: {\n      get () {\n        return this; //type is an alias to itself (so we can use in Maps as we would to for other categories such literals, etc)\n      }\n    },\n    value: {value: value !== void 0 ? value : symbol},\n    rawValue: {value: symbol, enumerable: true},\n    isReserved: {value: reservedKeywords.includes(symbol), enumerable: true}\n  });\n\n  return Object.freeze(token);\n};\n\n//create a token table\nexport const tokenRegistry = () => {\n  const ecmaScriptTokens = puncutators.concat(keywords, futureReservedKeyword)\n    .map(symbol => ([symbol, createLanguageToken(symbol)]));\n  ecmaScriptTokens.push(['null', createLanguageToken('null', null)]);\n  ecmaScriptTokens.push(['true', createLanguageToken('true', true)]);\n  ecmaScriptTokens.push(['false', createLanguageToken('false', false)]);\n  ecmaScriptTokens.push(['of', createLanguageToken('of')]);\n\n  const tokenMap = new Map(ecmaScriptTokens);\n\n  return {\n    get (key) {\n      return tokenMap.get(key)\n    },\n    evaluate (lexeme) {\n      if (!tokenMap.has(lexeme.rawValue)) {\n        switch (lexeme.type) {\n          case categories.StringLiteral:\n            return Object.assign(lexeme, {\n              value: lexeme.rawValue.substr(1, lexeme.rawValue.length - 2)\n            });\n          case categories.NumericLiteral:\n            return Object.assign(lexeme, {value: Number(lexeme.rawValue)});\n          case categories.RegularExpressionLiteral:\n            return Object.assign(lexeme, {value: new RegExp(lexeme.pattern, lexeme.flags)});\n          default:\n            return Object.assign(lexeme, {value: lexeme.rawValue});\n        }\n      }\n      return tokenMap.get(lexeme.rawValue);\n    },\n    addToken () {\n      throw new Error('not implemented');\n    }\n  }\n};\n\nexport default tokenRegistry();","export const CHAR_STAR = '*';\nexport const CHAR_SLASH = '/';\nexport const MULTI_LINE_COMMENT_START = '/*';\nexport const SINGLE_LINE_COMMENT_START = '//';\nexport const CHAR_BACKSLASH = '\\\\';\nexport const CHAR_SINGLE_QUOTE = \"'\";\nexport const CHAR_DOUBLE_QUOTE = '\"';\nexport const CHAR_LEFT_BRACKET = '[';\nexport const CHAR_RIGHT_BRACKET = ']';\nexport const CHAR_DOT = '.';\nexport const SPREAD = '...';","import {\n  categories,\n  puncutators\n} from \"./tokens\";\nimport * as chars from \"./chars\";\n\nconst lexemeFromRegExp = (regExp, category) => sourceStream => ({type: category, rawValue: sourceStream.match(regExp)});\nconst testFromRegExp = regExp => sourceStream => sourceStream.test(regExp);\nconst productionFromRegexp = ({test, lexeme, category}) => () => {\n  //we create regexp dynamically so they are not global to every instance of the scanner\n  const testRegexp = new RegExp(test);\n  const lexemeRegexp = new RegExp(lexeme, 'y');\n  return {\n    test: testFromRegExp(testRegexp),\n    lexeme: lexemeFromRegExp(lexemeRegexp, category)\n  }\n};\n\nexport const numbers = productionFromRegexp({\n  category: categories.NumericLiteral,\n  test: `^(?:[1-9]|\\\\.\\\\d|0[1-9]?|0[xX][0-9a-fA-F]|0[bB][01]|0[oO][0-7])`,\n  lexeme: `0[xX][0-9a-fA-F]+|0[bB][01]+|0[oO][0-7]+|(?:(?:\\\\d+(?:\\\\.\\\\d*)?|\\\\.\\\\d+)(?:[eE][-+]?\\\\d+)?)`\n});\n\nexport const identifiers = productionFromRegexp({\n  category: categories.Identifier,\n  test: `^[$_a-zA-Z]`,\n  lexeme: `[$_a-zA-Z][$\\\\w]*`\n});\n\nexport const whiteSpace = productionFromRegexp({\n  category: categories.WhiteSpace,\n  test: `^(?:[\\\\u0009\\\\u000b\\\\u000c\\\\u0020\\\\u00a0\\\\ufeff])`,\n  lexeme: `[\\\\u0009\\\\u000b\\\\u000c\\\\u0020\\\\u00a0\\\\ufeff]+`\n});\n\nexport const lineTerminator = productionFromRegexp({\n  category: categories.LineTerminator,\n  test: `^(?:[\\\\u000a\\\\u000d\\\\u2028\\\\u2029])`,\n  lexeme: `[\\\\u000a\\\\u000d\\\\u2028\\\\u2029]+`\n});\n\nexport const singleLineComment = () => {\n  const lexemeRegExp = /\\/\\/.*/y;\n  return {\n    test: (sourceStream) => sourceStream.nextSubStr(2) === chars.SINGLE_LINE_COMMENT_START,\n    lexeme: lexemeFromRegExp(lexemeRegExp, categories.SingleLineComment)\n  };\n};\n\nexport const multiLineComment = () => {\n  const lexeme = (sourceStream, count = 2) => {\n    const next = sourceStream.seeNextAt(count);\n    count++;\n    if (next === chars.CHAR_STAR) {\n      const secondNext = sourceStream.seeNextAt(count);\n      if (secondNext === chars.CHAR_SLASH) {\n        return {\n          type: categories.MultiLineComment,\n          rawValue: sourceStream.read(count + 1)\n        }\n      }\n    }\n    return lexeme(sourceStream, count);\n  };\n  return {\n    test (sourceStream) {\n      return sourceStream.nextSubStr(2) === chars.MULTI_LINE_COMMENT_START;\n    },\n    lexeme\n  };\n};\n\nconst fromQuote = quote => {\n  const fn = (sourceStream, count = 1) => {\n    const next = sourceStream.seeNextAt(count);\n    count += 1;\n    if (next === quote) {\n      return {\n        type: categories.StringLiteral,\n        rawValue: sourceStream.read(count)\n      };\n    }\n    if (next === chars.CHAR_BACKSLASH) {\n      count += 1;\n    }\n    return fn(sourceStream, count);\n  };\n  return fn;\n};\nexport const stringLiteral = () => {\n  const singleQuote = fromQuote(chars.CHAR_SINGLE_QUOTE);\n  const doubleQuote = fromQuote(chars.CHAR_DOUBLE_QUOTE);\n  return {\n    test (sourceStream) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_SINGLE_QUOTE || next === chars.CHAR_DOUBLE_QUOTE;\n    },\n    lexeme (sourceStream) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_DOUBLE_QUOTE ? doubleQuote(sourceStream) : singleQuote(sourceStream);\n    }\n  };\n};\n\nexport const punctuators = (punctuatorList = puncutators) => {\n\n  const sizeOnePunctuatorList = punctuatorList.filter(p => p.length === 1);\n  const sizeTwoPunctuatorList = punctuatorList.filter(p => p.length === 2);\n  const sizeThreePunctuatorList = punctuatorList.filter(p => p.length === 3);\n  const sizeFourPunctuatorList = punctuatorList.filter(p => p.length === 4);\n\n  //micro optimization (this function will run often)\n  const isInPunctuatorList = (str) => {\n    switch (str.length) {\n      case 2:\n        return sizeTwoPunctuatorList.includes(str);\n      case 3:\n        return sizeThreePunctuatorList.includes(str);\n      case 4:\n        return sizeFourPunctuatorList.includes(str);\n      default:\n        return false;\n    }\n  };\n  const lexeme = (sourceStream, count = 1) => {\n    const nextStretch = sourceStream.nextSubStr(count + 1);\n    if (!isInPunctuatorList(nextStretch) || nextStretch.length !== count + 1 /*End of file */) {\n      return {\n        type: categories.Punctuator,\n        rawValue: sourceStream.read(count)\n      };\n    }\n    return lexeme(sourceStream, count + 1);\n  };\n  const lexemeFromDot = sourceStream => ({\n    type: categories.Punctuator,\n    rawValue: (sourceStream.nextSubStr(3) === chars.SPREAD) ? sourceStream.read(3) : sourceStream.read(1)\n  });\n  return {\n    test (sourceStream, allowRegexp) {\n      const next = sourceStream.seeNextAt();\n      return (next === chars.CHAR_SLASH && allowRegexp === false) || sizeOnePunctuatorList.includes(next);\n    },\n    lexeme: sourceStream => sourceStream.seeNextAt() === chars.CHAR_DOT ? lexemeFromDot(sourceStream) : lexeme(sourceStream)\n  };\n};\n\nconst scanRegExpBody = (sourceStream, count = 1) => {\n  const next = sourceStream.seeNextAt(count);\n  count += 1;\n  switch (next) {\n    case chars.CHAR_SLASH:\n      return count;\n    case chars.CHAR_LEFT_BRACKET: {\n      // slash are \"escaped\" in a regexp class\n      count = scanRegExpClass(sourceStream, count);//+1\n      break;\n    }\n    case chars.CHAR_BACKSLASH: {\n      count += 1;\n      break;\n    }\n  }\n  return scanRegExpBody(sourceStream, count);\n};\nconst scanRegExpClass = (sourceStream, count) => {\n  const next = sourceStream.seeNextAt(count);\n  count += 1;\n  switch (next) {\n    case chars.CHAR_RIGHT_BRACKET:\n      return count;\n    case chars.CHAR_BACKSLASH:\n      count += 1\n  }\n  return scanRegExpClass(sourceStream, count);\n};\n\nconst identifierPart = /[$\\w]/;\nconst scanRegExpFlags = (sourceStream, count) => {\n  const next = sourceStream.seeNextAt(count);\n  if (!next || !identifierPart.test(next)) {\n    return count;\n  }\n  return scanRegExpFlags(sourceStream, count + 1);\n};\n\nexport const regularExpression = () => {\n  return {\n    test (sourceStream, allowRegexp) {\n      const next = sourceStream.seeNextAt();\n      return allowRegexp && next === chars.CHAR_SLASH;\n    },\n    lexeme (sourceStream) {\n      const body = scanRegExpBody(sourceStream);\n      const withFlags = scanRegExpFlags(sourceStream, body);\n      const rawValue = sourceStream.read(withFlags);\n      return {\n        type: categories.RegularExpressionLiteral,\n        rawValue,\n        pattern: rawValue.substr(1, body - 2),\n        flags: rawValue.substr(body, withFlags - body)\n      };\n    }\n  };\n};\n\nexport const ECMAScriptLexicalGrammar = [\n  whiteSpace,\n  lineTerminator,\n  numbers,\n  singleLineComment,\n  multiLineComment,\n  regularExpression,\n  punctuators,\n  identifiers,\n  stringLiteral\n];\n\nexport const scanner = (lexicalRules = ECMAScriptLexicalGrammar.map(g => g())) => {\n  return (source, isRegexpAllowed) => {\n    const rule = lexicalRules.find(lr => lr.test(source, isRegexpAllowed));\n    if (rule === void 0) {\n      throw new Error(`could not understand the symbol ${source.seeNextAt()}`);\n    }\n    return rule.lexeme(source);\n  };\n};\n\nexport default scanner();\n","import {sourceStream} from \"./source\";\nimport {allowRegexpAfter} from \"./tokens\";\nimport {lazyFilterWith, lazyMapWith} from \"./utils\";\nimport {default as defaultScanner} from './scanners';\nimport {default as defaultRegistry} from './tokens';\n\n/* Note\n\nwe could greatly improve perf by directly yielding filtered (and evaluated token?) at the scanner level instead of passing every lexeme through a lazy stream combinators pipe chain,\nhowever we would lost the great flexibility we have here !\n\nfor example if we simply ignored white space, line terminators, etc.\nour filter combinator would have to run much less (at least for big files)\n\nbottom line: we value more modularity and flexibility of the system over performance\n\ntodo: later we can give ability to the consumer to configure the scanner to perform better\n\n*/\n\n\n//return an iterable sequence of lexemes (note it can only be consumed once like a generator)\n//The consumer (like a parser) will have to handle the syntactic state and the token evaluation by itself\nexport const lexemes = (code, scanner) => {\n  let isRegexpAllowed = true;\n  const source = sourceStream(code);\n  return {\n    * [Symbol.iterator] () {\n      while (true) {\n        if (source.done === true) {\n          return;\n        }\n        yield scanner(source, isRegexpAllowed);\n      }\n    },\n    allowRegexp () {\n      isRegexpAllowed = true;\n    },\n    disallowRegexp () {\n      isRegexpAllowed = false;\n    },\n    loc () {\n      return source.loc();\n    }\n  }\n};\n\nlet defaultFilter = t => t.type >= 4;\nconst defaultOptions = {\n  scanner: defaultScanner,\n  tokenRegistry: defaultRegistry,\n  evaluate: defaultRegistry.evaluate,\n  filter: defaultFilter\n};\n\n// a standalone tokenizer (ie uses some heuristics based on the last meaningful token to know how to scan a slash)\n// https://stackoverflow.com/questions/5519596/when-parsing-javascript-what-determines-the-meaning-of-a-slash\nexport const tokenize = function* (code, {scanner = defaultScanner, tokenRegistry = defaultRegistry, filter, evaluate} = defaultOptions) {\n  const filterFunc = lazyFilterWith(filter || defaultFilter);\n  const mapFunc = lazyMapWith(evaluate || tokenRegistry.evaluate);\n  const filterMap = iter => mapFunc(filterFunc(iter));\n  const stream = lexemes(code, scanner);\n\n  for (let t of filterMap(stream)) {\n    yield t;\n    if (Object.is(t.type, t) || t.type >= 4) {\n      if (allowRegexpAfter.includes(t.rawValue)) {\n        stream.allowRegexp();\n      } else {\n        stream.disallowRegexp();\n      }\n    }\n  }\n};","const nodeFactory = (type, proto = null) => obj => Object.assign(Object.create(proto), {type}, obj);\n\n//pefix nodes\nexport const UnaryExpression = nodeFactory('UnaryExpression', {\n  * [Symbol.iterator] () {\n    yield this.argument;\n  }\n});\nexport const ThisExpression = nodeFactory('ThisExpression');\nexport const Literal = nodeFactory('Literal');\nexport const Identifier = nodeFactory('Identifier');\nexport const UpdateExpression = nodeFactory('UpdateExpression', {\n  * [Symbol.iterator] () {\n    yield this.argument;\n  }\n});\nexport const FunctionExpression = nodeFactory('FunctionExpression', {\n  * [Symbol.iterator] () {\n    yield this.id;\n    yield* this.params;\n    yield this.body;\n  }\n});\nexport const NewExpression = nodeFactory('NewExpression', {\n  * [Symbol.iterator] () {\n    yield this.callee;\n    yield* this.arguments;\n  }\n});\nexport const ArrayExpression = nodeFactory('ArrayExpression', {\n  * [Symbol.iterator] () {\n    yield* this.elements;\n  }\n});\nexport const ObjectExpression = nodeFactory('ObjectExpression', {\n  * [Symbol.iterator] () {\n    yield* this.properties;\n  }\n});\nexport const Property = nodeFactory('Property', {\n  * [Symbol.iterator] () {\n    yield this.key;\n    yield this.value;\n  }\n});\n\n//infix nodes\nconst asBinary = type => nodeFactory(type, {\n  * [Symbol.iterator] () {\n    yield this.left;\n    yield this.right;\n  }\n});\nexport const AssignmentExpression = asBinary('AssignmentExpression');\nexport const BinaryExpression = asBinary('BinaryExpression');\nexport const LogicalExpression = asBinary('LogicalExpression');\nexport const MemberExpression = nodeFactory('MemberExpression', {\n  * [Symbol.iterator] () {\n    yield this.object;\n    yield this.property;\n  }\n});\nexport const ConditionalExpression = nodeFactory('ConditionalExpression', {\n  * [Symbol.iterator] () {\n    yield this.test;\n    yield this.consequent;\n    yield this.alternate;\n  }\n});\nexport const CallExpression = nodeFactory('CallExpression', {\n  * [Symbol.iterator] () {\n    yield this.callee;\n    yield* this.arguments;\n  }\n});\nexport const SequenceExpression = nodeFactory('SequenceExpression', {\n  * [Symbol.iterator] () {\n    yield* this.expressions;\n  }\n});\n\n//statements nodes\n//todo refactoring with function expression\nexport const FunctionDeclaration = nodeFactory('FunctionDeclaration', {\n  * [Symbol.iterator] () {\n    yield this.id;\n    yield* this.params;\n    yield this.body;\n  }\n});\n//todo refactoring with conditional expression\nexport const IfStatement = nodeFactory('IfStatement', {\n  * [Symbol.iterator] () {\n    yield this.test;\n    yield this.consequent;\n    yield this.alternate;\n  }\n});\nexport const BlockStatement = nodeFactory('BlockStatement', {\n  * [Symbol.iterator] () {\n    yield* this.body;\n  }\n});\nexport const ExpressionStatement = nodeFactory('ExpressionStatement', {\n  * [Symbol.iterator] () {\n    yield this.expression;\n  }\n});\nexport const EmptyStatement = nodeFactory('EmptyStatement');\nexport const DebuggerStatement = nodeFactory('DebuggerStatement');\nconst withArgument = (type) => nodeFactory(\n  type, {\n    * [Symbol.iterator] () {\n      yield this.argument;\n    }\n  });\nexport const ReturnStatement = withArgument('ReturnStatement');\nexport const BreakStatement = withArgument('BreakStatement');\nexport const ContinueStatement = withArgument('ContinueStatement');\nexport const WithStatement = nodeFactory('WithStatement', {\n  * [Symbol.iterator] () {\n    yield this.object;\n    yield this.body;\n  }\n});\nexport const SwitchStatement = nodeFactory('SwitchStatement', {\n  * [Symbol.iterator] () {\n    yield this.discriminant;\n    yield* this.cases;\n  }\n});\nexport const SwitchCase = nodeFactory('SwitchCase', {\n  * [Symbol.iterator] () {\n    yield this.test;\n    yield* this.consequent;\n  }\n});\nexport const ThrowStatement = nodeFactory('ThrowStatement', {\n  * [Symbol.iterator] () {\n    yield this.expression;\n  }\n});\nexport const TryStatement = nodeFactory('TryStatement', {\n  * [Symbol.iterator] () {\n    yield this.block;\n    yield this.handler;\n    yield this.finalizer;\n  }\n});\nexport const CatchClause = nodeFactory('CatchClause', {\n  * [Symbol.iterator] () {\n    yield this.param;\n    yield this.body;\n  }\n});\nexport const WhileStatement = nodeFactory('WhileStatement', {\n  * [Symbol.iterator] () {\n    yield this.test;\n    yield this.body;\n  }\n});\nexport const DoWhileStatement = nodeFactory('DoWhileStatement', {\n  * [Symbol.iterator] () {\n    yield this.body;\n    yield this.test;\n  }\n});\nexport const VariableDeclarator = nodeFactory('VariableDeclarator', {\n  * [Symbol.iterator] () {\n    yield this.id;\n    yield this.init;\n  }\n});\nexport const VariableDeclaration = nodeFactory('VariableDeclaration', {\n  * [Symbol.iterator] () {\n    yield* this.declarations;\n  }\n});\nexport const ForInStatement = nodeFactory('ForInStatement', {\n  * [Symbol.iterator] () {\n    yield this.left;\n    yield this.right;\n  }\n});\nexport const ForStatement = nodeFactory('ForStatement', {\n  * [Symbol.iterator] () {\n    yield this.init;\n    yield this.test;\n    yield this.update;\n  }\n});\nexport const LabeledStatement = nodeFactory('LabeledStatement', {\n  * [Symbol.iterator] () {\n    yield this.body;\n  }\n});\n\nexport const Program = nodeFactory('Program', {\n  * [Symbol.iterator] () {\n    yield* this.body;\n  }\n});\n\n//walk & traverse\nexport function* traverse (node) {\n  yield node;\n  if (node && node[Symbol.iterator]) {\n    for (let child of node) {\n      yield* traverse(child);\n    }\n  }\n}\n\n\nexport const visitWithAncestors = visitor => node => {\n\n};\n\nexport const visit = (...visitors) => {\n  const aggregatedVisitor = visitors.reduce((acc, curr) => {\n    for (let nodeType of Object.keys(curr)) {\n      const fns = acc[nodeType] || [];\n      fns.push(curr[nodeType]);\n      acc[nodeType] = fns;\n    }\n    return acc;\n  }, {});\n\n  return node => {\n    for (let n of traverse(node)) {\n      if (aggregatedVisitor[n.type]) {\n        for (let vfunc of aggregatedVisitor[n.type]) {\n          vfunc(n);\n        }\n      }\n    }\n  };\n};\n\n","import * as ast from './ast';\n\nconst Statement = (factory, fn) => {\n  if (!fn) {\n    return factory;\n  } else {\n    return parser => factory(fn(parser));\n  }\n};\n\nexport const parseStatementList = (parser, exit = ['}'], statements = []) => {\n  const exitTokens = exit.map(s => parser.get(s)); // todo exit is not consistent with expression parser\n  const {done, value: nextToken} = parser.lookAhead();\n  if (done || exitTokens.includes(nextToken)) {\n    return statements;\n  }\n  statements.push(parseStatement(parser));\n  return parseStatementList(parser, exit, statements);\n};\nexport const withEventualSemiColon = (fn) => parser => {\n  const node = fn(parser);\n  parser.eventually(';');\n  return node;\n};\nexport const parseExpressionOrLabeledStatement = parser => {\n  const {value: nextToken} = parser.lookAhead(1);\n  return nextToken === parser.get(':') ? parseLabeledStatement(parser) : withEventualSemiColon(parseExpressionStatement)(parser);\n};\nexport const parseStatement = (parser) => {\n  parser.allowRegexp();\n  const {value: nextToken} = parser.lookAhead();\n  return parser.hasStatement(nextToken) ? parser.getStatement(nextToken)(parser) : withEventualSemiColon(parseExpressionStatement)(parser);\n};\n\nexport const parseFormalParameters = (parser, parameters = []) => {\n  const {value: nextToken} = parser.lookAhead();\n  if (nextToken === parser.get(')')) {\n    return parameters;\n  }\n\n  if (nextToken !== parser.get(',')) {\n    parameters.push(parser.expression(20));\n  } else {\n    parser.eat();\n  }\n  return parseFormalParameters(parser, parameters);\n};\nexport const parseFunctionDeclaration = Statement(ast.FunctionDeclaration, parser => {\n  parser.expect('function');\n  const node = {\n    id: parseBindingIdentifierOrPattern(parser),\n    async: false,\n    generator: false\n  };\n  parser.expect('(');\n  node.params = parseFormalParameters(parser);\n  parser.expect(')');\n  node.body = parseBlockStatement(parser);\n  return node;\n});\n\nexport const parseIfStatement = Statement(ast.IfStatement, parser => {\n  parser.expect('if');\n  parser.expect('(');\n  const test = parser.expression();\n  parser.expect(')');\n  const consequent = parseStatement(parser);\n  let alternate = null;\n  if (parser.eventually('else')) {\n    alternate = parseStatement(parser);\n  }\n  return {\n    test,\n    consequent,\n    alternate\n  };\n});\n\nexport const parseBlockStatement = Statement(ast.BlockStatement, parser => {\n  parser.expect('{');\n  const node = {\n    body: parseStatementList(parser)\n  };\n  parser.expect('}');\n  return node;\n});\n\nexport const parseExpressionStatement = Statement(ast.ExpressionStatement, parser => ({\n  expression: parser.expression()\n}));\n\nexport const parseEmptyStatement = Statement(ast.EmptyStatement, parser => {\n  parser.expect(';');\n});\n\nexport const parseDebuggerStatement = Statement(ast.DebuggerStatement);\n\nexport const parseReturnStatement = Statement(ast.ReturnStatement, parser => {\n  parser.expect('return');\n  return {\n    argument: parser.expression()\n  };\n});\n\nexport const parseBreakStatement = Statement(ast.BreakStatement, parser => {\n  parser.expect('break');\n  return {\n    argument: parser.expression(20)\n  };\n});\n\nexport const parseContinueStatement = Statement(ast.ContinueStatement, parser => {\n  parser.expect('continue');\n  return {\n    argument: parser.expression(20)\n  };\n});\n\nexport const parseWithStatement = Statement(ast.WithStatement, parser => {\n  parser.expect('with');\n  parser.expect('(');\n  const object = parser.expression();\n  parser.expect(')');\n  return {\n    object,\n    body: parseStatement(parser)\n  };\n});\n\nexport const parseSwitchStatement = Statement(ast.SwitchStatement, parser => {\n  parser.expect('switch');\n  parser.expect('(');\n  const discriminant = parser.expression();\n  parser.expect(')');\n  parser.expect('{');\n  const cases = parseSwitchCases(parser);\n  parser.expect('}');\n  return {\n    discriminant,\n    cases\n  };\n});\n\nexport const parseSwitchCases = (parser, cases = []) => {\n  const {value: nextToken} = parser.lookAhead();\n  if (nextToken !== parser.get('case') && nextToken !== parser.get('default')) {\n    return cases;\n  }\n  parser.eat();\n  cases.push(parseSwitchCase(parser, nextToken));\n  return parseSwitchCases(parser, cases);\n};\n\nexport const parseSwitchCase = (parser, nextToken) => {\n  const {type} = nextToken;\n  const node = {\n    type: 'SwitchCase',\n    test: type === parser.get('case') ? parser.expression() : null\n  };\n  parser.expect(':');\n  node.consequent = parseStatementList(parser, ['}', 'case', 'default']);\n  return node;\n};\n\nexport const parseThrowStatement = Statement(ast.ThrowStatement, parser => {\n  parser.expect('throw');\n  return {\n    expression: parser.expression()\n  };\n});\n\nexport const parseTryStatement = Statement(ast.TryStatement, parser => {\n  parser.expect('try');\n  const node = {block: parseBlockStatement(parser), handler: null, finalizer: null};\n  if (parser.eventually('catch')) {\n    const handler = {type: 'CatchClause'};\n    parser.expect('(');\n    handler.param = parser.expression();\n    parser.expect(')');\n    handler.body = parseBlockStatement(parser);\n    node.handler = handler;\n  }\n  if (parser.eventually('finally')) {\n    node.finalizer = parseBlockStatement(parser);\n  }\n  return node;\n});\n\nexport const parseWhileStatement = Statement(ast.WhileStatement, parser => {\n  parser.expect('while');\n  parser.expect('(');\n  const node = {\n    test: parser.expression()\n  };\n  parser.expect(')');\n  node.body = parseStatement(parser);\n  return node;\n});\n\nexport const parseDoWhileStatement = Statement(ast.DoWhileStatement, parser => {\n  parser.expect('do');\n  const node = {\n    body: parseStatement(parser)\n  };\n  parser.expect('while');\n  parser.expect('(');\n  node.test = parser.expression();\n  parser.expect(')');\n  return node;\n});\n\n//todo\nexport const parseBindingIdentifierOrPattern = parser => {\n  return parser.expression(20);\n};\n\nexport const parseVariableDeclarators = (parser, declarators = []) => {\n  const id = parseBindingIdentifierOrPattern(parser);\n  let {value: nextToken} = parser.lookAhead();\n  let init = null;\n  const node = {\n    type: 'VariableDeclarator',\n    id: id\n  };\n\n  const comma = parser.get(',');\n  if (parser.eventually('=')) {\n    init = parser.expression(parser.getInfixPrecedence(comma));\n    nextToken = parser.lookAhead().value;\n  }\n\n  node.init = init;\n\n  declarators.push(node);\n\n  if (nextToken !== comma) {\n    return declarators;\n  }\n\n  parser.eat();\n\n  return parseVariableDeclarators(parser, declarators);\n};\n\nexport const parseVariableDeclaration = Statement(ast.VariableDeclaration, parser => {\n  parser.expect('var');\n  return {\n    kind: 'var',\n    declarations: parseVariableDeclarators(parser)\n  };\n});\n\nconst getForDerivation = parser => {\n  const {value: nextToken} = parser.lookAhead();\n  switch (nextToken.type) {\n    case parser.get('in'):\n      return asForIn;\n    case parser.get('of'):\n      return asForOf;\n    default:\n      return asFor;\n  }\n};\nconst asForIn = (parser, left) => {\n  parser.expect('in');\n  const n = {\n    type: 'ForInStatement',\n    left\n  };\n  n.right = parser.expression();\n  return n;\n};\nconst asFor = (parser, init) => {\n  parser.expect(';');\n  const n = {\n    type: 'ForStatement',\n    init,\n    test: parser.expression()\n  };\n  parser.expect(';');\n  n.update = parser.expression();\n  return n;\n};\n\n//todo\nconst asForOf = (parser, init) => {\n  parser.expect('of');\n  return {};\n};\n\nexport const parseForStatement = parser => {\n  parser.expect('for');\n  parser.expect('(');\n  const {value: token} = parser.lookAhead();\n  let startExpression, node;\n  if (token === parser.get('var')) {\n    startExpression = parseVariableDeclaration(parser);\n  } else {\n    startExpression = parser.expression(-1, [parser.get('in'), parser.get('of')]);\n  }\n  const derivation = getForDerivation(parser);\n  node = derivation(parser, startExpression);\n  parser.expect(')');\n  node.body = parseStatement(parser);\n  return node;\n};\n\nexport const parseLabeledStatement = Statement(ast.LabeledStatement, parser => {\n  const node = {\n    label: parser.expression(20)\n  };\n  parser.expect(':');\n  node.body = parseStatement(parser);\n  return node;\n});\n\n\n\n","import {categories} from \"../../tokenizer/src/tokens\";\nimport {parseBindingIdentifierOrPattern, parseBlockStatement, parseFormalParameters} from \"./statements\";\nimport * as ast from \"./ast\";\n\n//todo 1. check whether a real compose affects performances or not\n//todo 2. these could be decoratos like @Infix(ast.foo) etc or eve @Node(ast.blah)\n//compose one with arrity one\nconst Prefix = (factory, fn) => parser => factory(fn(parser));\n// compose with arrity 3\nconst Infix = (factory, fn) => (parser, left, operator) => factory(fn(parser, left, operator));\n\n//prefix\nconst asValue = (type, key) => Prefix(type, (parser) => {\n  const {value: token} = parser.next();\n  return key ? {[key]: token.value} : {};\n});\nconst asUnaryExpression = (type) => Prefix(type, (parser) => {\n  const {value: token} = parser.next();\n  return {\n    operator: token.value,\n    argument: parser.expression(parser.getPrefixPrecedence(token)),\n    prefix: true\n  };\n});\nexport const parseGroupExpression = (parser) => {\n  parser.expect('(');\n  const exp = parser.expression();\n  parser.expect(')');\n  return exp;\n};\nexport const parseUnaryExpression = asUnaryExpression(ast.UnaryExpression);\nexport const parseThisExpression = asValue(ast.ThisExpression);\nexport const parseLiteralExpression = asValue(ast.Literal, 'value');\nexport const parseIdentifierExpression = asValue(ast.Identifier, 'name');\nexport const parseRegularExpressionLiteral = Prefix(ast.Literal, parser => {\n  const {value: regexp} = parser.next();\n  return {\n    value: regexp.value,\n    regex: {\n      pattern: regexp.value.source,\n      flags: regexp.value.flags\n    }\n  }\n});\nexport const parseUpdateExpressionAsPrefix = asUnaryExpression(ast.UpdateExpression);\nexport const parseFunctionExpression = Prefix(ast.FunctionExpression, (parser) => {\n  parser.expect('function');\n  const node = {\n    id: null,\n    async: false,\n    generator: false\n  };\n  const {value: nextToken} = parser.lookAhead();\n  if (nextToken !== parser.get('(')) {\n    node.id = parseBindingIdentifierOrPattern(parser);\n  }\n  parser.expect('(');\n  node.params = parseFormalParameters(parser);\n  parser.expect(')');\n  node.body = parseBlockStatement(parser);\n  return node;\n});\nexport const parseNewExpression = Prefix(ast.NewExpression, parser => {\n  const {value: newToken} = parser.expect('new');\n  const callee = parser.expression(parser.getPrefixPrecedence(newToken));\n  return {\n    callee: callee.callee ? callee.callee : callee,\n    arguments: callee.arguments ? callee.arguments : []\n  };\n});\n\n//Arrays literals\nconst parseArrayElements = (parser, elements = []) => {\n  const {value: token} = parser.lookAhead();\n  if (token === parser.get(']')) {\n    return elements;\n  }\n  const comma = parser.get(',');\n  elements.push(parser.expression(parser.getInfixPrecedence(comma)));\n  const {value: nextToken} = parser.lookAhead();\n  if (nextToken === comma) {\n    parser.eat();\n  }\n  return parseArrayElements(parser, elements);\n};\nexport const parseArrayLiteralExpression = Prefix(ast.ArrayExpression, (parser) => {\n  parser.expect('[');\n  const node = {\n    elements: parseArrayElements(parser)\n  };\n  parser.expect(']');\n  return node;\n});\n\nconst parsePropertyList = (parser, properties = []) => {\n  const {value: nextToken} = parser.lookAhead();\n  if (nextToken === parser.get('}')) {\n    return properties;\n  }\n  if (nextToken !== parser.get(',')) {\n    properties.push(parseObjectPropertyExpression(parser));\n  } else {\n    parser.eat();\n  }\n  return parsePropertyList(parser, properties);\n};\nconst isPropertyName = (parser, token) => token === parser.get('[') || token.type === categories.Identifier || token.type === categories.NumericLiteral || token.type === categories.StringLiteral || token.isReserved === true;\nexport const parseObjectPropertyExpression = Prefix(ast.Property, parser => {\n  const {value: nextToken} = parser.lookAhead();\n  let key;\n  let kind = 'init';\n  let value = null;\n  let computed = false;\n  let shorthand = false;\n  let method = false;\n  if (isPropertyName(parser, nextToken)) {\n    if (parser.eventually('[')) {\n      computed = true;\n      key = parser.expression();\n      parser.expect(']');\n    } else {\n      key = parser.expression(20)\n    }\n    parser.expect(':');\n    value = parser.expression(parser.getInfixPrecedence(parser.get(',')))\n  }\n\n  return {\n    key,\n    value,\n    kind,\n    computed,\n    method,\n    shorthand\n  };\n});\nexport const parseObjectLiteralExpression = Prefix(ast.ObjectExpression, (parser) => {\n  parser.expect('{');\n  const node = {\n    properties: parsePropertyList(parser)\n  };\n  parser.expect('}');\n  return node;\n});\n\n//infix\nconst asBinaryExpression = type => Infix(type, (parser, left, operator) => {\n  return {\n    left,\n    right: parser.expression(parser.getInfixPrecedence(operator)),\n    operator: operator.value\n  };\n});\nconst parseArguments = (parser, expressions = []) => {\n  const {value: parsableValue} = parser.lookAhead();\n  const comma = parser.get(',');\n\n  if (parsableValue === parser.get(')')) {\n    return expressions;\n  }\n\n  expressions.push(parser.expression(parser.getInfixPrecedence(comma)));\n  const {value: lookAhead} = parser.lookAhead();\n\n  if (lookAhead !== comma) {\n    return expressions;\n  }\n  parser.eat();\n  return parseArguments(parser, expressions);\n};\nexport const parseAssignmentExpression = asBinaryExpression(ast.AssignmentExpression);\nexport const parseBinaryExpression = asBinaryExpression(ast.BinaryExpression);\nexport const parseLogicalExpression = asBinaryExpression(ast.LogicalExpression);\nexport const parseMemberAccessExpression = Infix(ast.MemberExpression, (parser, left, operator) => {\n  const computed = operator === parser.get('[');\n  const node = {\n    object: left,\n    computed: computed,\n    property: computed ? parser.expression() : parseIdentifierExpression(parser)\n  };\n  if (computed) {\n    parser.expect(']');\n  }\n  return node;\n});\nexport const parseUpdateExpression = Infix(ast.UpdateExpression, (parser, left, operator) => ({\n  type: 'UpdateExpression',\n  argument: left,\n  operator: operator.value,\n  prefix: false\n}));\nexport const parseConditionalExpression = Infix(ast.ConditionalExpression, (parser, test) => {\n  const node = {\n    test\n  };\n  const commaPrecedence = parser.getInfixPrecedence(parser.get(','));\n  node.consequent = parser.expression(commaPrecedence);\n  parser.expect(':');\n  node.alternate = parser.expression(commaPrecedence);\n  return node;\n});\nexport const parseCallExpression = Infix(ast.CallExpression, (parser, callee) => {\n  const node = {\n    callee,\n    arguments: parseArguments(parser)\n  };\n  parser.expect(')');\n  return node;\n});\n\nexport const parseSequenceExpression = Infix(ast.SequenceExpression, (parser, left) => {\n  let node = left;\n  const comma = parser.get(',');\n  const next = parser.expression(parser.getInfixPrecedence(comma));\n  if (left.type === 'SequenceExpression') {\n    left.expressions.push(next);\n  } else {\n    node = {\n      type: 'SequenceExpression',\n      expressions: [left, next]\n    }\n  }\n  return node;\n});","import {tokenRegistry, categories} from \"../../tokenizer/src/tokens\";\nimport * as expressions from './expressions';\nimport * as statements from './statements';\nimport {withEventualSemiColon} from \"./statements\";\n\nexport const ECMAScriptTokenRegistry = () => {\n  const registry = tokenRegistry();\n\n  /**\n   * EXPRESSIONS\n   */\n\n  const prefixMap = new Map();\n  //unary operators\n  prefixMap.set(registry.get('-'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('+'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('!'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('~'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('typeof'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('void'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('delete'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  //update operators\n  prefixMap.set(registry.get('--'), {parse: expressions.parseUpdateExpressionAsPrefix, precedence: 16});\n  prefixMap.set(registry.get('++'), {parse: expressions.parseUpdateExpressionAsPrefix, precedence: 16});\n  //literals\n  prefixMap.set(categories.StringLiteral, {parse: expressions.parseLiteralExpression, precedence: -1});\n  prefixMap.set(categories.NumericLiteral, {parse: expressions.parseLiteralExpression, precedence: -1});\n  prefixMap.set(categories.RegularExpressionLiteral, {\n    parse: expressions.parseRegularExpressionLiteral,\n    precedence: -1\n  });\n  prefixMap.set(registry.get('null'), {parse: expressions.parseLiteralExpression, precedence: -1});\n  prefixMap.set(registry.get('false'), {parse: expressions.parseLiteralExpression, precedence: -1});\n  prefixMap.set(registry.get('true'), {parse: expressions.parseLiteralExpression, precedence: -1});\n  prefixMap.set(registry.get('['), {parse: expressions.parseArrayLiteralExpression, precedence: -1});\n  prefixMap.set(registry.get('{'), {parse: expressions.parseObjectLiteralExpression, precedence: -1});\n  //identifiers\n  prefixMap.set(registry.get('this'), {parse: expressions.parseThisExpression, precedence: -1});\n  prefixMap.set(categories.Identifier, {parse: expressions.parseIdentifierExpression, precedence: -1});\n  //functions\n  prefixMap.set(registry.get('function'), {parse: expressions.parseFunctionExpression, precedence: -1});\n  prefixMap.set(registry.get('new'), {parse: expressions.parseNewExpression, precedence: 18});\n  //group\n  prefixMap.set(registry.get('('), {parse: expressions.parseGroupExpression, precedence: 20});\n\n\n  const infixMap = new Map();\n  //sequence\n  infixMap.set(registry.get(','), {parse: expressions.parseSequenceExpression, precedence: 0});\n  //conditional\n  infixMap.set(registry.get('?'), {parse: expressions.parseConditionalExpression, precedence: 4});\n  //assignment operators\n  infixMap.set(registry.get('='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('+='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('-='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('*='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('/='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('%='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('<<='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('>>='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('>>>='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('&='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('^='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('|='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  //binary operators\n  infixMap.set(registry.get('=='), {parse: expressions.parseBinaryExpression, precedence: 10});\n  infixMap.set(registry.get('!='), {parse: expressions.parseBinaryExpression, precedence: 10});\n  infixMap.set(registry.get('==='), {parse: expressions.parseBinaryExpression, precedence: 10});\n  infixMap.set(registry.get('!=='), {parse: expressions.parseBinaryExpression, precedence: 10});\n  infixMap.set(registry.get('<'), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('<='), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('>'), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('>='), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('in'), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('instanceof'), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('<<'), {parse: expressions.parseBinaryExpression, precedence: 12});\n  infixMap.set(registry.get('>>'), {parse: expressions.parseBinaryExpression, precedence: 12});\n  infixMap.set(registry.get('>>>'), {parse: expressions.parseBinaryExpression, precedence: 12});\n  infixMap.set(registry.get('+'), {parse: expressions.parseBinaryExpression, precedence: 13});\n  infixMap.set(registry.get('-'), {parse: expressions.parseBinaryExpression, precedence: 13});\n  infixMap.set(registry.get('*'), {parse: expressions.parseBinaryExpression, precedence: 14});\n  infixMap.set(registry.get('/'), {parse: expressions.parseBinaryExpression, precedence: 14});\n  infixMap.set(registry.get('%'), {parse: expressions.parseBinaryExpression, precedence: 14});\n  infixMap.set(registry.get('**'), {parse: expressions.parseBinaryExpression, precedence: 15});\n  infixMap.set(registry.get('|'), {parse: expressions.parseBinaryExpression, precedence: 7});\n  infixMap.set(registry.get('^'), {parse: expressions.parseBinaryExpression, precedence: 8});\n  infixMap.set(registry.get('&'), {parse: expressions.parseBinaryExpression, precedence: 9});\n  //member access operator\n  infixMap.set(registry.get('.'), {parse: expressions.parseMemberAccessExpression, precedence: 19});\n  infixMap.set(registry.get('['), {parse: expressions.parseMemberAccessExpression, precedence: 19});\n  //logical operators\n  infixMap.set(registry.get('||'), {parse: expressions.parseLogicalExpression, precedence: 5});\n  infixMap.set(registry.get('&&'), {parse: expressions.parseLogicalExpression, precedence: 6});\n  //update operators\n  infixMap.set(registry.get('++'), {parse: expressions.parseUpdateExpression, precedence: 17});\n  infixMap.set(registry.get('--'), {parse: expressions.parseUpdateExpression, precedence: 17});\n  //call\n  infixMap.set(registry.get('('), {parse: expressions.parseCallExpression, precedence: 19});\n\n  /**\n   * STATEMENTS\n   */\n\n  const statementsMap = new Map();\n  statementsMap.set(registry.get('if'),statements.parseIfStatement);\n  statementsMap.set(registry.get(';'),statements.parseEmptyStatement);\n  statementsMap.set(registry.get('{'),statements.parseBlockStatement);\n  statementsMap.set(registry.get('for'),statements.parseForStatement);\n  statementsMap.set(registry.get('var'),withEventualSemiColon(statements.parseVariableDeclaration));\n  statementsMap.set(registry.get('function'),statements.parseFunctionDeclaration);\n  statementsMap.set(registry.get('return'),withEventualSemiColon(statements.parseReturnStatement));\n  statementsMap.set(registry.get('break'),withEventualSemiColon(statements.parseBreakStatement));\n  statementsMap.set(registry.get('continue'),withEventualSemiColon(statements.parseContinueStatement));\n  statementsMap.set(registry.get('throw'),withEventualSemiColon(statements.parseThrowStatement));\n  statementsMap.set(registry.get('while'),withEventualSemiColon(statements.parseWhileStatement));\n  statementsMap.set(registry.get('do'),withEventualSemiColon(statements.parseDoWhileStatement));\n  statementsMap.set(registry.get('try'),statements.parseTryStatement);\n  statementsMap.set(registry.get('switch'),statements.parseSwitchStatement);\n  statementsMap.set(registry.get('with'),statements.parseWithStatement);\n  statementsMap.set(registry.get('debugger'),withEventualSemiColon(statements.parseDebuggerStatement));\n  statementsMap.set(categories.Identifier,statements.parseExpressionOrLabeledStatement);\n\n  return Object.assign(registry, {\n    getInfix (token) {\n      return infixMap.get(token.type);\n    },\n    getPrefix (token) {\n      return prefixMap.get(token.type);\n    },\n    getStatement (token) {\n      return statementsMap.get(token.type);\n    },\n    hasPrefix (token) {\n      return prefixMap.has(token.type);\n    },\n    hasInfix (token) {\n      return infixMap.has(token.type)\n    },\n    hasStatement (token) {\n      return statementsMap.has(token.type);\n    }\n  });\n};\n\n\nexport default ECMAScriptTokenRegistry();","import {lazyMapWith, lazyFilterWith} from \"../../tokenizer/src/utils\"\nimport {lexemes} from \"../../tokenizer/src/index\";\nimport {default as ECMAScriptTokens} from './tokens';\nimport {default as ECMAScriptScanner} from \"../../tokenizer/src/scanners\"\n\n//forward method of arrity one (more efficient than using spread operator on arguments)\nexport const forwardArrityOne = (receiver, stream, ...methods) => {\n  for (let m of methods) {\n    receiver[m] = (arg) => stream[m](arg);\n  }\n  return receiver;\n};\n\n//a buffered stream token\nconst tokenStream = ({scanner, tokenRegistry, filter, evaluate}) => {\n  const filterFunc = lazyFilterWith(filter || (t => t.type >= 4));\n  const map = lazyMapWith(evaluate || tokenRegistry.evaluate);\n  const filterMap = it => map(filterFunc(it));\n\n  //as generator(only consumed once)\n  return (code) => {\n\n    const stream = lexemes(code, scanner);\n    const iterator = filterMap(stream)[Symbol.iterator]();\n    const buffer = [];\n    let lastLoc;\n\n    const next = () => iterator.next();\n\n    return forwardArrityOne({\n      [Symbol.iterator] () {\n        return this;\n      },\n      lookAhead (offset = 0) {\n        if (buffer.length > offset) {\n          return buffer[offset]\n        }\n        buffer.push(next());\n        return this.lookAhead(offset);\n      },\n      eventually (expected) {\n        const {value: token, done} = this.lookAhead();\n        if (!done && expected === token) {\n          this.eat();\n          return true;\n        }\n        return false;\n      },\n      expect (expected) {\n        const nextToken = this.next();\n        if (expected !== nextToken.value) {\n          throw new Error(`Unexpected token: expected \"${expected.rawValue}\" but got \"${nextToken.value.rawValue}\"`);\n        }\n        return nextToken;\n      },\n      next () {\n        return buffer.length ? buffer.shift() : next();\n      },\n      eat (number = 1) {\n        const n = this.next();\n        number -= 1;\n        return number < 1 ? n : this.eat(number);\n      }\n    }, stream, 'allowRegexp', 'disallowRegexp');\n  };\n};\n\nexport default tokenStream({scanner: ECMAScriptScanner, tokenRegistry: ECMAScriptTokens});","import {default as stream, forwardArrityOne} from './source';\nimport {default as defaultRegistry} from './tokens';\nimport {parseStatementList} from \"./statements\";\nimport {Program} from \"./ast\";\n\nexport const parserFactory = (tokens = defaultRegistry) => {\n\n  const getInfixPrecedence = operator => tokens.hasInfix(operator) ? tokens.getInfix(operator).precedence : -1;\n  const getPrefixPrecedence = operator => tokens.hasPrefix(operator) ? tokens.getPrefix(operator).precedence : -1;\n\n  const parseInfix = (parser, left, precedence, exits) => {\n    parser.disallowRegexp();\n    const {value: operator} = parser.lookAhead();\n    if (!operator || precedence >= getInfixPrecedence(operator) || exits.includes(operator.type)) {\n      return left;\n    }\n    parser.eat();\n    parser.allowRegexp();\n    const nextLeft = tokens.getInfix(operator).parse(parser, left, operator);\n    return parseInfix(parser, nextLeft, precedence, exits);\n  };\n\n  return code => {\n\n    const tokenStream = stream(code);\n\n    const parser = Object.assign(forwardArrityOne({\n        expect: symbol => tokenStream.expect(tokens.get(symbol)), //more convenient to have it from the symbol\n        eventually: symbol => tokenStream.eventually(tokens.get(symbol)), //more convenient to have it from the symbol\n        getInfixPrecedence,\n        getPrefixPrecedence,\n        expression (precedence = -1, exits = []) {\n          parser.allowRegexp();\n          const {value: token} = parser.lookAhead();\n          if (!tokens.hasPrefix(token)) {\n            if (token.isReserved === true) { // reserved words are allowed as identifier names (such in member expressions)\n              parser.eat();\n              return {type: 'Identifier', name: token.value};\n            }\n            return null;\n          }\n          const left = tokens.getPrefix(token).parse(parser);\n          return parseInfix(parser, left, precedence, exits);\n        },\n        program () {\n          return Program({\n            body: parseStatementList(parser)\n          });\n        },\n        module () {\n          throw new Error('not implemented');\n        },\n      }, tokenStream, 'lookAhead', 'next', 'eat', 'allowRegexp', 'disallowRegexp'),\n      tokens);\n\n    return parser;\n  };\n\n};\n\nexport const parseExpression = (expression) => {\n  const parse = parserFactory();\n  return parse(expression).expression();\n};\n\nexport const parseProgram = program => {\n  const parse = parserFactory();\n  return parse(program).program();\n};\n","import {parseProgram} from \"../src/index\";\nimport {traverse, visit} from \"../src/ast\";\n\nconst fs = require('fs');\nconst path = require('path');\nconst utils = require('util');\nconst programPath = path.resolve(__dirname, '../fixtures/react.js');\n// const program = fs.readFileSync(programPath, {encoding: 'utf8'});\n// import {parse as acorn} from 'acorn';\n\nconst program = `function foo(a, b){\n  console.log('test');\n}`;\n\nconst ast = parseProgram(program);\n\nconst logLiterals = visit({\n  Literal (node) {\n    console.log(`Literal: ${node.value}`);\n  },\n  Identifier (node) {\n    console.log(node);\n  }\n}, {\n  Literal (node) {\n    console.log('visit too !!');\n  },\n  FunctionDeclaration(node){\n    console.log(node);\n  }\n});\n\nlogLiterals(ast);\n\n\n// const [foo] = identifiers(traverse(ast));\n\n\n// console.log([...traverse(ast)]);\n\n// console.log('######################');\n\n// const astFromAcorn = acorn(program);\n// console.log(utils.inspect(astFromAcorn, {depth: null, colors:true}));\n\n\n/* browser  */\n// (async function  () {\n//    const resp = await fetch('../fixtures/jquery.js');\n//    const text = await resp.text();\n//\n//    const ast = parseProgram(text);\n//    // console.log(ast);\n// })();\n/* end browser */\n"],"names":["chars.SINGLE_LINE_COMMENT_START","chars.CHAR_STAR","chars.CHAR_SLASH","chars.MULTI_LINE_COMMENT_START","chars.CHAR_BACKSLASH","chars.CHAR_SINGLE_QUOTE","chars.CHAR_DOUBLE_QUOTE","chars.SPREAD","chars.CHAR_DOT","chars.CHAR_LEFT_BRACKET","chars.CHAR_RIGHT_BRACKET","scanner","tokenRegistry","ast.FunctionDeclaration","ast.IfStatement","ast.BlockStatement","ast.ExpressionStatement","ast.EmptyStatement","ast.DebuggerStatement","ast.ReturnStatement","ast.BreakStatement","ast.ContinueStatement","ast.WithStatement","ast.SwitchStatement","ast.ThrowStatement","ast.TryStatement","ast.WhileStatement","ast.DoWhileStatement","ast.VariableDeclaration","ast.LabeledStatement","ast.UnaryExpression","ast.ThisExpression","ast.Literal","ast.Identifier","ast.UpdateExpression","ast.FunctionExpression","ast.NewExpression","ast.ArrayExpression","ast.Property","ast.ObjectExpression","ast.AssignmentExpression","ast.BinaryExpression","ast.LogicalExpression","ast.MemberExpression","ast.ConditionalExpression","ast.CallExpression","ast.SequenceExpression","expressions.parseUnaryExpression","expressions.parseUpdateExpressionAsPrefix","expressions.parseLiteralExpression","expressions.parseRegularExpressionLiteral","expressions.parseArrayLiteralExpression","expressions.parseObjectLiteralExpression","expressions.parseThisExpression","expressions.parseIdentifierExpression","expressions.parseFunctionExpression","expressions.parseNewExpression","expressions.parseGroupExpression","expressions.parseSequenceExpression","expressions.parseConditionalExpression","expressions.parseAssignmentExpression","expressions.parseBinaryExpression","expressions.parseMemberAccessExpression","expressions.parseLogicalExpression","expressions.parseUpdateExpression","expressions.parseCallExpression","statements.parseIfStatement","statements.parseEmptyStatement","statements.parseBlockStatement","statements.parseForStatement","statements.parseVariableDeclaration","statements.parseFunctionDeclaration","statements.parseReturnStatement","statements.parseBreakStatement","statements.parseContinueStatement","statements.parseThrowStatement","statements.parseWhileStatement","statements.parseDoWhileStatement","statements.parseTryStatement","statements.parseSwitchStatement","statements.parseWithStatement","statements.parseDebuggerStatement","statements.parseExpressionOrLabeledStatement","ECMAScriptScanner","defaultRegistry"],"mappings":";;;AAAO,MAAM,WAAW,GAAG,CAAC,EAAE,KAAK,WAAW,QAAQ,EAAE;EACtD,KAAK,IAAI,CAAC,IAAI,QAAQ,EAAE;IACtB,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC;GACb;CACF,CAAC;;AAEF,AAAO,MAAM,cAAc,GAAG,EAAE,IAAI,WAAW,QAAQ,EAAE;EACvD,KAAK,IAAI,CAAC,IAAI,QAAQ,EAAE;IACtB,IAAI,EAAE,CAAC,CAAC,CAAC,EAAE;MACT,MAAM,CAAC,CAAC;KACT;GACF;CACF;;ACZD;AACA,AAAO,MAAM,YAAY,GAAG,CAAC,IAAI,KAAK;EACpC,MAAM,oBAAoB,GAAG,6BAA6B,CAAC;EAC3D,IAAI,KAAK,GAAG,CAAC,CAAC;EACd,IAAI,GAAG,GAAG,CAAC,CAAC;EACZ,IAAI,IAAI,GAAG,CAAC,CAAC;;EAEb,MAAM,IAAI,GAAG,CAAC,MAAM,KAAK,WAAW,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;EAC5D,MAAM,UAAU,GAAG,CAAC,KAAK,GAAG,CAAC,KAAK,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;EAC5D,MAAM,SAAS,GAAG,CAAC,MAAM,GAAG,CAAC,KAAK,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC,CAAC;EACvD,MAAM,WAAW,GAAG,MAAM,UAAU,CAAC,CAAC,CAAC,CAAC;EACxC,MAAM,GAAG,GAAG,OAAO,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC;;EAEhC,MAAM,OAAO,GAAG,CAAC,MAAM,GAAG,CAAC,KAAK;IAC9B,IAAI,aAAa,GAAG,CAAC,CAAC;;;IAGtB,MAAM,OAAO,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC;;;IAGnC,OAAO,oBAAoB,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;MACzC,IAAI,IAAI,CAAC,CAAC;MACV,GAAG,GAAG,CAAC,CAAC;MACR,aAAa,GAAG,oBAAoB,CAAC,SAAS,CAAC;KAChD;IACD,GAAG,KAAK,MAAM,GAAG,aAAa,CAAC,CAAC;IAChC,KAAK,IAAI,MAAM,CAAC;GACjB,CAAC;;EAEF,MAAM,MAAM,GAAG;IACb,GAAG;IACH,IAAI;IACJ,UAAU;IACV,SAAS;;IAET,KAAK,CAAC,CAAC,MAAM,EAAE;MACb,MAAM,CAAC,SAAS,GAAG,KAAK,CAAC;MACzB,MAAM,CAAC,QAAQ,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;MACrC,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;MACzB,OAAO,QAAQ,CAAC;KACjB;;IAED,IAAI,CAAC,CAAC,MAAM,EAAE;MACZ,MAAM,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;MAClC,OAAO,CAAC,MAAM,CAAC,CAAC;MAChB,OAAO,CAAC,CAAC;KACV;GACF,CAAC;;EAEF,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,MAAM,EAAE;IACpC,GAAG,CAAC,GAAG;MACL,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,KAAK,CAAC,CAAC;KAC/B;GACF,CAAC,CAAC;EACH,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,OAAO,EAAE;IACrC,GAAG,CAAC,GAAG;MACL,OAAO,KAAK,CAAC;KACd;GACF,CAAC,CAAC;;EAEH,OAAO,MAAM,CAAC;CACf;;AC7DM,MAAM,UAAU,GAAG;EACxB,UAAU,EAAE,CAAC;EACb,cAAc,EAAE,CAAC;EACjB,iBAAiB,EAAE,CAAC;EACpB,gBAAgB,EAAE,CAAC;EACnB,UAAU,EAAE,CAAC;EACb,UAAU,EAAE,CAAC;EACb,cAAc,EAAE,CAAC;EACjB,aAAa,EAAE,CAAC;EAChB,wBAAwB,EAAE,CAAC;EAC3B,QAAQ,EAAE,CAAC;EACX,YAAY,EAAE,EAAE;EAChB,cAAc,EAAE,EAAE;EAClB,YAAY,EAAE,EAAE;CACjB,CAAC;;;;AAIF,MAAM,QAAQ,GAAG,iNAAiN,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AAC9O,MAAM,qBAAqB,GAAG,CAAC,MAAM,CAAC,CAAC;AACvC,MAAM,gBAAgB,GAAG,QAAQ,CAAC,MAAM,CAAC,qBAAqB,EAAE,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC;;;AAG3F,AAAO,MAAM,WAAW,GAAG,CAAC,4IAA4I,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;;AAErL,AAAO,MAAM,gBAAgB,GAAG,+KAA+K,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;;AAE3N,MAAM,mBAAmB,GAAG,CAAC,MAAM,EAAE,KAAK,KAAK;EAC7C,MAAM,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE;IAChC,IAAI,EAAE;MACJ,GAAG,CAAC,GAAG;QACL,OAAO,IAAI,CAAC;OACb;KACF;IACD,KAAK,EAAE,CAAC,KAAK,EAAE,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,GAAG,MAAM,CAAC;IACjD,QAAQ,EAAE,CAAC,KAAK,EAAE,MAAM,EAAE,UAAU,EAAE,IAAI,CAAC;IAC3C,UAAU,EAAE,CAAC,KAAK,EAAE,gBAAgB,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,UAAU,EAAE,IAAI,CAAC;GACzE,CAAC,CAAC;;EAEH,OAAO,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;CAC7B,CAAC;;;AAGF,AAAO,MAAM,aAAa,GAAG,MAAM;EACjC,MAAM,gBAAgB,GAAG,WAAW,CAAC,MAAM,CAAC,QAAQ,EAAE,qBAAqB,CAAC;KACzE,GAAG,CAAC,MAAM,KAAK,CAAC,MAAM,EAAE,mBAAmB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;EAC1D,gBAAgB,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,mBAAmB,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;EACnE,gBAAgB,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,mBAAmB,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;EACnE,gBAAgB,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,mBAAmB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;EACtE,gBAAgB,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,mBAAmB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;;EAEzD,MAAM,QAAQ,GAAG,IAAI,GAAG,CAAC,gBAAgB,CAAC,CAAC;;EAE3C,OAAO;IACL,GAAG,CAAC,CAAC,GAAG,EAAE;MACR,OAAO,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC;KACzB;IACD,QAAQ,CAAC,CAAC,MAAM,EAAE;MAChB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE;QAClC,QAAQ,MAAM,CAAC,IAAI;UACjB,KAAK,UAAU,CAAC,aAAa;YAC3B,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE;cAC3B,KAAK,EAAE,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,EAAE,MAAM,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;aAC7D,CAAC,CAAC;UACL,KAAK,UAAU,CAAC,cAAc;YAC5B,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,KAAK,EAAE,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;UACjE,KAAK,UAAU,CAAC,wBAAwB;YACtC,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,KAAK,EAAE,IAAI,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;UAClF;YACE,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,KAAK,EAAE,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC;SAC1D;OACF;MACD,OAAO,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;KACtC;IACD,QAAQ,CAAC,GAAG;MACV,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;KACpC;GACF;CACF,CAAC;;AAEF,AAAe,aAAa,EAAE;;gBAAC,hBChFxB,MAAM,SAAS,GAAG,GAAG,CAAC;AAC7B,AAAO,MAAM,UAAU,GAAG,GAAG,CAAC;AAC9B,AAAO,MAAM,wBAAwB,GAAG,IAAI,CAAC;AAC7C,AAAO,MAAM,yBAAyB,GAAG,IAAI,CAAC;AAC9C,AAAO,MAAM,cAAc,GAAG,IAAI,CAAC;AACnC,AAAO,MAAM,iBAAiB,GAAG,GAAG,CAAC;AACrC,AAAO,MAAM,iBAAiB,GAAG,GAAG,CAAC;AACrC,AAAO,MAAM,iBAAiB,GAAG,GAAG,CAAC;AACrC,AAAO,MAAM,kBAAkB,GAAG,GAAG,CAAC;AACtC,AAAO,MAAM,QAAQ,GAAG,GAAG,CAAC;AAC5B,AAAO,MAAM,MAAM,GAAG,KAAK;;ACJ3B,MAAM,gBAAgB,GAAG,CAAC,MAAM,EAAE,QAAQ,KAAK,YAAY,KAAK,CAAC,IAAI,EAAE,QAAQ,EAAE,QAAQ,EAAE,YAAY,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACxH,MAAM,cAAc,GAAG,MAAM,IAAI,YAAY,IAAI,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;AAC3E,MAAM,oBAAoB,GAAG,CAAC,CAAC,IAAI,EAAE,MAAM,EAAE,QAAQ,CAAC,KAAK,MAAM;;EAE/D,MAAM,UAAU,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,CAAC;EACpC,MAAM,YAAY,GAAG,IAAI,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;EAC7C,OAAO;IACL,IAAI,EAAE,cAAc,CAAC,UAAU,CAAC;IAChC,MAAM,EAAE,gBAAgB,CAAC,YAAY,EAAE,QAAQ,CAAC;GACjD;CACF,CAAC;;AAEF,AAAO,MAAM,OAAO,GAAG,oBAAoB,CAAC;EAC1C,QAAQ,EAAE,UAAU,CAAC,cAAc;EACnC,IAAI,EAAE,CAAC,+DAA+D,CAAC;EACvE,MAAM,EAAE,CAAC,2FAA2F,CAAC;CACtG,CAAC,CAAC;;AAEH,AAAO,MAAM,WAAW,GAAG,oBAAoB,CAAC;EAC9C,QAAQ,EAAE,UAAU,CAAC,UAAU;EAC/B,IAAI,EAAE,CAAC,WAAW,CAAC;EACnB,MAAM,EAAE,CAAC,iBAAiB,CAAC;CAC5B,CAAC,CAAC;;AAEH,AAAO,MAAM,UAAU,GAAG,oBAAoB,CAAC;EAC7C,QAAQ,EAAE,UAAU,CAAC,UAAU;EAC/B,IAAI,EAAE,CAAC,iDAAiD,CAAC;EACzD,MAAM,EAAE,CAAC,6CAA6C,CAAC;CACxD,CAAC,CAAC;;AAEH,AAAO,MAAM,cAAc,GAAG,oBAAoB,CAAC;EACjD,QAAQ,EAAE,UAAU,CAAC,cAAc;EACnC,IAAI,EAAE,CAAC,mCAAmC,CAAC;EAC3C,MAAM,EAAE,CAAC,+BAA+B,CAAC;CAC1C,CAAC,CAAC;;AAEH,AAAO,MAAM,iBAAiB,GAAG,MAAM;EACrC,MAAM,YAAY,GAAG,SAAS,CAAC;EAC/B,OAAO;IACL,IAAI,EAAE,CAAC,YAAY,KAAK,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,KAAKA,yBAA+B;IACtF,MAAM,EAAE,gBAAgB,CAAC,YAAY,EAAE,UAAU,CAAC,iBAAiB,CAAC;GACrE,CAAC;CACH,CAAC;;AAEF,AAAO,MAAM,gBAAgB,GAAG,MAAM;EACpC,MAAM,MAAM,GAAG,CAAC,YAAY,EAAE,KAAK,GAAG,CAAC,KAAK;IAC1C,MAAM,IAAI,GAAG,YAAY,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IAC3C,KAAK,EAAE,CAAC;IACR,IAAI,IAAI,KAAKC,SAAe,EAAE;MAC5B,MAAM,UAAU,GAAG,YAAY,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;MACjD,IAAI,UAAU,KAAKC,UAAgB,EAAE;QACnC,OAAO;UACL,IAAI,EAAE,UAAU,CAAC,gBAAgB;UACjC,QAAQ,EAAE,YAAY,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;SACvC;OACF;KACF;IACD,OAAO,MAAM,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;GACpC,CAAC;EACF,OAAO;IACL,IAAI,CAAC,CAAC,YAAY,EAAE;MAClB,OAAO,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,KAAKC,wBAA8B,CAAC;KACtE;IACD,MAAM;GACP,CAAC;CACH,CAAC;;AAEF,MAAM,SAAS,GAAG,KAAK,IAAI;EACzB,MAAM,EAAE,GAAG,CAAC,YAAY,EAAE,KAAK,GAAG,CAAC,KAAK;IACtC,MAAM,IAAI,GAAG,YAAY,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IAC3C,KAAK,IAAI,CAAC,CAAC;IACX,IAAI,IAAI,KAAK,KAAK,EAAE;MAClB,OAAO;QACL,IAAI,EAAE,UAAU,CAAC,aAAa;QAC9B,QAAQ,EAAE,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC;OACnC,CAAC;KACH;IACD,IAAI,IAAI,KAAKC,cAAoB,EAAE;MACjC,KAAK,IAAI,CAAC,CAAC;KACZ;IACD,OAAO,EAAE,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;GAChC,CAAC;EACF,OAAO,EAAE,CAAC;CACX,CAAC;AACF,AAAO,MAAM,aAAa,GAAG,MAAM;EACjC,MAAM,WAAW,GAAG,SAAS,CAACC,iBAAuB,CAAC,CAAC;EACvD,MAAM,WAAW,GAAG,SAAS,CAACC,iBAAuB,CAAC,CAAC;EACvD,OAAO;IACL,IAAI,CAAC,CAAC,YAAY,EAAE;MAClB,MAAM,IAAI,GAAG,YAAY,CAAC,SAAS,EAAE,CAAC;MACtC,OAAO,IAAI,KAAKD,iBAAuB,IAAI,IAAI,KAAKC,iBAAuB,CAAC;KAC7E;IACD,MAAM,CAAC,CAAC,YAAY,EAAE;MACpB,MAAM,IAAI,GAAG,YAAY,CAAC,SAAS,EAAE,CAAC;MACtC,OAAO,IAAI,KAAKA,iBAAuB,GAAG,WAAW,CAAC,YAAY,CAAC,GAAG,WAAW,CAAC,YAAY,CAAC,CAAC;KACjG;GACF,CAAC;CACH,CAAC;;AAEF,AAAO,MAAM,WAAW,GAAG,CAAC,cAAc,GAAG,WAAW,KAAK;;EAE3D,MAAM,qBAAqB,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC;EACzE,MAAM,qBAAqB,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC;EACzE,MAAM,uBAAuB,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC;EAC3E,MAAM,sBAAsB,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC;;;EAG1E,MAAM,kBAAkB,GAAG,CAAC,GAAG,KAAK;IAClC,QAAQ,GAAG,CAAC,MAAM;MAChB,KAAK,CAAC;QACJ,OAAO,qBAAqB,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;MAC7C,KAAK,CAAC;QACJ,OAAO,uBAAuB,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;MAC/C,KAAK,CAAC;QACJ,OAAO,sBAAsB,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;MAC9C;QACE,OAAO,KAAK,CAAC;KAChB;GACF,CAAC;EACF,MAAM,MAAM,GAAG,CAAC,YAAY,EAAE,KAAK,GAAG,CAAC,KAAK;IAC1C,MAAM,WAAW,GAAG,YAAY,CAAC,UAAU,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;IACvD,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,IAAI,WAAW,CAAC,MAAM,KAAK,KAAK,GAAG,CAAC,mBAAmB;MACzF,OAAO;QACL,IAAI,EAAE,UAAU,CAAC,UAAU;QAC3B,QAAQ,EAAE,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC;OACnC,CAAC;KACH;IACD,OAAO,MAAM,CAAC,YAAY,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC;GACxC,CAAC;EACF,MAAM,aAAa,GAAG,YAAY,KAAK;IACrC,IAAI,EAAE,UAAU,CAAC,UAAU;IAC3B,QAAQ,EAAE,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,KAAKC,MAAY,IAAI,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC;GACtG,CAAC,CAAC;EACH,OAAO;IACL,IAAI,CAAC,CAAC,YAAY,EAAE,WAAW,EAAE;MAC/B,MAAM,IAAI,GAAG,YAAY,CAAC,SAAS,EAAE,CAAC;MACtC,OAAO,CAAC,IAAI,KAAKL,UAAgB,IAAI,WAAW,KAAK,KAAK,KAAK,qBAAqB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;KACrG;IACD,MAAM,EAAE,YAAY,IAAI,YAAY,CAAC,SAAS,EAAE,KAAKM,QAAc,GAAG,aAAa,CAAC,YAAY,CAAC,GAAG,MAAM,CAAC,YAAY,CAAC;GACzH,CAAC;CACH,CAAC;;AAEF,MAAM,cAAc,GAAG,CAAC,YAAY,EAAE,KAAK,GAAG,CAAC,KAAK;EAClD,MAAM,IAAI,GAAG,YAAY,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;EAC3C,KAAK,IAAI,CAAC,CAAC;EACX,QAAQ,IAAI;IACV,KAAKN,UAAgB;MACnB,OAAO,KAAK,CAAC;IACf,KAAKO,iBAAuB,EAAE;;MAE5B,KAAK,GAAG,eAAe,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;MAC7C,MAAM;KACP;IACD,KAAKL,cAAoB,EAAE;MACzB,KAAK,IAAI,CAAC,CAAC;MACX,MAAM;KACP;GACF;EACD,OAAO,cAAc,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;CAC5C,CAAC;AACF,MAAM,eAAe,GAAG,CAAC,YAAY,EAAE,KAAK,KAAK;EAC/C,MAAM,IAAI,GAAG,YAAY,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;EAC3C,KAAK,IAAI,CAAC,CAAC;EACX,QAAQ,IAAI;IACV,KAAKM,kBAAwB;MAC3B,OAAO,KAAK,CAAC;IACf,KAAKN,cAAoB;MACvB,KAAK,IAAI,EAAC;GACb;EACD,OAAO,eAAe,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;CAC7C,CAAC;;AAEF,MAAM,cAAc,GAAG,OAAO,CAAC;AAC/B,MAAM,eAAe,GAAG,CAAC,YAAY,EAAE,KAAK,KAAK;EAC/C,MAAM,IAAI,GAAG,YAAY,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;EAC3C,IAAI,CAAC,IAAI,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;IACvC,OAAO,KAAK,CAAC;GACd;EACD,OAAO,eAAe,CAAC,YAAY,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC;CACjD,CAAC;;AAEF,AAAO,MAAM,iBAAiB,GAAG,MAAM;EACrC,OAAO;IACL,IAAI,CAAC,CAAC,YAAY,EAAE,WAAW,EAAE;MAC/B,MAAM,IAAI,GAAG,YAAY,CAAC,SAAS,EAAE,CAAC;MACtC,OAAO,WAAW,IAAI,IAAI,KAAKF,UAAgB,CAAC;KACjD;IACD,MAAM,CAAC,CAAC,YAAY,EAAE;MACpB,MAAM,IAAI,GAAG,cAAc,CAAC,YAAY,CAAC,CAAC;MAC1C,MAAM,SAAS,GAAG,eAAe,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;MACtD,MAAM,QAAQ,GAAG,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;MAC9C,OAAO;QACL,IAAI,EAAE,UAAU,CAAC,wBAAwB;QACzC,QAAQ;QACR,OAAO,EAAE,QAAQ,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,GAAG,CAAC,CAAC;QACrC,KAAK,EAAE,QAAQ,CAAC,MAAM,CAAC,IAAI,EAAE,SAAS,GAAG,IAAI,CAAC;OAC/C,CAAC;KACH;GACF,CAAC;CACH,CAAC;;AAEF,AAAO,MAAM,wBAAwB,GAAG;EACtC,UAAU;EACV,cAAc;EACd,OAAO;EACP,iBAAiB;EACjB,gBAAgB;EAChB,iBAAiB;EACjB,WAAW;EACX,WAAW;EACX,aAAa;CACd,CAAC;;AAEF,AAAO,MAAM,OAAO,GAAG,CAAC,YAAY,GAAG,wBAAwB,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK;EAChF,OAAO,CAAC,MAAM,EAAE,eAAe,KAAK;IAClC,MAAM,IAAI,GAAG,YAAY,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,CAAC,IAAI,CAAC,MAAM,EAAE,eAAe,CAAC,CAAC,CAAC;IACvE,IAAI,IAAI,KAAK,KAAK,CAAC,EAAE;MACnB,MAAM,IAAI,KAAK,CAAC,CAAC,gCAAgC,EAAE,MAAM,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC;KAC1E;IACD,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;GAC5B,CAAC;CACH,CAAC;;AAEF,qBAAe,OAAO,EAAE,CAAC;;AC/NzB;;;;;;;;;;;;;;;;;AAiBA,AAAO,MAAM,OAAO,GAAG,CAAC,IAAI,EAAES,UAAO,KAAK;EACxC,IAAI,eAAe,GAAG,IAAI,CAAC;EAC3B,MAAM,MAAM,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;EAClC,OAAO;IACL,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;MACrB,OAAO,IAAI,EAAE;QACX,IAAI,MAAM,CAAC,IAAI,KAAK,IAAI,EAAE;UACxB,OAAO;SACR;QACD,MAAMA,UAAO,CAAC,MAAM,EAAE,eAAe,CAAC,CAAC;OACxC;KACF;IACD,WAAW,CAAC,GAAG;MACb,eAAe,GAAG,IAAI,CAAC;KACxB;IACD,cAAc,CAAC,GAAG;MAChB,eAAe,GAAG,KAAK,CAAC;KACzB;IACD,GAAG,CAAC,GAAG;MACL,OAAO,MAAM,CAAC,GAAG,EAAE,CAAC;KACrB;GACF;CACF,CAAC;;AAEF,AAQA;6GAC6G;;ACxD7G,MAAM,WAAW,GAAG,CAAC,IAAI,EAAE,KAAK,GAAG,IAAI,KAAK,GAAG,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;;;AAGpG,AAAO,MAAM,eAAe,GAAG,WAAW,CAAC,iBAAiB,EAAE;EAC5D,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,MAAM,IAAI,CAAC,QAAQ,CAAC;GACrB;CACF,CAAC,CAAC;AACH,AAAO,MAAM,cAAc,GAAG,WAAW,CAAC,gBAAgB,CAAC,CAAC;AAC5D,AAAO,MAAM,OAAO,GAAG,WAAW,CAAC,SAAS,CAAC,CAAC;AAC9C,AAAO,MAAM,UAAU,GAAG,WAAW,CAAC,YAAY,CAAC,CAAC;AACpD,AAAO,MAAM,gBAAgB,GAAG,WAAW,CAAC,kBAAkB,EAAE;EAC9D,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,MAAM,IAAI,CAAC,QAAQ,CAAC;GACrB;CACF,CAAC,CAAC;AACH,AAAO,MAAM,kBAAkB,GAAG,WAAW,CAAC,oBAAoB,EAAE;EAClE,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,MAAM,IAAI,CAAC,EAAE,CAAC;IACd,OAAO,IAAI,CAAC,MAAM,CAAC;IACnB,MAAM,IAAI,CAAC,IAAI,CAAC;GACjB;CACF,CAAC,CAAC;AACH,AAAO,MAAM,aAAa,GAAG,WAAW,CAAC,eAAe,EAAE;EACxD,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,MAAM,IAAI,CAAC,MAAM,CAAC;IAClB,OAAO,IAAI,CAAC,SAAS,CAAC;GACvB;CACF,CAAC,CAAC;AACH,AAAO,MAAM,eAAe,GAAG,WAAW,CAAC,iBAAiB,EAAE;EAC5D,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,OAAO,IAAI,CAAC,QAAQ,CAAC;GACtB;CACF,CAAC,CAAC;AACH,AAAO,MAAM,gBAAgB,GAAG,WAAW,CAAC,kBAAkB,EAAE;EAC9D,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,OAAO,IAAI,CAAC,UAAU,CAAC;GACxB;CACF,CAAC,CAAC;AACH,AAAO,MAAM,QAAQ,GAAG,WAAW,CAAC,UAAU,EAAE;EAC9C,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,MAAM,IAAI,CAAC,GAAG,CAAC;IACf,MAAM,IAAI,CAAC,KAAK,CAAC;GAClB;CACF,CAAC,CAAC;;;AAGH,MAAM,QAAQ,GAAG,IAAI,IAAI,WAAW,CAAC,IAAI,EAAE;EACzC,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,MAAM,IAAI,CAAC,IAAI,CAAC;IAChB,MAAM,IAAI,CAAC,KAAK,CAAC;GAClB;CACF,CAAC,CAAC;AACH,AAAO,MAAM,oBAAoB,GAAG,QAAQ,CAAC,sBAAsB,CAAC,CAAC;AACrE,AAAO,MAAM,gBAAgB,GAAG,QAAQ,CAAC,kBAAkB,CAAC,CAAC;AAC7D,AAAO,MAAM,iBAAiB,GAAG,QAAQ,CAAC,mBAAmB,CAAC,CAAC;AAC/D,AAAO,MAAM,gBAAgB,GAAG,WAAW,CAAC,kBAAkB,EAAE;EAC9D,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,MAAM,IAAI,CAAC,MAAM,CAAC;IAClB,MAAM,IAAI,CAAC,QAAQ,CAAC;GACrB;CACF,CAAC,CAAC;AACH,AAAO,MAAM,qBAAqB,GAAG,WAAW,CAAC,uBAAuB,EAAE;EACxE,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,MAAM,IAAI,CAAC,IAAI,CAAC;IAChB,MAAM,IAAI,CAAC,UAAU,CAAC;IACtB,MAAM,IAAI,CAAC,SAAS,CAAC;GACtB;CACF,CAAC,CAAC;AACH,AAAO,MAAM,cAAc,GAAG,WAAW,CAAC,gBAAgB,EAAE;EAC1D,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,MAAM,IAAI,CAAC,MAAM,CAAC;IAClB,OAAO,IAAI,CAAC,SAAS,CAAC;GACvB;CACF,CAAC,CAAC;AACH,AAAO,MAAM,kBAAkB,GAAG,WAAW,CAAC,oBAAoB,EAAE;EAClE,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,OAAO,IAAI,CAAC,WAAW,CAAC;GACzB;CACF,CAAC,CAAC;;;;AAIH,AAAO,MAAM,mBAAmB,GAAG,WAAW,CAAC,qBAAqB,EAAE;EACpE,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,MAAM,IAAI,CAAC,EAAE,CAAC;IACd,OAAO,IAAI,CAAC,MAAM,CAAC;IACnB,MAAM,IAAI,CAAC,IAAI,CAAC;GACjB;CACF,CAAC,CAAC;;AAEH,AAAO,MAAM,WAAW,GAAG,WAAW,CAAC,aAAa,EAAE;EACpD,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,MAAM,IAAI,CAAC,IAAI,CAAC;IAChB,MAAM,IAAI,CAAC,UAAU,CAAC;IACtB,MAAM,IAAI,CAAC,SAAS,CAAC;GACtB;CACF,CAAC,CAAC;AACH,AAAO,MAAM,cAAc,GAAG,WAAW,CAAC,gBAAgB,EAAE;EAC1D,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,OAAO,IAAI,CAAC,IAAI,CAAC;GAClB;CACF,CAAC,CAAC;AACH,AAAO,MAAM,mBAAmB,GAAG,WAAW,CAAC,qBAAqB,EAAE;EACpE,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,MAAM,IAAI,CAAC,UAAU,CAAC;GACvB;CACF,CAAC,CAAC;AACH,AAAO,MAAM,cAAc,GAAG,WAAW,CAAC,gBAAgB,CAAC,CAAC;AAC5D,AAAO,MAAM,iBAAiB,GAAG,WAAW,CAAC,mBAAmB,CAAC,CAAC;AAClE,MAAM,YAAY,GAAG,CAAC,IAAI,KAAK,WAAW;EACxC,IAAI,EAAE;IACJ,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;MACrB,MAAM,IAAI,CAAC,QAAQ,CAAC;KACrB;GACF,CAAC,CAAC;AACL,AAAO,MAAM,eAAe,GAAG,YAAY,CAAC,iBAAiB,CAAC,CAAC;AAC/D,AAAO,MAAM,cAAc,GAAG,YAAY,CAAC,gBAAgB,CAAC,CAAC;AAC7D,AAAO,MAAM,iBAAiB,GAAG,YAAY,CAAC,mBAAmB,CAAC,CAAC;AACnE,AAAO,MAAM,aAAa,GAAG,WAAW,CAAC,eAAe,EAAE;EACxD,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,MAAM,IAAI,CAAC,MAAM,CAAC;IAClB,MAAM,IAAI,CAAC,IAAI,CAAC;GACjB;CACF,CAAC,CAAC;AACH,AAAO,MAAM,eAAe,GAAG,WAAW,CAAC,iBAAiB,EAAE;EAC5D,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,MAAM,IAAI,CAAC,YAAY,CAAC;IACxB,OAAO,IAAI,CAAC,KAAK,CAAC;GACnB;CACF,CAAC,CAAC;AACH,AAKG;AACH,AAAO,MAAM,cAAc,GAAG,WAAW,CAAC,gBAAgB,EAAE;EAC1D,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,MAAM,IAAI,CAAC,UAAU,CAAC;GACvB;CACF,CAAC,CAAC;AACH,AAAO,MAAM,YAAY,GAAG,WAAW,CAAC,cAAc,EAAE;EACtD,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,MAAM,IAAI,CAAC,KAAK,CAAC;IACjB,MAAM,IAAI,CAAC,OAAO,CAAC;IACnB,MAAM,IAAI,CAAC,SAAS,CAAC;GACtB;CACF,CAAC,CAAC;AACH,AAKG;AACH,AAAO,MAAM,cAAc,GAAG,WAAW,CAAC,gBAAgB,EAAE;EAC1D,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,MAAM,IAAI,CAAC,IAAI,CAAC;IAChB,MAAM,IAAI,CAAC,IAAI,CAAC;GACjB;CACF,CAAC,CAAC;AACH,AAAO,MAAM,gBAAgB,GAAG,WAAW,CAAC,kBAAkB,EAAE;EAC9D,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,MAAM,IAAI,CAAC,IAAI,CAAC;IAChB,MAAM,IAAI,CAAC,IAAI,CAAC;GACjB;CACF,CAAC,CAAC;AACH,AAKG;AACH,AAAO,MAAM,mBAAmB,GAAG,WAAW,CAAC,qBAAqB,EAAE;EACpE,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,OAAO,IAAI,CAAC,YAAY,CAAC;GAC1B;CACF,CAAC,CAAC;AACH,AAKG;AACH,AAMG;AACH,AAAO,MAAM,gBAAgB,GAAG,WAAW,CAAC,kBAAkB,EAAE;EAC9D,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,MAAM,IAAI,CAAC,IAAI,CAAC;GACjB;CACF,CAAC,CAAC;;AAEH,AAAO,MAAM,OAAO,GAAG,WAAW,CAAC,SAAS,EAAE;EAC5C,GAAG,MAAM,CAAC,QAAQ,EAAE,GAAG;IACrB,OAAO,IAAI,CAAC,IAAI,CAAC;GAClB;CACF,CAAC,CAAC;;;AAGH,AAAO,UAAU,QAAQ,EAAE,IAAI,EAAE;EAC/B,MAAM,IAAI,CAAC;EACX,IAAI,IAAI,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE;IACjC,KAAK,IAAI,KAAK,IAAI,IAAI,EAAE;MACtB,OAAO,QAAQ,CAAC,KAAK,CAAC,CAAC;KACxB;GACF;CACF;;;AAGD,AAEE;;AAEF,AAAO,MAAM,KAAK,GAAG,CAAC,GAAG,QAAQ,KAAK;EACpC,MAAM,iBAAiB,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,IAAI,KAAK;IACvD,KAAK,IAAI,QAAQ,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;MACtC,MAAM,GAAG,GAAG,GAAG,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC;MAChC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;MACzB,GAAG,CAAC,QAAQ,CAAC,GAAG,GAAG,CAAC;KACrB;IACD,OAAO,GAAG,CAAC;GACZ,EAAE,EAAE,CAAC,CAAC;;EAEP,OAAO,IAAI,IAAI;IACb,KAAK,IAAI,CAAC,IAAI,QAAQ,CAAC,IAAI,CAAC,EAAE;MAC5B,IAAI,iBAAiB,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE;QAC7B,KAAK,IAAI,KAAK,IAAI,iBAAiB,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE;UAC3C,KAAK,CAAC,CAAC,CAAC,CAAC;SACV;OACF;KACF;GACF,CAAC;CACH;;AC3OD,MAAM,SAAS,GAAG,CAAC,OAAO,EAAE,EAAE,KAAK;EACjC,IAAI,CAAC,EAAE,EAAE;IACP,OAAO,OAAO,CAAC;GAChB,MAAM;IACL,OAAO,MAAM,IAAI,OAAO,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;GACtC;CACF,CAAC;;AAEF,AAAO,MAAM,kBAAkB,GAAG,CAAC,MAAM,EAAE,IAAI,GAAG,CAAC,GAAG,CAAC,EAAE,UAAU,GAAG,EAAE,KAAK;EAC3E,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;EAChD,MAAM,CAAC,IAAI,EAAE,KAAK,EAAE,SAAS,CAAC,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;EACpD,IAAI,IAAI,IAAI,UAAU,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE;IAC1C,OAAO,UAAU,CAAC;GACnB;EACD,UAAU,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC;EACxC,OAAO,kBAAkB,CAAC,MAAM,EAAE,IAAI,EAAE,UAAU,CAAC,CAAC;CACrD,CAAC;AACF,AAAO,MAAM,qBAAqB,GAAG,CAAC,EAAE,KAAK,MAAM,IAAI;EACrD,MAAM,IAAI,GAAG,EAAE,CAAC,MAAM,CAAC,CAAC;EACxB,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;EACvB,OAAO,IAAI,CAAC;CACb,CAAC;AACF,AAAO,MAAM,iCAAiC,GAAG,MAAM,IAAI;EACzD,MAAM,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;EAC/C,OAAO,SAAS,KAAK,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,qBAAqB,CAAC,MAAM,CAAC,GAAG,qBAAqB,CAAC,wBAAwB,CAAC,CAAC,MAAM,CAAC,CAAC;CAChI,CAAC;AACF,AAAO,MAAM,cAAc,GAAG,CAAC,MAAM,KAAK;EACxC,MAAM,CAAC,WAAW,EAAE,CAAC;EACrB,MAAM,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;EAC9C,OAAO,MAAM,CAAC,YAAY,CAAC,SAAS,CAAC,GAAG,MAAM,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC,MAAM,CAAC,GAAG,qBAAqB,CAAC,wBAAwB,CAAC,CAAC,MAAM,CAAC,CAAC;CAC1I,CAAC;;AAEF,AAAO,MAAM,qBAAqB,GAAG,CAAC,MAAM,EAAE,UAAU,GAAG,EAAE,KAAK;EAChE,MAAM,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;EAC9C,IAAI,SAAS,KAAK,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;IACjC,OAAO,UAAU,CAAC;GACnB;;EAED,IAAI,SAAS,KAAK,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;IACjC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC;GACxC,MAAM;IACL,MAAM,CAAC,GAAG,EAAE,CAAC;GACd;EACD,OAAO,qBAAqB,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;CAClD,CAAC;AACF,AAAO,MAAM,wBAAwB,GAAG,SAAS,CAACE,mBAAuB,EAAE,MAAM,IAAI;EACnF,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;EAC1B,MAAM,IAAI,GAAG;IACX,EAAE,EAAE,+BAA+B,CAAC,MAAM,CAAC;IAC3C,KAAK,EAAE,KAAK;IACZ,SAAS,EAAE,KAAK;GACjB,CAAC;EACF,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,IAAI,CAAC,MAAM,GAAG,qBAAqB,CAAC,MAAM,CAAC,CAAC;EAC5C,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,IAAI,CAAC,IAAI,GAAG,mBAAmB,CAAC,MAAM,CAAC,CAAC;EACxC,OAAO,IAAI,CAAC;CACb,CAAC,CAAC;;AAEH,AAAO,MAAM,gBAAgB,GAAG,SAAS,CAACC,WAAe,EAAE,MAAM,IAAI;EACnE,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;EACpB,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,MAAM,IAAI,GAAG,MAAM,CAAC,UAAU,EAAE,CAAC;EACjC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,MAAM,UAAU,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC;EAC1C,IAAI,SAAS,GAAG,IAAI,CAAC;EACrB,IAAI,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;IAC7B,SAAS,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC;GACpC;EACD,OAAO;IACL,IAAI;IACJ,UAAU;IACV,SAAS;GACV,CAAC;CACH,CAAC,CAAC;;AAEH,AAAO,MAAM,mBAAmB,GAAG,SAAS,CAACC,cAAkB,EAAE,MAAM,IAAI;EACzE,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,MAAM,IAAI,GAAG;IACX,IAAI,EAAE,kBAAkB,CAAC,MAAM,CAAC;GACjC,CAAC;EACF,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,OAAO,IAAI,CAAC;CACb,CAAC,CAAC;;AAEH,AAAO,MAAM,wBAAwB,GAAG,SAAS,CAACC,mBAAuB,EAAE,MAAM,KAAK;EACpF,UAAU,EAAE,MAAM,CAAC,UAAU,EAAE;CAChC,CAAC,CAAC,CAAC;;AAEJ,AAAO,MAAM,mBAAmB,GAAG,SAAS,CAACC,cAAkB,EAAE,MAAM,IAAI;EACzE,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;CACpB,CAAC,CAAC;;AAEH,AAAO,MAAM,sBAAsB,GAAG,SAAS,CAACC,iBAAqB,CAAC,CAAC;;AAEvE,AAAO,MAAM,oBAAoB,GAAG,SAAS,CAACC,eAAmB,EAAE,MAAM,IAAI;EAC3E,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;EACxB,OAAO;IACL,QAAQ,EAAE,MAAM,CAAC,UAAU,EAAE;GAC9B,CAAC;CACH,CAAC,CAAC;;AAEH,AAAO,MAAM,mBAAmB,GAAG,SAAS,CAACC,cAAkB,EAAE,MAAM,IAAI;EACzE,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;EACvB,OAAO;IACL,QAAQ,EAAE,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC;GAChC,CAAC;CACH,CAAC,CAAC;;AAEH,AAAO,MAAM,sBAAsB,GAAG,SAAS,CAACC,iBAAqB,EAAE,MAAM,IAAI;EAC/E,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;EAC1B,OAAO;IACL,QAAQ,EAAE,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC;GAChC,CAAC;CACH,CAAC,CAAC;;AAEH,AAAO,MAAM,kBAAkB,GAAG,SAAS,CAACC,aAAiB,EAAE,MAAM,IAAI;EACvE,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;EACtB,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,MAAM,MAAM,GAAG,MAAM,CAAC,UAAU,EAAE,CAAC;EACnC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,OAAO;IACL,MAAM;IACN,IAAI,EAAE,cAAc,CAAC,MAAM,CAAC;GAC7B,CAAC;CACH,CAAC,CAAC;;AAEH,AAAO,MAAM,oBAAoB,GAAG,SAAS,CAACC,eAAmB,EAAE,MAAM,IAAI;EAC3E,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;EACxB,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,MAAM,YAAY,GAAG,MAAM,CAAC,UAAU,EAAE,CAAC;EACzC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,MAAM,KAAK,GAAG,gBAAgB,CAAC,MAAM,CAAC,CAAC;EACvC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,OAAO;IACL,YAAY;IACZ,KAAK;GACN,CAAC;CACH,CAAC,CAAC;;AAEH,AAAO,MAAM,gBAAgB,GAAG,CAAC,MAAM,EAAE,KAAK,GAAG,EAAE,KAAK;EACtD,MAAM,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;EAC9C,IAAI,SAAS,KAAK,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,SAAS,KAAK,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;IAC3E,OAAO,KAAK,CAAC;GACd;EACD,MAAM,CAAC,GAAG,EAAE,CAAC;EACb,KAAK,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC,CAAC;EAC/C,OAAO,gBAAgB,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;CACxC,CAAC;;AAEF,AAAO,MAAM,eAAe,GAAG,CAAC,MAAM,EAAE,SAAS,KAAK;EACpD,MAAM,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC;EACzB,MAAM,IAAI,GAAG;IACX,IAAI,EAAE,YAAY;IAClB,IAAI,EAAE,IAAI,KAAK,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,UAAU,EAAE,GAAG,IAAI;GAC/D,CAAC;EACF,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,IAAI,CAAC,UAAU,GAAG,kBAAkB,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,MAAM,EAAE,SAAS,CAAC,CAAC,CAAC;EACvE,OAAO,IAAI,CAAC;CACb,CAAC;;AAEF,AAAO,MAAM,mBAAmB,GAAG,SAAS,CAACC,cAAkB,EAAE,MAAM,IAAI;EACzE,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;EACvB,OAAO;IACL,UAAU,EAAE,MAAM,CAAC,UAAU,EAAE;GAChC,CAAC;CACH,CAAC,CAAC;;AAEH,AAAO,MAAM,iBAAiB,GAAG,SAAS,CAACC,YAAgB,EAAE,MAAM,IAAI;EACrE,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;EACrB,MAAM,IAAI,GAAG,CAAC,KAAK,EAAE,mBAAmB,CAAC,MAAM,CAAC,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;EAClF,IAAI,MAAM,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE;IAC9B,MAAM,OAAO,GAAG,CAAC,IAAI,EAAE,aAAa,CAAC,CAAC;IACtC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;IACnB,OAAO,CAAC,KAAK,GAAG,MAAM,CAAC,UAAU,EAAE,CAAC;IACpC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;IACnB,OAAO,CAAC,IAAI,GAAG,mBAAmB,CAAC,MAAM,CAAC,CAAC;IAC3C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;GACxB;EACD,IAAI,MAAM,CAAC,UAAU,CAAC,SAAS,CAAC,EAAE;IAChC,IAAI,CAAC,SAAS,GAAG,mBAAmB,CAAC,MAAM,CAAC,CAAC;GAC9C;EACD,OAAO,IAAI,CAAC;CACb,CAAC,CAAC;;AAEH,AAAO,MAAM,mBAAmB,GAAG,SAAS,CAACC,cAAkB,EAAE,MAAM,IAAI;EACzE,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;EACvB,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,MAAM,IAAI,GAAG;IACX,IAAI,EAAE,MAAM,CAAC,UAAU,EAAE;GAC1B,CAAC;EACF,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,IAAI,CAAC,IAAI,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC;EACnC,OAAO,IAAI,CAAC;CACb,CAAC,CAAC;;AAEH,AAAO,MAAM,qBAAqB,GAAG,SAAS,CAACC,gBAAoB,EAAE,MAAM,IAAI;EAC7E,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;EACpB,MAAM,IAAI,GAAG;IACX,IAAI,EAAE,cAAc,CAAC,MAAM,CAAC;GAC7B,CAAC;EACF,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;EACvB,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,IAAI,CAAC,IAAI,GAAG,MAAM,CAAC,UAAU,EAAE,CAAC;EAChC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,OAAO,IAAI,CAAC;CACb,CAAC,CAAC;;;AAGH,AAAO,MAAM,+BAA+B,GAAG,MAAM,IAAI;EACvD,OAAO,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;CAC9B,CAAC;;AAEF,AAAO,MAAM,wBAAwB,GAAG,CAAC,MAAM,EAAE,WAAW,GAAG,EAAE,KAAK;EACpE,MAAM,EAAE,GAAG,+BAA+B,CAAC,MAAM,CAAC,CAAC;EACnD,IAAI,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;EAC5C,IAAI,IAAI,GAAG,IAAI,CAAC;EAChB,MAAM,IAAI,GAAG;IACX,IAAI,EAAE,oBAAoB;IAC1B,EAAE,EAAE,EAAE;GACP,CAAC;;EAEF,MAAM,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC9B,IAAI,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;IAC1B,IAAI,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC,CAAC;IAC3D,SAAS,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC,KAAK,CAAC;GACtC;;EAED,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;;EAEjB,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;;EAEvB,IAAI,SAAS,KAAK,KAAK,EAAE;IACvB,OAAO,WAAW,CAAC;GACpB;;EAED,MAAM,CAAC,GAAG,EAAE,CAAC;;EAEb,OAAO,wBAAwB,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;CACtD,CAAC;;AAEF,AAAO,MAAM,wBAAwB,GAAG,SAAS,CAACC,mBAAuB,EAAE,MAAM,IAAI;EACnF,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;EACrB,OAAO;IACL,IAAI,EAAE,KAAK;IACX,YAAY,EAAE,wBAAwB,CAAC,MAAM,CAAC;GAC/C,CAAC;CACH,CAAC,CAAC;;AAEH,MAAM,gBAAgB,GAAG,MAAM,IAAI;EACjC,MAAM,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;EAC9C,QAAQ,SAAS,CAAC,IAAI;IACpB,KAAK,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC;MACnB,OAAO,OAAO,CAAC;IACjB,KAAK,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC;MACnB,OAAO,OAAO,CAAC;IACjB;MACE,OAAO,KAAK,CAAC;GAChB;CACF,CAAC;AACF,MAAM,OAAO,GAAG,CAAC,MAAM,EAAE,IAAI,KAAK;EAChC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;EACpB,MAAM,CAAC,GAAG;IACR,IAAI,EAAE,gBAAgB;IACtB,IAAI;GACL,CAAC;EACF,CAAC,CAAC,KAAK,GAAG,MAAM,CAAC,UAAU,EAAE,CAAC;EAC9B,OAAO,CAAC,CAAC;CACV,CAAC;AACF,MAAM,KAAK,GAAG,CAAC,MAAM,EAAE,IAAI,KAAK;EAC9B,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,MAAM,CAAC,GAAG;IACR,IAAI,EAAE,cAAc;IACpB,IAAI;IACJ,IAAI,EAAE,MAAM,CAAC,UAAU,EAAE;GAC1B,CAAC;EACF,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,CAAC,CAAC,MAAM,GAAG,MAAM,CAAC,UAAU,EAAE,CAAC;EAC/B,OAAO,CAAC,CAAC;CACV,CAAC;;;AAGF,MAAM,OAAO,GAAG,CAAC,MAAM,EAAE,IAAI,KAAK;EAChC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;EACpB,OAAO,EAAE,CAAC;CACX,CAAC;;AAEF,AAAO,MAAM,iBAAiB,GAAG,MAAM,IAAI;EACzC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;EACrB,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;EAC1C,IAAI,eAAe,EAAE,IAAI,CAAC;EAC1B,IAAI,KAAK,KAAK,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;IAC/B,eAAe,GAAG,wBAAwB,CAAC,MAAM,CAAC,CAAC;GACpD,MAAM;IACL,eAAe,GAAG,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;GAC/E;EACD,MAAM,UAAU,GAAG,gBAAgB,CAAC,MAAM,CAAC,CAAC;EAC5C,IAAI,GAAG,UAAU,CAAC,MAAM,EAAE,eAAe,CAAC,CAAC;EAC3C,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,IAAI,CAAC,IAAI,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC;EACnC,OAAO,IAAI,CAAC;CACb,CAAC;;AAEF,AAAO,MAAM,qBAAqB,GAAG,SAAS,CAACC,gBAAoB,EAAE,MAAM,IAAI;EAC7E,MAAM,IAAI,GAAG;IACX,KAAK,EAAE,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC;GAC7B,CAAC;EACF,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,IAAI,CAAC,IAAI,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC;EACnC,OAAO,IAAI,CAAC;CACb,CAAC;;ACtTF;;;AAGA,MAAM,MAAM,GAAG,CAAC,OAAO,EAAE,EAAE,KAAK,MAAM,IAAI,OAAO,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;;AAE9D,MAAM,KAAK,GAAG,CAAC,OAAO,EAAE,EAAE,KAAK,CAAC,MAAM,EAAE,IAAI,EAAE,QAAQ,KAAK,OAAO,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;;;AAG/F,MAAM,OAAO,GAAG,CAAC,IAAI,EAAE,GAAG,KAAK,MAAM,CAAC,IAAI,EAAE,CAAC,MAAM,KAAK;EACtD,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,GAAG,MAAM,CAAC,IAAI,EAAE,CAAC;EACrC,OAAO,GAAG,GAAG,CAAC,CAAC,GAAG,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;CACxC,CAAC,CAAC;AACH,MAAM,iBAAiB,GAAG,CAAC,IAAI,KAAK,MAAM,CAAC,IAAI,EAAE,CAAC,MAAM,KAAK;EAC3D,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,GAAG,MAAM,CAAC,IAAI,EAAE,CAAC;EACrC,OAAO;IACL,QAAQ,EAAE,KAAK,CAAC,KAAK;IACrB,QAAQ,EAAE,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;IAC9D,MAAM,EAAE,IAAI;GACb,CAAC;CACH,CAAC,CAAC;AACH,AAAO,MAAM,oBAAoB,GAAG,CAAC,MAAM,KAAK;EAC9C,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,MAAM,GAAG,GAAG,MAAM,CAAC,UAAU,EAAE,CAAC;EAChC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,OAAO,GAAG,CAAC;CACZ,CAAC;AACF,AAAO,MAAM,oBAAoB,GAAG,iBAAiB,CAACC,eAAmB,CAAC,CAAC;AAC3E,AAAO,MAAM,mBAAmB,GAAG,OAAO,CAACC,cAAkB,CAAC,CAAC;AAC/D,AAAO,MAAM,sBAAsB,GAAG,OAAO,CAACC,OAAW,EAAE,OAAO,CAAC,CAAC;AACpE,AAAO,MAAM,yBAAyB,GAAG,OAAO,CAACC,UAAc,EAAE,MAAM,CAAC,CAAC;AACzE,AAAO,MAAM,6BAA6B,GAAG,MAAM,CAACD,OAAW,EAAE,MAAM,IAAI;EACzE,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,GAAG,MAAM,CAAC,IAAI,EAAE,CAAC;EACtC,OAAO;IACL,KAAK,EAAE,MAAM,CAAC,KAAK;IACnB,KAAK,EAAE;MACL,OAAO,EAAE,MAAM,CAAC,KAAK,CAAC,MAAM;MAC5B,KAAK,EAAE,MAAM,CAAC,KAAK,CAAC,KAAK;KAC1B;GACF;CACF,CAAC,CAAC;AACH,AAAO,MAAM,6BAA6B,GAAG,iBAAiB,CAACE,gBAAoB,CAAC,CAAC;AACrF,AAAO,MAAM,uBAAuB,GAAG,MAAM,CAACC,kBAAsB,EAAE,CAAC,MAAM,KAAK;EAChF,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;EAC1B,MAAM,IAAI,GAAG;IACX,EAAE,EAAE,IAAI;IACR,KAAK,EAAE,KAAK;IACZ,SAAS,EAAE,KAAK;GACjB,CAAC;EACF,MAAM,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;EAC9C,IAAI,SAAS,KAAK,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;IACjC,IAAI,CAAC,EAAE,GAAG,+BAA+B,CAAC,MAAM,CAAC,CAAC;GACnD;EACD,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,IAAI,CAAC,MAAM,GAAG,qBAAqB,CAAC,MAAM,CAAC,CAAC;EAC5C,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,IAAI,CAAC,IAAI,GAAG,mBAAmB,CAAC,MAAM,CAAC,CAAC;EACxC,OAAO,IAAI,CAAC;CACb,CAAC,CAAC;AACH,AAAO,MAAM,kBAAkB,GAAG,MAAM,CAACC,aAAiB,EAAE,MAAM,IAAI;EACpE,MAAM,CAAC,KAAK,EAAE,QAAQ,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;EAC/C,MAAM,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC,CAAC;EACvE,OAAO;IACL,MAAM,EAAE,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,GAAG,MAAM;IAC9C,SAAS,EAAE,MAAM,CAAC,SAAS,GAAG,MAAM,CAAC,SAAS,GAAG,EAAE;GACpD,CAAC;CACH,CAAC,CAAC;;;AAGH,MAAM,kBAAkB,GAAG,CAAC,MAAM,EAAE,QAAQ,GAAG,EAAE,KAAK;EACpD,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;EAC1C,IAAI,KAAK,KAAK,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;IAC7B,OAAO,QAAQ,CAAC;GACjB;EACD,MAAM,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC9B,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;EACnE,MAAM,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;EAC9C,IAAI,SAAS,KAAK,KAAK,EAAE;IACvB,MAAM,CAAC,GAAG,EAAE,CAAC;GACd;EACD,OAAO,kBAAkB,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;CAC7C,CAAC;AACF,AAAO,MAAM,2BAA2B,GAAG,MAAM,CAACC,eAAmB,EAAE,CAAC,MAAM,KAAK;EACjF,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,MAAM,IAAI,GAAG;IACX,QAAQ,EAAE,kBAAkB,CAAC,MAAM,CAAC;GACrC,CAAC;EACF,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,OAAO,IAAI,CAAC;CACb,CAAC,CAAC;;AAEH,MAAM,iBAAiB,GAAG,CAAC,MAAM,EAAE,UAAU,GAAG,EAAE,KAAK;EACrD,MAAM,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;EAC9C,IAAI,SAAS,KAAK,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;IACjC,OAAO,UAAU,CAAC;GACnB;EACD,IAAI,SAAS,KAAK,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;IACjC,UAAU,CAAC,IAAI,CAAC,6BAA6B,CAAC,MAAM,CAAC,CAAC,CAAC;GACxD,MAAM;IACL,MAAM,CAAC,GAAG,EAAE,CAAC;GACd;EACD,OAAO,iBAAiB,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;CAC9C,CAAC;AACF,MAAM,cAAc,GAAG,CAAC,MAAM,EAAE,KAAK,KAAK,KAAK,KAAK,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,IAAI,KAAK,UAAU,CAAC,UAAU,IAAI,KAAK,CAAC,IAAI,KAAK,UAAU,CAAC,cAAc,IAAI,KAAK,CAAC,IAAI,KAAK,UAAU,CAAC,aAAa,IAAI,KAAK,CAAC,UAAU,KAAK,IAAI,CAAC;AAChO,AAAO,MAAM,6BAA6B,GAAG,MAAM,CAACC,QAAY,EAAE,MAAM,IAAI;EAC1E,MAAM,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;EAC9C,IAAI,GAAG,CAAC;EACR,IAAI,IAAI,GAAG,MAAM,CAAC;EAClB,IAAI,KAAK,GAAG,IAAI,CAAC;EACjB,IAAI,QAAQ,GAAG,KAAK,CAAC;EACrB,IAAI,SAAS,GAAG,KAAK,CAAC;EACtB,IAAI,MAAM,GAAG,KAAK,CAAC;EACnB,IAAI,cAAc,CAAC,MAAM,EAAE,SAAS,CAAC,EAAE;IACrC,IAAI,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;MAC1B,QAAQ,GAAG,IAAI,CAAC;MAChB,GAAG,GAAG,MAAM,CAAC,UAAU,EAAE,CAAC;MAC1B,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;KACpB,MAAM;MACL,GAAG,GAAG,MAAM,CAAC,UAAU,CAAC,EAAE,EAAC;KAC5B;IACD,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;IACnB,KAAK,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,kBAAkB,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAC;GACtE;;EAED,OAAO;IACL,GAAG;IACH,KAAK;IACL,IAAI;IACJ,QAAQ;IACR,MAAM;IACN,SAAS;GACV,CAAC;CACH,CAAC,CAAC;AACH,AAAO,MAAM,4BAA4B,GAAG,MAAM,CAACC,gBAAoB,EAAE,CAAC,MAAM,KAAK;EACnF,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,MAAM,IAAI,GAAG;IACX,UAAU,EAAE,iBAAiB,CAAC,MAAM,CAAC;GACtC,CAAC;EACF,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,OAAO,IAAI,CAAC;CACb,CAAC,CAAC;;;AAGH,MAAM,kBAAkB,GAAG,IAAI,IAAI,KAAK,CAAC,IAAI,EAAE,CAAC,MAAM,EAAE,IAAI,EAAE,QAAQ,KAAK;EACzE,OAAO;IACL,IAAI;IACJ,KAAK,EAAE,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;IAC7D,QAAQ,EAAE,QAAQ,CAAC,KAAK;GACzB,CAAC;CACH,CAAC,CAAC;AACH,MAAM,cAAc,GAAG,CAAC,MAAM,EAAE,WAAW,GAAG,EAAE,KAAK;EACnD,MAAM,CAAC,KAAK,EAAE,aAAa,CAAC,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;EAClD,MAAM,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;;EAE9B,IAAI,aAAa,KAAK,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;IACrC,OAAO,WAAW,CAAC;GACpB;;EAED,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;EACtE,MAAM,CAAC,KAAK,EAAE,SAAS,CAAC,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;;EAE9C,IAAI,SAAS,KAAK,KAAK,EAAE;IACvB,OAAO,WAAW,CAAC;GACpB;EACD,MAAM,CAAC,GAAG,EAAE,CAAC;EACb,OAAO,cAAc,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;CAC5C,CAAC;AACF,AAAO,MAAM,yBAAyB,GAAG,kBAAkB,CAACC,oBAAwB,CAAC,CAAC;AACtF,AAAO,MAAM,qBAAqB,GAAG,kBAAkB,CAACC,gBAAoB,CAAC,CAAC;AAC9E,AAAO,MAAM,sBAAsB,GAAG,kBAAkB,CAACC,iBAAqB,CAAC,CAAC;AAChF,AAAO,MAAM,2BAA2B,GAAG,KAAK,CAACC,gBAAoB,EAAE,CAAC,MAAM,EAAE,IAAI,EAAE,QAAQ,KAAK;EACjG,MAAM,QAAQ,GAAG,QAAQ,KAAK,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC9C,MAAM,IAAI,GAAG;IACX,MAAM,EAAE,IAAI;IACZ,QAAQ,EAAE,QAAQ;IAClB,QAAQ,EAAE,QAAQ,GAAG,MAAM,CAAC,UAAU,EAAE,GAAG,yBAAyB,CAAC,MAAM,CAAC;GAC7E,CAAC;EACF,IAAI,QAAQ,EAAE;IACZ,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;GACpB;EACD,OAAO,IAAI,CAAC;CACb,CAAC,CAAC;AACH,AAAO,MAAM,qBAAqB,GAAG,KAAK,CAACT,gBAAoB,EAAE,CAAC,MAAM,EAAE,IAAI,EAAE,QAAQ,MAAM;EAC5F,IAAI,EAAE,kBAAkB;EACxB,QAAQ,EAAE,IAAI;EACd,QAAQ,EAAE,QAAQ,CAAC,KAAK;EACxB,MAAM,EAAE,KAAK;CACd,CAAC,CAAC,CAAC;AACJ,AAAO,MAAM,0BAA0B,GAAG,KAAK,CAACU,qBAAyB,EAAE,CAAC,MAAM,EAAE,IAAI,KAAK;EAC3F,MAAM,IAAI,GAAG;IACX,IAAI;GACL,CAAC;EACF,MAAM,eAAe,GAAG,MAAM,CAAC,kBAAkB,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;EACnE,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC;EACrD,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC;EACpD,OAAO,IAAI,CAAC;CACb,CAAC,CAAC;AACH,AAAO,MAAM,mBAAmB,GAAG,KAAK,CAACC,cAAkB,EAAE,CAAC,MAAM,EAAE,MAAM,KAAK;EAC/E,MAAM,IAAI,GAAG;IACX,MAAM;IACN,SAAS,EAAE,cAAc,CAAC,MAAM,CAAC;GAClC,CAAC;EACF,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;EACnB,OAAO,IAAI,CAAC;CACb,CAAC,CAAC;;AAEH,AAAO,MAAM,uBAAuB,GAAG,KAAK,CAACC,kBAAsB,EAAE,CAAC,MAAM,EAAE,IAAI,KAAK;EACrF,IAAI,IAAI,GAAG,IAAI,CAAC;EAChB,MAAM,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC9B,MAAM,IAAI,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC,CAAC;EACjE,IAAI,IAAI,CAAC,IAAI,KAAK,oBAAoB,EAAE;IACtC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;GAC7B,MAAM;IACL,IAAI,GAAG;MACL,IAAI,EAAE,oBAAoB;MAC1B,WAAW,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC;MAC1B;GACF;EACD,OAAO,IAAI,CAAC;CACb,CAAC;;AC1NK,MAAM,uBAAuB,GAAG,MAAM;EAC3C,MAAM,QAAQ,GAAG,aAAa,EAAE,CAAC;;;;;;EAMjC,MAAM,SAAS,GAAG,IAAI,GAAG,EAAE,CAAC;;EAE5B,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEC,oBAAgC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC5F,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEA,oBAAgC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC5F,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEA,oBAAgC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC5F,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEA,oBAAgC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC5F,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,KAAK,EAAEA,oBAAgC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EACjG,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,EAAEA,oBAAgC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC/F,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,KAAK,EAAEA,oBAAgC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;;EAEjG,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAEC,6BAAyC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EACtG,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAEA,6BAAyC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;;EAEtG,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,aAAa,EAAE,CAAC,KAAK,EAAEC,sBAAkC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;EACrG,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,cAAc,EAAE,CAAC,KAAK,EAAEA,sBAAkC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;EACtG,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,wBAAwB,EAAE;IACjD,KAAK,EAAEC,6BAAyC;IAChD,UAAU,EAAE,CAAC,CAAC;GACf,CAAC,CAAC;EACH,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,EAAED,sBAAkC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;EACjG,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,KAAK,EAAEA,sBAAkC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;EAClG,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,EAAEA,sBAAkC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;EACjG,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEE,2BAAuC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;EACnG,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEC,4BAAwC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;;EAEpG,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,EAAEC,mBAA+B,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;EAC9F,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,UAAU,EAAE,CAAC,KAAK,EAAEC,yBAAqC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;;EAErG,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC,KAAK,EAAEC,uBAAmC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;EACtG,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,EAAEC,kBAA8B,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;;EAE5F,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEC,oBAAgC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;;;EAG5F,MAAM,QAAQ,GAAG,IAAI,GAAG,EAAE,CAAC;;EAE3B,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEC,uBAAmC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;;EAE7F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEC,0BAAsC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;;EAEhG,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEC,yBAAqC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;EAC/F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAEA,yBAAqC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;EAChG,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAEA,yBAAqC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;EAChG,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAEA,yBAAqC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;EAChG,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAEA,yBAAqC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;EAChG,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAEA,yBAAqC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;EAChG,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,EAAEA,yBAAqC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;EACjG,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,EAAEA,yBAAqC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;EACjG,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,EAAEA,yBAAqC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;EAClG,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAEA,yBAAqC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;EAChG,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAEA,yBAAqC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;EAChG,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAEA,yBAAqC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;;EAEhG,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAEC,qBAAiC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC7F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAEA,qBAAiC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC7F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,EAAEA,qBAAiC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC9F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,EAAEA,qBAAiC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC9F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEA,qBAAiC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC5F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAEA,qBAAiC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC7F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEA,qBAAiC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC5F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAEA,qBAAiC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC7F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAEA,qBAAiC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC7F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE,CAAC,KAAK,EAAEA,qBAAiC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EACrG,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAEA,qBAAiC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC7F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAEA,qBAAiC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC7F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,EAAEA,qBAAiC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC9F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEA,qBAAiC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC5F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEA,qBAAiC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC5F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEA,qBAAiC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC5F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEA,qBAAiC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC5F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEA,qBAAiC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC5F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAEA,qBAAiC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC7F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEA,qBAAiC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;EAC3F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEA,qBAAiC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;EAC3F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEA,qBAAiC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;;EAE3F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEC,2BAAuC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAClG,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEA,2BAAuC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;;EAElG,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAEC,sBAAkC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;EAC7F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAEA,sBAAkC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;;EAE7F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAEC,qBAAiC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;EAC7F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAEA,qBAAiC,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;;EAE7F,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAEC,mBAA+B,EAAE,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC;;;;;;EAM1F,MAAM,aAAa,GAAG,IAAI,GAAG,EAAE,CAAC;EAChC,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAACC,gBAA2B,CAAC,CAAC;EAClE,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAACC,mBAA8B,CAAC,CAAC;EACpE,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAACC,mBAA8B,CAAC,CAAC;EACpE,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAACC,iBAA4B,CAAC,CAAC;EACpE,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,qBAAqB,CAACC,wBAAmC,CAAC,CAAC,CAAC;EAClG,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,UAAU,CAAC,CAACC,wBAAmC,CAAC,CAAC;EAChF,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,qBAAqB,CAACC,oBAA+B,CAAC,CAAC,CAAC;EACjG,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,qBAAqB,CAACC,mBAA8B,CAAC,CAAC,CAAC;EAC/F,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,qBAAqB,CAACC,sBAAiC,CAAC,CAAC,CAAC;EACrG,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,qBAAqB,CAACC,mBAA8B,CAAC,CAAC,CAAC;EAC/F,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,qBAAqB,CAACC,mBAA8B,CAAC,CAAC,CAAC;EAC/F,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,qBAAqB,CAACC,qBAAgC,CAAC,CAAC,CAAC;EAC9F,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAACC,iBAA4B,CAAC,CAAC;EACpE,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,CAACC,oBAA+B,CAAC,CAAC;EAC1E,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,CAACC,kBAA6B,CAAC,CAAC;EACtE,aAAa,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,qBAAqB,CAACC,sBAAiC,CAAC,CAAC,CAAC;EACrG,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,UAAU,CAACC,iCAA4C,CAAC,CAAC;;EAEtF,OAAO,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE;IAC7B,QAAQ,CAAC,CAAC,KAAK,EAAE;MACf,OAAO,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;KACjC;IACD,SAAS,CAAC,CAAC,KAAK,EAAE;MAChB,OAAO,SAAS,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;KAClC;IACD,YAAY,CAAC,CAAC,KAAK,EAAE;MACnB,OAAO,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;KACtC;IACD,SAAS,CAAC,CAAC,KAAK,EAAE;MAChB,OAAO,SAAS,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;KAClC;IACD,QAAQ,CAAC,CAAC,KAAK,EAAE;MACf,OAAO,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC;KAChC;IACD,YAAY,CAAC,CAAC,KAAK,EAAE;MACnB,OAAO,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;KACtC;GACF,CAAC,CAAC;CACJ,CAAC;;;AAGF,uBAAe,uBAAuB,EAAE;;iDAAC,jDC5IzC;AACA,AAAO,MAAM,gBAAgB,GAAG,CAAC,QAAQ,EAAE,MAAM,EAAE,GAAG,OAAO,KAAK;EAChE,KAAK,IAAI,CAAC,IAAI,OAAO,EAAE;IACrB,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,KAAK,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;GACvC;EACD,OAAO,QAAQ,CAAC;CACjB,CAAC;;;AAGF,MAAM,WAAW,GAAG,CAAC,UAACvE,UAAO,EAAE,aAAa,EAAE,MAAM,EAAE,QAAQ,CAAC,KAAK;EAClE,MAAM,UAAU,GAAG,cAAc,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC;EAChE,MAAM,GAAG,GAAG,WAAW,CAAC,QAAQ,IAAI,aAAa,CAAC,QAAQ,CAAC,CAAC;EAC5D,MAAM,SAAS,GAAG,EAAE,IAAI,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC;;;EAG5C,OAAO,CAAC,IAAI,KAAK;;IAEf,MAAM,MAAM,GAAG,OAAO,CAAC,IAAI,EAAEA,UAAO,CAAC,CAAC;IACtC,MAAM,QAAQ,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC;IACtD,MAAM,MAAM,GAAG,EAAE,CAAC;IAClB,AAEA,MAAM,IAAI,GAAG,MAAM,QAAQ,CAAC,IAAI,EAAE,CAAC;;IAEnC,OAAO,gBAAgB,CAAC;MACtB,CAAC,MAAM,CAAC,QAAQ,EAAE,GAAG;QACnB,OAAO,IAAI,CAAC;OACb;MACD,SAAS,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;QACrB,IAAI,MAAM,CAAC,MAAM,GAAG,MAAM,EAAE;UAC1B,OAAO,MAAM,CAAC,MAAM,CAAC;SACtB;QACD,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;QACpB,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;OAC/B;MACD,UAAU,CAAC,CAAC,QAAQ,EAAE;QACpB,MAAM,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;QAC9C,IAAI,CAAC,IAAI,IAAI,QAAQ,KAAK,KAAK,EAAE;UAC/B,IAAI,CAAC,GAAG,EAAE,CAAC;UACX,OAAO,IAAI,CAAC;SACb;QACD,OAAO,KAAK,CAAC;OACd;MACD,MAAM,CAAC,CAAC,QAAQ,EAAE;QAChB,MAAM,SAAS,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;QAC9B,IAAI,QAAQ,KAAK,SAAS,CAAC,KAAK,EAAE;UAChC,MAAM,IAAI,KAAK,CAAC,CAAC,4BAA4B,EAAE,QAAQ,CAAC,QAAQ,CAAC,WAAW,EAAE,SAAS,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;SAC5G;QACD,OAAO,SAAS,CAAC;OAClB;MACD,IAAI,CAAC,GAAG;QACN,OAAO,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,KAAK,EAAE,GAAG,IAAI,EAAE,CAAC;OAChD;MACD,GAAG,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;QACf,MAAM,CAAC,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;QACtB,MAAM,IAAI,CAAC,CAAC;QACZ,OAAO,MAAM,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;OAC1C;KACF,EAAE,MAAM,EAAE,aAAa,EAAE,gBAAgB,CAAC,CAAC;GAC7C,CAAC;CACH,CAAC;;AAEF,aAAe,WAAW,CAAC,CAAC,OAAO,EAAEwE,cAAiB,EAAE,aAAa,EAAE,gBAAgB,CAAC,CAAC;;qFAAC,rFC9DnF,MAAM,aAAa,GAAG,CAAC,MAAM,GAAGC,gBAAe,KAAK;;EAEzD,MAAM,kBAAkB,GAAG,QAAQ,IAAI,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAAG,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;EAC7G,MAAM,mBAAmB,GAAG,QAAQ,IAAI,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;;EAEhH,MAAM,UAAU,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,KAAK;IACtD,MAAM,CAAC,cAAc,EAAE,CAAC;IACxB,MAAM,CAAC,KAAK,EAAE,QAAQ,CAAC,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;IAC7C,IAAI,CAAC,QAAQ,IAAI,UAAU,IAAI,kBAAkB,CAAC,QAAQ,CAAC,IAAI,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;MAC5F,OAAO,IAAI,CAAC;KACb;IACD,MAAM,CAAC,GAAG,EAAE,CAAC;IACb,MAAM,CAAC,WAAW,EAAE,CAAC;IACrB,MAAM,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;IACzE,OAAO,UAAU,CAAC,MAAM,EAAE,QAAQ,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;GACxD,CAAC;;EAEF,OAAO,IAAI,IAAI;;IAEb,MAAM,WAAW,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;;IAEjC,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC;QAC1C,MAAM,EAAE,MAAM,IAAI,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QACxD,UAAU,EAAE,MAAM,IAAI,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAChE,kBAAkB;QAClB,mBAAmB;QACnB,UAAU,CAAC,CAAC,UAAU,GAAG,CAAC,CAAC,EAAE,KAAK,GAAG,EAAE,EAAE;UACvC,MAAM,CAAC,WAAW,EAAE,CAAC;UACrB,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;UAC1C,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;YAC5B,IAAI,KAAK,CAAC,UAAU,KAAK,IAAI,EAAE;cAC7B,MAAM,CAAC,GAAG,EAAE,CAAC;cACb,OAAO,CAAC,IAAI,EAAE,YAAY,EAAE,IAAI,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC;aAChD;YACD,OAAO,IAAI,CAAC;WACb;UACD,MAAM,IAAI,GAAG,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;UACnD,OAAO,UAAU,CAAC,MAAM,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;SACpD;QACD,OAAO,CAAC,GAAG;UACT,OAAO,OAAO,CAAC;YACb,IAAI,EAAE,kBAAkB,CAAC,MAAM,CAAC;WACjC,CAAC,CAAC;SACJ;QACD,MAAM,CAAC,GAAG;UACR,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;SACpC;OACF,EAAE,WAAW,EAAE,WAAW,EAAE,MAAM,EAAE,KAAK,EAAE,aAAa,EAAE,gBAAgB,CAAC;MAC5E,MAAM,CAAC,CAAC;;IAEV,OAAO,MAAM,CAAC;GACf,CAAC;;CAEH,CAAC;;AAEF,AAGE;;AAEF,AAAO,MAAM,YAAY,GAAG,OAAO,IAAI;EACrC,MAAM,KAAK,GAAG,aAAa,EAAE,CAAC;EAC9B,OAAO,KAAK,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,CAAC;CACjC;;ACjED,MAAM,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;AACzB,MAAM,IAAI,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC;AAC7B,MAAM,KAAK,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC;AAC9B,MAAM,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,sBAAsB,CAAC,CAAC;;;;AAIpE,MAAM,OAAO,GAAG,CAAC;;CAEhB,CAAC,CAAC;;AAEH,MAAM,GAAG,GAAG,YAAY,CAAC,OAAO,CAAC,CAAC;;AAElC,MAAM,WAAW,GAAG,KAAK,CAAC;EACxB,OAAO,CAAC,CAAC,IAAI,EAAE;IACb,OAAO,CAAC,GAAG,CAAC,CAAC,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;GACvC;EACD,UAAU,CAAC,CAAC,IAAI,EAAE;IAChB,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;GACnB;CACF,EAAE;EACD,OAAO,CAAC,CAAC,IAAI,EAAE;IACb,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;GAC7B;EACD,mBAAmB,CAAC,IAAI,CAAC;IACvB,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;GACnB;CACF,CAAC,CAAC;;AAEH,WAAW,CAAC,GAAG,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;;iBAsBA;;;;"}