{"version":3,"file":"index.js","sources":["../../../tokenizer/src/utils.js","../../../tokenizer/src/source.js","../../../tokenizer/src/tokens.js","../../../tokenizer/src/chars.js","../../../tokenizer/src/scanners.js","../../../tokenizer/src/index.js","../../src/statements.js","../../src/expressions.js","../../src/tokens.js","../../src/source.js","../../src/index.js","../index.js"],"sourcesContent":["export const lazyMapWith = (fn) => function* (iterator) {\n  for (let i of iterator) {\n    yield fn(i);\n  }\n};\n\nexport const lazyFilterWith = fn => function* (iterator) {\n  for (let i of iterator) {\n    if (fn(i)) {\n      yield i;\n    }\n  }\n};","export const sourceStream = (code) => {\n  let index = 0;\n  const advance = (number = 1) => {\n    index += number;\n  };\n\n  const test = (regexp) => nextStretch().search(regexp) === 0;\n  const nextSubStr = (count = 1) => code.substr(index, count);\n  const seeNextAt = (offset = 0) => code[index + offset];\n  const nextStretch = () => nextSubStr(3); //we need three chars to be really sure of the current lexical production\n\n  const stream = {\n    test,\n    nextSubStr,\n    seeNextAt,\n    //advance stream\n    match (regexp) {\n      regexp.lastIndex = index;\n      const [rawValue] = regexp.exec(code);\n      advance(rawValue.length);\n      return rawValue;\n    },\n    //advance stream\n    read (length) {\n      const s = this.nextSubStr(length);\n      advance(length);\n      return s;\n    }\n  };\n\n  Object.defineProperty(stream, 'done', {\n    get () {\n      return code[index] === void 0;\n    }\n  });\n  Object.defineProperty(stream, 'index', {\n    get () {\n      return index;\n    }\n  });\n\n  return stream;\n};","export const categories = {\n  WhiteSpace: 0,\n  LineTerminator: 1,\n  SingleLineComment: 2,\n  MultiLineComment: 3,\n  Punctuator: 4,\n  Identifier: 5,\n  NumericLiteral: 6,\n  StringLiteral: 7,\n  RegularExpressionLiteral: 8,\n  Template: 9,\n  TemplateHead: 10,\n  TemplateMiddle: 11,\n  TemplateTail: 12\n};\n\n//defined as keywords\n//todo check async, let ?\nconst keywords = 'await break case catch class const continue debugger default delete do else export extends finally for function if import in instanceof new return super switch this throw try typeof var void while with yield'.split(' ');\nconst futureReservedKeyword = ['enum'];\nconst reservedKeywords = keywords.concat(futureReservedKeyword, ['null', 'true', 'false']);\n\n//defined as punctuators\nexport const puncutators = `{ ( ) [ ] . ... ; , < > <= >= == != === !== + - * % ** ++ -- << >> >>> & | ^ ! ~ && || ? : = += -= *= %= **= <<= >>= >>>= &= |= ^= => / /= }`.split(' ');\n\nexport const allowRegexpAfter = 'case delete do else in instanceof new return throw typeof void { ( [ . ; , < > <= >= == != === !== + - * << >> >>> & | ^ ! ~ && || ? : = += -= *= %= <<= >>= >>>= &= |= ^= /='.split(' ');\n\nconst createLanguageToken = (symbol, value) => {\n  const token = Object.create(null, {\n    type: {\n      get () {\n        return this; //type is an alias to itself (so we can use in Maps as we would to for other categories such literals, etc)\n      }\n    },\n    value: {value: value !== void 0 ? value : symbol},\n    rawValue: {value: symbol, enumerable: true},\n    isReserved: {value: reservedKeywords.includes(symbol), enumerable: true}\n  });\n\n  return Object.freeze(token);\n};\n\n//create a token table\nexport const tokenRegistry = () => {\n  const ecmaScriptTokens = puncutators.concat(keywords, futureReservedKeyword)\n    .map(symbol => ([symbol, createLanguageToken(symbol)]));\n  ecmaScriptTokens.push(['null', createLanguageToken('null', null)]);\n  ecmaScriptTokens.push(['true', createLanguageToken('true', true)]);\n  ecmaScriptTokens.push(['false', createLanguageToken('false', false)]);\n  ecmaScriptTokens.push(['of', createLanguageToken('of')]);\n\n  const tokenMap = new Map(ecmaScriptTokens);\n\n  return {\n    get (key) {\n      return tokenMap.get(key)\n    },\n    evaluate (lexeme) {\n      if (!tokenMap.has(lexeme.rawValue)) {\n        switch (lexeme.type) {\n          case categories.StringLiteral:\n            return Object.assign(lexeme, {\n              value: lexeme.rawValue.substr(1, lexeme.rawValue.length - 2)\n            });\n          case categories.NumericLiteral:\n            return Object.assign(lexeme, {value: Number(lexeme.rawValue)});\n          case categories.RegularExpressionLiteral:\n            return Object.assign(lexeme, {value: new RegExp(lexeme.pattern, lexeme.flags)});\n          default:\n            return Object.assign(lexeme, {value: lexeme.rawValue});\n        }\n      }\n      return tokenMap.get(lexeme.rawValue);\n    },\n    addToken () {\n      throw new Error('not implemented');\n    }\n  }\n};\n\nexport default tokenRegistry();","export const CHAR_STAR = '*';\nexport const CHAR_SLASH = '/';\nexport const MULTI_LINE_COMMENT_START = '/*';\nexport const SINGLE_LINE_COMMENT_START = '//';\nexport const CHAR_BACKSLASH = '\\\\';\nexport const CHAR_SINGLE_QUOTE = \"'\";\nexport const CHAR_DOUBLE_QUOTE = '\"';\nexport const CHAR_LEFT_BRACKET = '[';\nexport const CHAR_RIGHT_BRACKET = ']';\nexport const CHAR_DOT = '.';\nexport const SPREAD = '...';","import {\n  categories,\n  puncutators\n} from \"./tokens\";\nimport * as chars from \"./chars\";\n\nconst lexemeFromRegExp = (regExp, category) => sourceStream => ({type: category, rawValue: sourceStream.match(regExp)});\nconst testFromRegExp = regExp => sourceStream => sourceStream.test(regExp);\nconst productionFromRegexp = ({test, lexeme, category}) => () => {\n  //we create regexp dynamically so they are not global to every instance of the scanner\n  const testRegexp = new RegExp(test);\n  const lexemeRegexp = new RegExp(lexeme, 'y');\n  return {\n    test: testFromRegExp(testRegexp),\n    lexeme: lexemeFromRegExp(lexemeRegexp, category)\n  }\n};\n\nexport const numbers = productionFromRegexp({\n  category: categories.NumericLiteral,\n  test: `^(?:[1-9]|\\\\.\\\\d|0[1-9]?|0[xX][0-9a-fA-F]|0[bB][01]|0[oO][0-7])`,\n  lexeme: `0[xX][0-9a-fA-F]+|0[bB][01]+|0[oO][0-7]+|(?:(?:\\\\d+(?:\\\\.\\\\d*)?|\\\\.\\\\d+)(?:[eE][-+]?\\\\d+)?)`\n});\n\nexport const identifiers = productionFromRegexp({\n  category: categories.Identifier,\n  test: `^[$_a-zA-Z]`,\n  lexeme: `[$_a-zA-Z][$\\\\w]*`\n});\n\nexport const whiteSpace = productionFromRegexp({\n  category: categories.WhiteSpace,\n  test: `^(?:[\\\\u0009\\\\u000b\\\\u000c\\\\u0020\\\\u00a0\\\\ufeff])`,\n  lexeme: `[\\\\u0009\\\\u000b\\\\u000c\\\\u0020\\\\u00a0\\\\ufeff]+`\n});\n\nexport const lineTerminator = productionFromRegexp({\n  category: categories.LineTerminator,\n  test: `^(?:[\\\\u000a\\\\u000d\\\\u2028\\\\u2029])`,\n  lexeme: `[\\\\u000a\\\\u000d\\\\u2028\\\\u2029]+`\n});\n\nexport const singleLineComment = () => {\n  const lexemeRegExp = /\\/\\/.*/y;\n  return {\n    test: (sourceStream) => sourceStream.nextSubStr(2) === chars.SINGLE_LINE_COMMENT_START,\n    lexeme: lexemeFromRegExp(lexemeRegExp, categories.SingleLineComment)\n  };\n};\n\nexport const multiLineComment = () => {\n  const lexeme = (sourceStream, count = 2) => {\n    const next = sourceStream.seeNextAt(count);\n    count++;\n    if (next === chars.CHAR_STAR) {\n      const secondNext = sourceStream.seeNextAt(count);\n      if (secondNext === chars.CHAR_SLASH) {\n        return {\n          type: categories.MultiLineComment,\n          rawValue: sourceStream.read(count + 1)\n        }\n      }\n    }\n    return lexeme(sourceStream, count);\n  };\n  return {\n    test (sourceStream) {\n      return sourceStream.nextSubStr(2) === chars.MULTI_LINE_COMMENT_START;\n    },\n    lexeme\n  };\n};\n\nconst fromQuote = quote => {\n  const fn = (sourceStream, count = 1) => {\n    const next = sourceStream.seeNextAt(count);\n    count += 1;\n    if (next === quote) {\n      return {\n        type: categories.StringLiteral,\n        rawValue: sourceStream.read(count)\n      };\n    }\n    if (next === chars.CHAR_BACKSLASH) {\n      count += 1;\n    }\n    return fn(sourceStream, count);\n  };\n  return fn;\n};\nexport const stringLiteral = () => {\n  const singleQuote = fromQuote(chars.CHAR_SINGLE_QUOTE);\n  const doubleQuote = fromQuote(chars.CHAR_DOUBLE_QUOTE);\n  return {\n    test (sourceStream) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_SINGLE_QUOTE || next === chars.CHAR_DOUBLE_QUOTE;\n    },\n    lexeme (sourceStream) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_DOUBLE_QUOTE ? doubleQuote(sourceStream) : singleQuote(sourceStream);\n    }\n  };\n};\n\nexport const punctuators = (punctuatorList = puncutators) => {\n\n  const sizeOnePunctuatorList = punctuatorList.filter(p => p.length === 1);\n  const sizeTwoPunctuatorList = punctuatorList.filter(p => p.length === 2);\n  const sizeThreePunctuatorList = punctuatorList.filter(p => p.length === 3);\n  const sizeFourPunctuatorList = punctuatorList.filter(p => p.length === 4);\n\n  //micro optimization (this function will run often)\n  const isInPunctuatorList = (str) => {\n    switch (str.length) {\n      case 2:\n        return sizeTwoPunctuatorList.includes(str);\n      case 3:\n        return sizeThreePunctuatorList.includes(str);\n      case 4:\n        return sizeFourPunctuatorList.includes(str);\n      default:\n        return false;\n    }\n  };\n  const lexeme = (sourceStream, count = 1) => {\n    const nextStretch = sourceStream.nextSubStr(count + 1);\n    if (!isInPunctuatorList(nextStretch) || nextStretch.length !== count + 1 /*End of file */) {\n      return {\n        type: categories.Punctuator,\n        rawValue: sourceStream.read(count)\n      };\n    }\n    return lexeme(sourceStream, count + 1);\n  };\n  const lexemeFromDot = sourceStream => ({\n    type: categories.Punctuator,\n    rawValue: (sourceStream.nextSubStr(3) === chars.SPREAD) ? sourceStream.read(3) : sourceStream.read(1)\n  });\n  return {\n    test (sourceStream, allowRegexp) {\n      const next = sourceStream.seeNextAt();\n      return (next === chars.CHAR_SLASH && allowRegexp === false) || sizeOnePunctuatorList.includes(next);\n    },\n    lexeme: sourceStream => sourceStream.seeNextAt() === chars.CHAR_DOT ? lexemeFromDot(sourceStream) : lexeme(sourceStream)\n  };\n};\n\nconst scanRegExpBody = (sourceStream, count = 1) => {\n  const next = sourceStream.seeNextAt(count);\n  count += 1;\n  switch (next) {\n    case chars.CHAR_SLASH:\n      return count;\n    case chars.CHAR_LEFT_BRACKET: {\n      // slash are \"escaped\" in a regexp class\n      count = scanRegExpClass(sourceStream, count);//+1\n      break;\n    }\n    case chars.CHAR_BACKSLASH: {\n      count += 1;\n      break;\n    }\n  }\n  return scanRegExpBody(sourceStream, count);\n};\nconst scanRegExpClass = (sourceStream, count) => {\n  const next = sourceStream.seeNextAt(count);\n  count += 1;\n  switch (next) {\n    case chars.CHAR_RIGHT_BRACKET:\n      return count;\n    case chars.CHAR_BACKSLASH:\n      count += 1\n  }\n  return scanRegExpClass(sourceStream, count);\n};\n\nconst identifierPart = /[$\\w]/;\nconst scanRegExpFlags = (sourceStream, count) => {\n  const next = sourceStream.seeNextAt(count);\n  if (!next || !identifierPart.test(next)) {\n    return count;\n  }\n  return scanRegExpFlags(sourceStream, count + 1);\n};\n\nexport const regularExpression = () => {\n  return {\n    test (sourceStream, allowRegexp) {\n      const next = sourceStream.seeNextAt();\n      return allowRegexp && next === chars.CHAR_SLASH;\n    },\n    lexeme (sourceStream) {\n      const body = scanRegExpBody(sourceStream);\n      const withFlags = scanRegExpFlags(sourceStream, body);\n      const rawValue = sourceStream.read(withFlags);\n      return {\n        type: categories.RegularExpressionLiteral,\n        rawValue,\n        pattern: rawValue.substr(1, body - 2),\n        flags: rawValue.substr(body, withFlags - body)\n      };\n    }\n  };\n};\n\nexport const ECMAScriptLexicalGrammar = [\n  whiteSpace,\n  lineTerminator,\n  numbers,\n  singleLineComment,\n  multiLineComment,\n  regularExpression,\n  punctuators,\n  identifiers,\n  stringLiteral\n];\n\nexport const scanner = (lexicalRules = ECMAScriptLexicalGrammar.map(g => g())) => {\n  return (source, isRegexpAllowed) => {\n    const rule = lexicalRules.find(lr => lr.test(source, isRegexpAllowed));\n    if (rule === void 0) {\n      throw new Error(`could not understand the symbol ${source.seeNextAt()}`);\n    }\n    return rule.lexeme(source);\n  };\n};\n\nexport default scanner();\n","import {sourceStream} from \"./source\";\nimport {allowRegexpAfter} from \"./tokens\";\nimport {lazyFilterWith, lazyMapWith} from \"./utils\";\nimport {default as defaultScanner} from './scanners';\nimport {default as defaultRegistry} from './tokens';\n\n/* Note\n\nwe could greatly improve perf by directly yielding filtered (and evaluated token?) at the scanner level instead of passing every lexeme through a lazy stream combinators pipe chain,\nhowever we would lost the great flexibility we have here !\n\nfor example if we simply ignored white space, line terminators, etc.\nour filter combinator would have to run much less (at least for big files)\n\nbottom line: we value more modularity and flexibility of the system over performance\n\ntodo: later we can give ability to the consumer to configure the scanner to perform better\n\n*/\n\n\n//return an iterable sequence of lexemes (note it can only be consumed once like a generator)\n//The consumer (like a parser) will have to handle the syntactic state and the token evaluation by itself\nexport const lexemes = (code, scanner) => {\n  let isRegexpAllowed = true;\n  const source = sourceStream(code);\n  return {\n    * [Symbol.iterator] () {\n      while (true) {\n        if (source.done === true) {\n          return;\n        }\n        yield scanner(source, isRegexpAllowed);\n      }\n    },\n    allowRegexp () {\n      isRegexpAllowed = true;\n    },\n    disallowRegexp () {\n      isRegexpAllowed = false;\n    }\n  }\n};\n\nlet defaultFilter = t => t.type >= 4;\nconst defaultOptions = {\n  scanner: defaultScanner,\n  tokenRegistry: defaultRegistry,\n  evaluate: defaultRegistry.evaluate,\n  filter: defaultFilter\n};\n\n// a standalone tokenizer (ie uses some heuristics based on the last meaningful token to know how to scan a slash)\n// https://stackoverflow.com/questions/5519596/when-parsing-javascript-what-determines-the-meaning-of-a-slash\nexport const tokenize = function* (code, {scanner = defaultScanner, tokenRegistry = defaultRegistry, filter, evaluate} = defaultOptions) {\n  const filterFunc = lazyFilterWith(filter || defaultFilter);\n  const mapFunc = lazyMapWith(evaluate || tokenRegistry.evaluate);\n  const filterMap = iter => mapFunc(filterFunc(iter));\n  const stream = lexemes(code, scanner);\n\n  for (let t of filterMap(stream)) {\n    yield t;\n    if (Object.is(t.type, t) || t.type >= 4) {\n      if (allowRegexpAfter.includes(t.rawValue)) {\n        stream.allowRegexp();\n      } else {\n        stream.disallowRegexp();\n      }\n    }\n  }\n};","export const parseStatementList = (parser, exit = ['}'], statements = []) => {\n  const exitTokens = exit.map(s => parser.get(s)); // todo exit is not consistent with expression parser\n  const {done, value: nextToken} = parser.lookAhead();\n  if (done || exitTokens.includes(nextToken)) {\n    return statements;\n  }\n  statements.push(parseStatement(parser));\n  return parseStatementList(parser, exit, statements);\n};\n\nconst nodeTypeDecorator = (type) => fn => parser => Object.assign(fn(parser), {type});\n\nexport const withEventualSemiColon = (fn) => parser => {\n  const node = fn(parser);\n  parser.eventually(';');\n  return node;\n};\n\nexport const parseExpressionOrLabeledStatement = parser => {\n  const {value: nextToken} = parser.lookAhead(1);\n  return nextToken === parser.get(':') ? parseLabeledStatement(parser) : withEventualSemiColon(parseExpressionStatement)(parser);\n};\n\nexport const parseStatement = (parser) => {\n  parser.allowRegexp();\n  const {value: nextToken} = parser.lookAhead();\n  return parser.hasStatement(nextToken) ? parser.getStatement(nextToken)(parser) : withEventualSemiColon(parseExpressionStatement)(parser);\n};\n\nexport const parseFormalParameters = (parser, parameters = []) => {\n  const {value: nextToken} = parser.lookAhead();\n  if (nextToken === parser.get(')')) {\n    return parameters;\n  }\n\n  if (nextToken !== parser.get(',')) {\n    parameters.push(parser.expression(20));\n  } else {\n    parser.eat();\n  }\n  return parseFormalParameters(parser, parameters);\n};\n\nexport const parseFunctionDeclaration = parser => {\n  parser.expect('function');\n  const node = {\n    type: 'FunctionDeclaration',\n    id: parseBindingIdentifierOrPattern(parser),\n    async: false,\n    generator: false\n  };\n  parser.expect('(');\n  node.params = parseFormalParameters(parser);\n  parser.expect(')');\n  node.body = parseBlockStatement(parser);\n  return node;\n};\n\nexport const parseIfStatement = parser => {\n  parser.expect('if');\n  parser.expect('(');\n  const test = parser.expression();\n  parser.expect(')');\n  const consequent = parseStatement(parser);\n  let alternate = null;\n  if (parser.eventually('else')) {\n    alternate = parseStatement(parser);\n  }\n  return {\n    type: 'IfStatement',\n    test,\n    consequent,\n    alternate\n  };\n};\n\nexport const parseBlockStatement = parser => {\n  parser.expect('{');\n  const node = {\n    type: 'BlockStatement',\n    body: parseStatementList(parser)\n  };\n  parser.expect('}');\n  return node;\n};\n\nexport const parseExpressionStatement = parser => {\n  const expression = parser.expression();\n  return {\n    type: 'ExpressionStatement',\n    expression: expression\n  };\n};\n\nexport const parseEmptyStatement = nodeTypeDecorator('EmptyStatement')\n(parser => {\n  parser.expect(';');\n  return {};\n});\n\nexport const parseDebuggerStatement = nodeTypeDecorator('DebuggerStatement')\n(parser => {\n  parser.expect('debugger');\n  return {};\n});\n\nexport const parseReturnStatement = nodeTypeDecorator('ReturnStatement')\n(parser => {\n  parser.expect('return');\n  return {\n    argument: parser.expression()\n  };\n});\n\nexport const parseBreakStatement = nodeTypeDecorator('BreakStatement')\n(parser => {\n  parser.expect('break');\n  return {\n    argument: parser.expression(20)\n  }\n});\n\nexport const parseContinueStatement = parser => {\n  parser.expect('continue');\n  return {\n    type: 'ContinueStatement',\n    argument: parser.expression(20)\n  };\n};\n\nexport const parseWithStatement = parser => {\n  parser.expect('with');\n  parser.expect('(');\n  const object = parser.expression();\n  parser.expect(')');\n  return {\n    type: 'WithStatement',\n    object,\n    body: parseStatement(parser)\n  };\n};\n\nexport const parseSwitchStatement = parser => {\n  parser.expect('switch');\n  parser.expect('(');\n  const discriminant = parser.expression();\n  parser.expect(')');\n  parser.expect('{');\n  const cases = parseSwitchCases(parser);\n  parser.expect('}');\n  return {\n    type: 'SwitchStatement',\n    discriminant,\n    cases\n  };\n};\n\nexport const parseSwitchCases = (parser, cases = []) => {\n  const {value: nextToken} = parser.lookAhead();\n  if (nextToken !== parser.get('case') && nextToken !== parser.get('default')) {\n    return cases;\n  }\n  parser.eat();\n  cases.push(parseSwitchCase(parser, nextToken));\n  return parseSwitchCases(parser, cases);\n};\n\nexport const parseSwitchCase = (parser, nextToken) => {\n  const {type} = nextToken;\n  const node = {\n    type: 'SwitchCase',\n    test: type === parser.get('case') ? parser.expression() : null\n  };\n  parser.expect(':');\n  node.consequent = parseStatementList(parser, ['}', 'case', 'default']);\n  return node;\n};\n\nexport const parseThrowStatement = parser => {\n  parser.expect('throw');\n  const node = {\n    type: 'ThrowStatement',\n    expression: parser.expression()\n  };\n  return node;\n};\n\nexport const parseTryStatement = parser => {\n  parser.expect('try');\n  const node = {type: 'TryStatement', block: parseBlockStatement(parser), handler: null, finalizer: null};\n  if (parser.eventually('catch')) {\n    const handler = {type: 'CatchClause'};\n    parser.expect('(');\n    handler.param = parser.expression();\n    parser.expect(')');\n    handler.body = parseBlockStatement(parser);\n    node.handler = handler;\n  }\n  if (parser.eventually('finally')) {\n    node.finalizer = parseBlockStatement(parser);\n  }\n  return node;\n};\n\nexport const parseWhileStatement = parser => {\n  parser.expect('while');\n  parser.expect('(');\n  const node = {\n    type: 'WhileStatement',\n    test: parser.expression()\n  };\n  parser.expect(')');\n  node.body = parseStatement(parser);\n  return node;\n};\n\nexport const parseDoWhileStatement = parser => {\n  parser.expect('do');\n  const node = {\n    type: 'DoWhileStatement',\n    body: parseStatement(parser)\n  };\n  parser.expect('while');\n  parser.expect('(');\n  node.test = parser.expression();\n  parser.expect(')');\n  return node;\n};\n\n//todo\nexport const parseBindingIdentifierOrPattern = parser => {\n  return parser.expression(20);\n};\n\nexport const parseVariableDeclarators = (parser, declarators = []) => {\n  const id = parseBindingIdentifierOrPattern(parser);\n  let {value: nextToken} = parser.lookAhead();\n  let init = null;\n  const node = {\n    type: 'VariableDeclarator',\n    id: id\n  };\n\n  const comma = parser.get(',');\n  if (parser.eventually('=')) {\n    init = parser.expression(parser.getInfixPrecedence(comma));\n    nextToken = parser.lookAhead().value;\n  }\n\n  node.init = init;\n\n  declarators.push(node);\n\n  if (nextToken !== comma) {\n    return declarators;\n  }\n\n  parser.eat();\n\n  return parseVariableDeclarators(parser, declarators);\n};\n\nexport const parseVariableStatement = parser => {\n  parser.expect('var');\n  return {\n    type: 'VariableDeclaration',\n    kind: 'var',\n    declarations: parseVariableDeclarators(parser)\n  };\n};\n\nconst getForDerivation = parser => {\n  const {value: nextToken} = parser.lookAhead();\n  switch (nextToken.type) {\n    case parser.get('in'):\n      return asForIn;\n    case parser.get('of'):\n      return asForOf;\n    default:\n      return asFor;\n  }\n};\nconst asForIn = (parser, left) => {\n  parser.expect('in');\n  const n = {\n    type: 'ForInStatement',\n    left\n  };\n  n.right = parser.expression();\n  return n;\n};\nconst asFor = (parser, init) => {\n  parser.expect(';');\n  const n = {\n    type: 'ForStatement',\n    init,\n    test: parser.expression()\n  };\n  parser.expect(';');\n  n.update = parser.expression();\n  return n;\n};\n\n//todo\nconst asForOf = (parser, init) => {\n  parser.expect('of');\n  return {};\n};\n\nexport const parseForStatement = parser => {\n  parser.expect('for');\n  parser.expect('(');\n  const {value: token} = parser.lookAhead();\n  let startExpression, node;\n  if (token === parser.get('var')) {\n    startExpression = parseVariableStatement(parser);\n  } else {\n    startExpression = parser.expression(-1, [parser.get('in'), parser.get('of')]);\n  }\n  const derivation = getForDerivation(parser);\n  node = derivation(parser, startExpression);\n  parser.expect(')');\n  node.body = parseStatement(parser);\n  return node;\n};\n\nexport const parseLabeledStatement = parser => {\n  const node = {\n    type: 'LabeledStatement',\n    label: parser.expression(20)\n  };\n  parser.expect(':');\n  node.body = parseStatement(parser);\n  return node;\n};\n\n\n\n","import {categories} from \"../../tokenizer/src/tokens\";\nimport {parseBindingIdentifierOrPattern, parseBlockStatement, parseFormalParameters} from \"./statements\";\n\n//prefix\nconst asValue = (type, key) => (parser) => {\n  const {value: token} = parser.next();\n  const node = {type};\n  if (key) {\n    node[key] = token.value;\n  }\n  return node;\n};\nconst asUnaryExpression = (type) => (parser) => {\n  const {value: token} = parser.next();\n  return {\n    type,\n    operator: token.value,\n    argument: parser.expression(parser.getPrefixPrecedence(token)),\n    prefix: true\n  };\n};\nexport const parseGroupExpression = (parser) => {\n  parser.expect('(');\n  const exp = parser.expression();\n  parser.expect(')');\n  return exp;\n};\nexport const parseUnaryExpression = asUnaryExpression('UnaryExpression', 'operator');\nexport const parseThisExpression = asValue('ThisExpression');\nexport const parseLiteralExpression = asValue('Literal', 'value');\nexport const parseIdentifierExpression = asValue('Identifier', 'name');\nexport const parseRegularExpressionLiteral = parser => {\n  const {value: regexp} = parser.next();\n  return {\n    type: 'Literal',\n    value: regexp.value,\n    regex: {\n      pattern: regexp.value.source,\n      flags: regexp.value.flags\n    }\n  }\n};\nexport const parseUpdateExpressionAsPrefix = asUnaryExpression('UpdateExpression');\nexport const parseFunctionExpression = (parser) => {\n  parser.expect('function');\n  const node = {\n    type: 'FunctionExpression',\n    id: null,\n    async: false,\n    generator: false\n  };\n  const {value: nextToken} = parser.lookAhead();\n  if (nextToken !== parser.get('(')) {\n    node.id = parseBindingIdentifierOrPattern(parser);\n  }\n  parser.expect('(');\n  node.params = parseFormalParameters(parser);\n  parser.expect(')');\n  node.body = parseBlockStatement(parser);\n  return node;\n};\nexport const parseNewExpression = parser => {\n  const {value: newToken} = parser.expect('new');\n  const callee = parser.expression(parser.getPrefixPrecedence(newToken));\n  return {\n    type: 'NewExpression',\n    callee: callee.callee ? callee.callee : callee,\n    arguments: callee.arguments ? callee.arguments : []\n  };\n};\n\n//Arrays literals\nconst parseArrayElements = (parser, elements = []) => {\n  const {value: token} = parser.lookAhead();\n  if (token === parser.get(']')) {\n    return elements;\n  }\n  const comma = parser.get(',');\n  elements.push(parser.expression(parser.getInfixPrecedence(comma)));\n  const {value: nextToken} = parser.lookAhead();\n  if (nextToken === comma) {\n    parser.eat();\n  }\n  return parseArrayElements(parser, elements);\n};\nexport const parseArrayLiteralExpression = (parser) => {\n  parser.expect('[');\n  const node = {\n    type: 'ArrayExpression',\n    elements: parseArrayElements(parser)\n  };\n  parser.expect(']');\n  return node;\n};\n\nconst parsePropertyList = (parser, properties = []) => {\n  const {value: nextToken} = parser.lookAhead();\n  if (nextToken === parser.get('}')) {\n    return properties;\n  }\n  if (nextToken !== parser.get(',')) {\n    properties.push(parseObjectPropertyExpression(parser));\n  } else {\n    parser.eat();\n  }\n  return parsePropertyList(parser, properties);\n};\nconst isPropertyName = (parser, token) => token === parser.get('[') || token.type === categories.Identifier || token.type === categories.NumericLiteral || token.type === categories.StringLiteral || token.isReserved === true;\nexport const parseObjectPropertyExpression = parser => {\n  const {value: nextToken} = parser.lookAhead();\n  let key;\n  let kind = 'init';\n  let value = null;\n  let computed = false;\n  let shorthand = false;\n  let method = false;\n  if (isPropertyName(parser, nextToken)) {\n    if (parser.eventually('[')) {\n      computed = true;\n      key = parser.expression();\n      parser.expect(']');\n    } else {\n      key = parser.expression(20)\n    }\n    parser.expect(':');\n    value = parser.expression(parser.getInfixPrecedence(parser.get(',')))\n  }\n\n  return {\n    type: 'Property',\n    key,\n    value,\n    kind,\n    computed,\n    method,\n    shorthand\n  };\n};\nexport const parseObjectLiteralExpression = (parser) => {\n  parser.expect('{');\n  const node = {\n    type: 'ObjectExpression',\n    properties: parsePropertyList(parser)\n  };\n  parser.expect('}');\n  return node;\n};\n\n//infix\nconst asBinaryExpression = type => (parser, left, operator) => {\n  return {\n    type,\n    left,\n    right: parser.expression(parser.getInfixPrecedence(operator)),\n    operator: operator.value\n  };\n};\nconst parseArguments = (parser, expressions = []) => {\n  const {value: parsableValue} = parser.lookAhead();\n  const comma = parser.get(',');\n\n  if (parsableValue === parser.get(')')) {\n    return expressions;\n  }\n\n  expressions.push(parser.expression(parser.getInfixPrecedence(comma)));\n  const {value: lookAhead} = parser.lookAhead();\n\n  if (lookAhead !== comma) {\n    return expressions;\n  }\n  parser.eat();\n  return parseArguments(parser, expressions);\n};\nexport const parseAssignmentExpression = asBinaryExpression('AssignmentExpression');\nexport const parseBinaryExpression = asBinaryExpression('BinaryExpression');\nexport const parseLogicalExpression = asBinaryExpression('LogicalExpression');\nexport const parseMemberAccessExpression = (parser, left, operator) => {\n  const computed = operator === parser.get('[');\n  const node = {\n    type: 'MemberExpression',\n    object: left,\n    computed: computed,\n    property: computed ? parser.expression() : parseIdentifierExpression(parser)\n  };\n  if (computed) {\n    parser.expect(']');\n  }\n  return node;\n};\nexport const parseUpdateExpression = (parser, left, operator) => {\n  return {\n    type: 'UpdateExpression',\n    argument: left,\n    operator: operator.value,\n    prefix: false\n  };\n};\nexport const parseConditionalExpression = (parser, test) => {\n  const node = {\n    type: 'ConditionalExpression',\n    test\n  };\n  const commaPrecedence = parser.getInfixPrecedence(parser.get(','));\n  node.consequent = parser.expression(commaPrecedence);\n  parser.expect(':');\n  node.alternate = parser.expression(commaPrecedence);\n  return node;\n};\nexport const parseCallExpression = (parser, callee) => {\n  const node = {\n    type: 'CallExpression',\n    callee,\n    arguments: parseArguments(parser)\n  };\n  parser.expect(')');\n  return node;\n};\n\nexport const parseSequenceExpression = (parser, left) => {\n  let node = left;\n  const comma = parser.get(',');\n  const next = parser.expression(parser.getInfixPrecedence(comma));\n  if (left.type === 'SequenceExpression') {\n    left.expressions.push(next);\n  } else {\n    node = {\n      type: 'SequenceExpression',\n      expressions: [left, next]\n    }\n  }\n  return node;\n};","import {tokenRegistry, categories} from \"../../tokenizer/src/tokens\";\nimport * as expressions from './expressions';\nimport * as statements from './statements';\nimport {withEventualSemiColon} from \"./statements\";\n\nexport const ECMAScriptTokenRegistry = () => {\n  const registry = tokenRegistry();\n\n  /**\n   * EXPRESSIONS\n   */\n\n  const prefixMap = new Map();\n  //unary operators\n  prefixMap.set(registry.get('-'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('+'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('!'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('~'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('typeof'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('void'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('delete'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  //update operators\n  prefixMap.set(registry.get('--'), {parse: expressions.parseUpdateExpressionAsPrefix, precedence: 16});\n  prefixMap.set(registry.get('++'), {parse: expressions.parseUpdateExpressionAsPrefix, precedence: 16});\n  //literals\n  prefixMap.set(categories.StringLiteral, {parse: expressions.parseLiteralExpression, precedence: -1});\n  prefixMap.set(categories.NumericLiteral, {parse: expressions.parseLiteralExpression, precedence: -1});\n  prefixMap.set(categories.RegularExpressionLiteral, {\n    parse: expressions.parseRegularExpressionLiteral,\n    precedence: -1\n  });\n  prefixMap.set(registry.get('null'), {parse: expressions.parseLiteralExpression, precedence: -1});\n  prefixMap.set(registry.get('false'), {parse: expressions.parseLiteralExpression, precedence: -1});\n  prefixMap.set(registry.get('true'), {parse: expressions.parseLiteralExpression, precedence: -1});\n  prefixMap.set(registry.get('['), {parse: expressions.parseArrayLiteralExpression, precedence: -1});\n  prefixMap.set(registry.get('{'), {parse: expressions.parseObjectLiteralExpression, precedence: -1});\n  //identifiers\n  prefixMap.set(registry.get('this'), {parse: expressions.parseThisExpression, precedence: -1});\n  prefixMap.set(categories.Identifier, {parse: expressions.parseIdentifierExpression, precedence: -1});\n  //functions\n  prefixMap.set(registry.get('function'), {parse: expressions.parseFunctionExpression, precedence: -1});\n  prefixMap.set(registry.get('new'), {parse: expressions.parseNewExpression, precedence: 18});\n  //group\n  prefixMap.set(registry.get('('), {parse: expressions.parseGroupExpression, precedence: 20});\n\n\n  const infixMap = new Map();\n  //sequence\n  infixMap.set(registry.get(','), {parse: expressions.parseSequenceExpression, precedence: 0});\n  //conditional\n  infixMap.set(registry.get('?'), {parse: expressions.parseConditionalExpression, precedence: 4});\n  //assignment operators\n  infixMap.set(registry.get('='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('+='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('-='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('*='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('/='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('%='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('<<='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('>>='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('>>>='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('&='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('^='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('|='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  //binary operators\n  infixMap.set(registry.get('=='), {parse: expressions.parseBinaryExpression, precedence: 10});\n  infixMap.set(registry.get('!='), {parse: expressions.parseBinaryExpression, precedence: 10});\n  infixMap.set(registry.get('==='), {parse: expressions.parseBinaryExpression, precedence: 10});\n  infixMap.set(registry.get('!=='), {parse: expressions.parseBinaryExpression, precedence: 10});\n  infixMap.set(registry.get('<'), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('<='), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('>'), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('>='), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('in'), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('instanceof'), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('<<'), {parse: expressions.parseBinaryExpression, precedence: 12});\n  infixMap.set(registry.get('>>'), {parse: expressions.parseBinaryExpression, precedence: 12});\n  infixMap.set(registry.get('>>>'), {parse: expressions.parseBinaryExpression, precedence: 12});\n  infixMap.set(registry.get('+'), {parse: expressions.parseBinaryExpression, precedence: 13});\n  infixMap.set(registry.get('-'), {parse: expressions.parseBinaryExpression, precedence: 13});\n  infixMap.set(registry.get('*'), {parse: expressions.parseBinaryExpression, precedence: 14});\n  infixMap.set(registry.get('/'), {parse: expressions.parseBinaryExpression, precedence: 14});\n  infixMap.set(registry.get('%'), {parse: expressions.parseBinaryExpression, precedence: 14});\n  infixMap.set(registry.get('**'), {parse: expressions.parseBinaryExpression, precedence: 15});\n  infixMap.set(registry.get('|'), {parse: expressions.parseBinaryExpression, precedence: 7});\n  infixMap.set(registry.get('^'), {parse: expressions.parseBinaryExpression, precedence: 8});\n  infixMap.set(registry.get('&'), {parse: expressions.parseBinaryExpression, precedence: 9});\n  //member access operator\n  infixMap.set(registry.get('.'), {parse: expressions.parseMemberAccessExpression, precedence: 19});\n  infixMap.set(registry.get('['), {parse: expressions.parseMemberAccessExpression, precedence: 19});\n  //logical operators\n  infixMap.set(registry.get('||'), {parse: expressions.parseLogicalExpression, precedence: 5});\n  infixMap.set(registry.get('&&'), {parse: expressions.parseLogicalExpression, precedence: 6});\n  //update operators\n  infixMap.set(registry.get('++'), {parse: expressions.parseUpdateExpression, precedence: 17});\n  infixMap.set(registry.get('--'), {parse: expressions.parseUpdateExpression, precedence: 17});\n  //call\n  infixMap.set(registry.get('('), {parse: expressions.parseCallExpression, precedence: 19});\n\n  /**\n   * STATEMENTS\n   */\n\n  const statementsMap = new Map();\n  statementsMap.set(registry.get('if'),statements.parseIfStatement);\n  statementsMap.set(registry.get(';'),statements.parseEmptyStatement);\n  statementsMap.set(registry.get('{'),statements.parseBlockStatement);\n  statementsMap.set(registry.get('for'),statements.parseForStatement);\n  statementsMap.set(registry.get('var'),withEventualSemiColon(statements.parseVariableStatement));\n  statementsMap.set(registry.get('function'),statements.parseFunctionDeclaration);\n  statementsMap.set(registry.get('return'),withEventualSemiColon(statements.parseReturnStatement));\n  statementsMap.set(registry.get('break'),withEventualSemiColon(statements.parseBreakStatement));\n  statementsMap.set(registry.get('continue'),withEventualSemiColon(statements.parseContinueStatement));\n  statementsMap.set(registry.get('throw'),withEventualSemiColon(statements.parseThrowStatement));\n  statementsMap.set(registry.get('while'),withEventualSemiColon(statements.parseWhileStatement));\n  statementsMap.set(registry.get('do'),withEventualSemiColon(statements.parseDoWhileStatement));\n  statementsMap.set(registry.get('try'),statements.parseTryStatement);\n  statementsMap.set(registry.get('switch'),statements.parseSwitchStatement);\n  statementsMap.set(registry.get('with'),statements.parseWithStatement);\n  statementsMap.set(registry.get('debugger'),withEventualSemiColon(statements.parseDebuggerStatement));\n  statementsMap.set(categories.Identifier,statements.parseExpressionOrLabeledStatement);\n\n  return Object.assign(registry, {\n    getInfix (token) {\n      return infixMap.get(token.type);\n    },\n    getPrefix (token) {\n      return prefixMap.get(token.type);\n    },\n    getStatement (token) {\n      return statementsMap.get(token.type);\n    },\n    hasPrefix (token) {\n      return prefixMap.has(token.type);\n    },\n    hasInfix (token) {\n      return infixMap.has(token.type)\n    },\n    hasStatement (token) {\n      return statementsMap.has(token.type);\n    }\n  });\n};\n\n\nexport default ECMAScriptTokenRegistry();","import {lazyMapWith, lazyFilterWith} from \"../../tokenizer/src/utils\"\nimport {lexemes} from \"../../tokenizer/src/index\";\nimport {default as ECMAScriptTokens} from './tokens';\nimport {default as ECMAScriptScanner} from \"../../tokenizer/src/scanners\"\n\n//forward method of arrity one (more efficient than using spread operator on arguments)\nexport const forwardArrityOne = (receiver, stream, ...methods) => {\n  for (let m of methods) {\n    receiver[m] = (arg) => stream[m](arg);\n  }\n  return receiver;\n};\n\n//a buffered stream token\nconst tokenStream = ({scanner, tokenRegistry, filter, evaluate}) => {\n  const filterFunc = lazyFilterWith(filter || (t => t.type >= 4));\n  const map = lazyMapWith(evaluate || tokenRegistry.evaluate);\n  const filterMap = it => map(filterFunc(it));\n\n  //as generator(only consumed once)\n  return (code) => {\n\n    const stream = lexemes(code, scanner);\n    const iterator = filterMap(stream)[Symbol.iterator]();\n    const buffer = [];\n\n    return forwardArrityOne({\n      [Symbol.iterator] () {\n        return this;\n      },\n      lookAhead (offset = 0) {\n        if (buffer.length > offset) {\n          return buffer[offset]\n        }\n        buffer.push(iterator.next());\n        return this.lookAhead(offset);\n      },\n      eventually (expected) {\n        const {value: token, done} = this.lookAhead();\n        if (!done && expected === token) {\n          this.eat();\n          return true;\n        }\n        return false;\n      },\n      expect (expected) {\n        const nextToken = this.next();\n        if (expected !== nextToken.value) {\n          throw new Error(`Unexpected token: expected \"${expected.rawValue}\" but got \"${nextToken.value.rawValue}\"`);\n        }\n        return nextToken;\n      },\n      next () {\n        const nextToken = buffer.length ? buffer.shift() : iterator.next();\n        // console.log(nextToken.value);\n        return nextToken;\n      },\n      eat (number = 1) {\n        const n = this.next();\n        number -= 1;\n        return number < 1 ? n : this.eat(number);\n      }\n    }, stream, 'allowRegexp', 'disallowRegexp');\n  };\n};\n\nexport default tokenStream({scanner: ECMAScriptScanner, tokenRegistry: ECMAScriptTokens});","import {default as stream, forwardArrityOne} from './source';\nimport {default as defaultRegistry} from './tokens';\nimport {parseStatementList} from \"./statements\";\n\nexport const parserFactory = (tokens = defaultRegistry) => {\n\n  const getInfixPrecedence = operator => tokens.hasInfix(operator) ? tokens.getInfix(operator).precedence : -1;\n  const getPrefixPrecedence = operator => tokens.hasPrefix(operator) ? tokens.getPrefix(operator).precedence : -1;\n\n  const parseInfix = (parser, left, precedence, exits) => {\n    parser.disallowRegexp();\n    const {value: operator} = parser.lookAhead();\n    if (!operator || precedence >= getInfixPrecedence(operator) || exits.includes(operator.type)) {\n      return left;\n    }\n    parser.eat();\n    parser.allowRegexp();\n    const nextLeft = tokens.getInfix(operator).parse(parser, left, operator);\n    return parseInfix(parser, nextLeft, precedence, exits);\n  };\n\n  return code => {\n\n    const tokenStream = stream(code);\n\n    const parser = Object.assign(forwardArrityOne({\n        expect: symbol => tokenStream.expect(tokens.get(symbol)), //more convenient to have it from the symbol\n        eventually: symbol => tokenStream.eventually(tokens.get(symbol)), //more convenient to have it from the symbol\n        getInfixPrecedence,\n        getPrefixPrecedence,\n        expression (precedence = -1, exits = []) {\n          parser.allowRegexp();\n          const {value: token} = parser.lookAhead();\n          if (!tokens.hasPrefix(token)) {\n            if (token.isReserved === true) { // reserved words are allowed as identifier names (such in member expressions)\n              parser.eat();\n              return {type: 'Identifier', name: token.value};\n            }\n            return null;\n          }\n          const left = tokens.getPrefix(token).parse(parser);\n          return parseInfix(parser, left, precedence, exits);\n        },\n        program () {\n          return {\n            type: 'Program',\n            body: parseStatementList(parser)\n          };\n        },\n        module () {\n          throw new Error('not implemented');\n        },\n      }, tokenStream, 'lookAhead', 'next', 'eat', 'allowRegexp', 'disallowRegexp'),\n      tokens);\n\n    return parser;\n  };\n\n};\n\nexport const parseExpression = (expression) => {\n  const parse = parserFactory();\n  return parse(expression).expression();\n};\n\nexport const parseProgram = program => {\n  const parse = parserFactory();\n  return parse(program).program();\n};\n","import {parseProgram} from \"../src/index\";\n\n// const fs = require('fs');\n// const path = require('path');\n// const utils = require('util');\n\n\n// const programPath = path.resolve(__dirname, '../fixtures/jquery.js');\n// const program = fs.readFileSync(programPath, {encoding: 'utf8'});\n\n// import {tokenizer} from 'acorn';\n// const program = `new foo() + bar`;\n// const ast = acorn.parse(program)\n\n// const ast = parseProgram(program);\n// console.log(utils.inspect(ast, {depth: null}));\n\n\n/* browser  */\n(async function  () {\n   const resp = await fetch('../fixtures/jquery.js');\n   const text = await resp.text();\n\n   const ast = parseProgram(text);\n   // console.log(ast);\n})();\n/* end browser */\n"],"names":["chars.SINGLE_LINE_COMMENT_START","chars.CHAR_STAR","chars.CHAR_SLASH","chars.MULTI_LINE_COMMENT_START","chars.CHAR_BACKSLASH","chars.CHAR_SINGLE_QUOTE","chars.CHAR_DOUBLE_QUOTE","chars.SPREAD","chars.CHAR_DOT","chars.CHAR_LEFT_BRACKET","chars.CHAR_RIGHT_BRACKET","scanner","tokenRegistry","expressions.parseUnaryExpression","expressions.parseUpdateExpressionAsPrefix","expressions.parseLiteralExpression","expressions.parseRegularExpressionLiteral","expressions.parseArrayLiteralExpression","expressions.parseObjectLiteralExpression","expressions.parseThisExpression","expressions.parseIdentifierExpression","expressions.parseFunctionExpression","expressions.parseNewExpression","expressions.parseGroupExpression","expressions.parseSequenceExpression","expressions.parseConditionalExpression","expressions.parseAssignmentExpression","expressions.parseBinaryExpression","expressions.parseMemberAccessExpression","expressions.parseLogicalExpression","expressions.parseUpdateExpression","expressions.parseCallExpression","statements.parseIfStatement","statements.parseEmptyStatement","statements.parseBlockStatement","statements.parseForStatement","statements.parseVariableStatement","statements.parseFunctionDeclaration","statements.parseReturnStatement","statements.parseBreakStatement","statements.parseContinueStatement","statements.parseThrowStatement","statements.parseWhileStatement","statements.parseDoWhileStatement","statements.parseTryStatement","statements.parseSwitchStatement","statements.parseWithStatement","statements.parseDebuggerStatement","statements.parseExpressionOrLabeledStatement","ECMAScriptScanner","defaultRegistry"],"mappings":"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"}