{"version":3,"file":"index.js","sources":["../../../tokenizer/src/utils.js","../../../tokenizer/src/source.js","../../../tokenizer/src/tokens.js","../../../tokenizer/src/chars.js","../../../tokenizer/src/scanners.js","../../../tokenizer/src/index.js","../../src/utils.js","../../src/ast.js","../../src/asAssign.js","../../src/expressions.js","../../src/array.js","../../src/function.js","../../src/object.js","../../src/class.js","../../src/module.js","../../src/statements.js","../../src/tokens.js","../../src/source.js","../../src/index.js","../index.js"],"sourcesContent":["export const lazyMapWith = (fn) => function* (iterator) {\n  for (let i of iterator) {\n    yield fn(i);\n  }\n};\n\nexport const lazyFilterWith = fn => function* (iterator) {\n  for (let i of iterator) {\n    if (fn(i)) {\n      yield i;\n    }\n  }\n};\n\nexport const syntacticFlags = {\n  allowRegexp: 1 << 0,\n  allowRightBrace: 1 << 1\n};","//todo put track loc as an option ?\nexport const sourceStream = (code) => {\n  const lineTerminatorRegexp = /[\\u000a\\u000d\\u2028\\u2029]/g;\n  let index = 0;\n  let col = 0;\n  let line = 1;\n\n  const test = (regexp) => nextStretch().search(regexp) === 0;\n  const nextSubStr = (count = 1) => code.substr(index, count);\n  const seeNextAt = (offset = 0) => code[index + offset];\n  const nextStretch = () => nextSubStr(3); //we need three chars to be really sure of the current lexical production (0x3...)\n  const loc = () => ({col, line});\n\n  const advance = (number = 1) => {\n    let lastLineIndex = 0;\n    // console.log(`col: ${col}`);\n    // console.log(`line: ${line}`);\n    const stretch = nextSubStr(number);\n    // console.log(`symbols: ${stretch}`);\n    // console.log('-------')\n    while (lineTerminatorRegexp.test(stretch)) {\n      line += 1;\n      col = 0;\n      lastLineIndex = lineTerminatorRegexp.lastIndex;\n    }\n    col += (number - lastLineIndex);\n    index += number;\n  };\n\n  const stream = {\n    loc,\n    test,\n    nextSubStr,\n    seeNextAt,\n    //advance stream\n    match (regexp) {\n      regexp.lastIndex = index;\n      const [rawValue] = regexp.exec(code);\n      advance(rawValue.length);\n      return rawValue;\n    },\n    //advance stream\n    read (length) {\n      const s = this.nextSubStr(length);\n      advance(length);\n      return s;\n    }\n  };\n\n  Object.defineProperty(stream, 'done', {\n    get () {\n      return code[index] === void 0;\n    }\n  });\n\n  return stream;\n};","export const categories = {\n  WhiteSpace: 0,\n  LineTerminator: 1,\n  SingleLineComment: 2,\n  MultiLineComment: 3,\n  Punctuator: 4,\n  Identifier: 5,\n  NumericLiteral: 6,\n  StringLiteral: 7,\n  RegularExpressionLiteral: 8,\n  Template: 9,\n  TemplateHead: 10,\n  TemplateMiddle: 11,\n  TemplateTail: 12\n};\n\n//defined as keywords\nconst keywords = 'await break case catch class const continue debugger default delete do else export extends finally for function if import in instanceof new return super switch this throw try typeof var void while with yield'.split(' ');\nconst futureReservedKeyword = ['enum'];\nconst reservedKeywords = keywords.concat(futureReservedKeyword, ['null', 'true', 'false']);\n\n//defined as punctuators\nexport const puncutators = `{ ( ) [ ] . ... ; , < > <= >= == != === !== + - * % ** ++ -- << >> >>> & | ^ ! ~ && || ? : = += -= *= %= **= <<= >>= >>>= &= |= ^= => / /= }`.split(' ');\n\nexport const allowRegexpAfter = 'case delete do else in instanceof new return throw typeof void { ( [ . ; , < > <= >= == != === !== + - * << >> >>> & | ^ ! ~ && || ? : = += -= *= %= <<= >>= >>>= &= |= ^= /='.split(' ');\n\nconst createLanguageToken = (symbol, value) => {\n  return Object.freeze(Object.assign(Object.create(null), {\n    type: puncutators.includes(symbol) ? categories.Punctuator : categories.Identifier,\n    value: value !== void  0 ? value : symbol,\n    rawValue: symbol\n  }));\n};\n\n//create a token table\nexport const tokenRegistry = () => {\n  const ecmaScriptTokens = puncutators.concat(keywords, futureReservedKeyword)\n    .map(symbol => ([symbol, createLanguageToken(symbol)]));\n  ecmaScriptTokens.push(['null', createLanguageToken('null', null)]);\n  ecmaScriptTokens.push(['true', createLanguageToken('true', true)]);\n  ecmaScriptTokens.push(['false', createLanguageToken('false', false)]);\n\n  //todo in some context the next tokens can be considered as identifier or identifierName\n  ecmaScriptTokens.push(['of', createLanguageToken('of')]);\n  ecmaScriptTokens.push(['let', createLanguageToken('let')]);\n  ecmaScriptTokens.push(['get', createLanguageToken('get')]);\n  ecmaScriptTokens.push(['set', createLanguageToken('set')]);\n  ecmaScriptTokens.push(['static', createLanguageToken('static')]);\n  ecmaScriptTokens.push(['as', createLanguageToken('as')]);\n  ecmaScriptTokens.push(['from', createLanguageToken('from')]);\n\n  const tokenMap = new Map(ecmaScriptTokens);\n\n  return {\n    get (key) {\n      return tokenMap.get(key)\n    },\n    isReserved(symbol){\n      return reservedKeywords.includes(symbol)\n    },\n    evaluate (lexeme) {\n      if (!tokenMap.has(lexeme.rawValue)) {\n        switch (lexeme.type) {\n          case categories.StringLiteral:\n            return Object.assign(lexeme, {\n              value: lexeme.rawValue.substr(1, lexeme.rawValue.length - 2)\n            });\n          case categories.NumericLiteral:\n            return Object.assign(lexeme, {value: Number(lexeme.rawValue)});\n          case categories.RegularExpressionLiteral:\n            return Object.assign(lexeme, {value: new RegExp(lexeme.pattern, lexeme.flags)});\n          default:\n            return Object.assign(lexeme, {value: lexeme.rawValue});\n        }\n      }\n      return tokenMap.get(lexeme.rawValue);\n    },\n    addToken () {\n      throw new Error('not implemented');\n    }\n  }\n};\n\nexport default tokenRegistry();","export const CHAR_STAR = '*';\nexport const CHAR_SLASH = '/';\nexport const MULTI_LINE_COMMENT_START = '/*';\nexport const SINGLE_LINE_COMMENT_START = '//';\nexport const CHAR_BACKSLASH = '\\\\';\nexport const CHAR_SINGLE_QUOTE = \"'\";\nexport const CHAR_DOUBLE_QUOTE = '\"';\nexport const CHAR_LEFT_BRACKET = '[';\nexport const CHAR_RIGHT_BRACKET = ']';\nexport const CHAR_DOT = '.';\nexport const SPREAD = '...';\nexport const CHAR_TEMPLATE_QUOTE = '`';\nexport const CHAR_DOLLAR = '$';\nexport const CHAR_BRACE_OPEN = '{';\nexport const CHAR_BRACE_CLOSE = '}';","import {\n  categories,\n  puncutators\n} from \"./tokens\";\nimport * as chars from \"./chars\";\nimport {syntacticFlags} from \"./utils\";\n\nconst lexemeFromRegExp = (regExp, category) => sourceStream => ({type: category, rawValue: sourceStream.match(regExp)});\nconst testFromRegExp = regExp => sourceStream => sourceStream.test(regExp);\nconst productionFromRegexp = ({test, lexeme, category}) => () => {\n  //we create regexp dynamically so they are not global to every instance of the scanner\n  const testRegexp = new RegExp(test);\n  const lexemeRegexp = new RegExp(lexeme, 'y');\n  return {\n    test: testFromRegExp(testRegexp),\n    lexeme: lexemeFromRegExp(lexemeRegexp, category)\n  }\n};\n\nexport const numbers = productionFromRegexp({\n  category: categories.NumericLiteral,\n  test: `^(?:[1-9]|\\\\.\\\\d|0[1-9]?|0[xX][0-9a-fA-F]|0[bB][01]|0[oO][0-7])`,\n  lexeme: `0[xX][0-9a-fA-F]+|0[bB][01]+|0[oO][0-7]+|(?:(?:\\\\d+(?:\\\\.\\\\d*)?|\\\\.\\\\d+)(?:[eE][-+]?\\\\d+)?)`\n});\n\nexport const identifiers = productionFromRegexp({\n  category: categories.Identifier,\n  test: `^[$_a-zA-Z]`,\n  lexeme: `[$_a-zA-Z][$\\\\w]*`\n});\n\nexport const whiteSpace = productionFromRegexp({\n  category: categories.WhiteSpace,\n  test: `^(?:[\\\\u0009\\\\u000b\\\\u000c\\\\u0020\\\\u00a0\\\\ufeff])`,\n  lexeme: `[\\\\u0009\\\\u000b\\\\u000c\\\\u0020\\\\u00a0\\\\ufeff]+`\n});\n\nexport const lineTerminator = productionFromRegexp({\n  category: categories.LineTerminator,\n  test: `^(?:[\\\\u000a\\\\u000d\\\\u2028\\\\u2029])`,\n  lexeme: `[\\\\u000a\\\\u000d\\\\u2028\\\\u2029]+`\n});\n\nexport const singleLineComment = () => {\n  const lexemeRegExp = /\\/\\/.*/y;\n  return {\n    test: (sourceStream) => sourceStream.nextSubStr(2) === chars.SINGLE_LINE_COMMENT_START,\n    lexeme: lexemeFromRegExp(lexemeRegExp, categories.SingleLineComment)\n  };\n};\n\nexport const multiLineComment = () => {\n  const lexeme = (sourceStream, count = 2) => {\n    const next = sourceStream.seeNextAt(count);\n    count++;\n    if (next === chars.CHAR_STAR) {\n      const secondNext = sourceStream.seeNextAt(count);\n      if (secondNext === chars.CHAR_SLASH) {\n        return {\n          type: categories.MultiLineComment,\n          rawValue: sourceStream.read(count + 1)\n        }\n      }\n    }\n    return lexeme(sourceStream, count);\n  };\n  return {\n    test (sourceStream) {\n      return sourceStream.nextSubStr(2) === chars.MULTI_LINE_COMMENT_START;\n    },\n    lexeme\n  };\n};\n\nconst fromQuote = quote => {\n  const fn = (sourceStream, count = 1) => {\n    const next = sourceStream.seeNextAt(count);\n    count += 1;\n    if (next === quote) {\n      return {\n        type: categories.StringLiteral,\n        rawValue: sourceStream.read(count)\n      };\n    }\n    if (next === chars.CHAR_BACKSLASH) {\n      count += 1;\n    }\n    return fn(sourceStream, count);\n  };\n  return fn;\n};\nexport const stringLiteral = () => {\n  const singleQuote = fromQuote(chars.CHAR_SINGLE_QUOTE);\n  const doubleQuote = fromQuote(chars.CHAR_DOUBLE_QUOTE);\n  return {\n    test (sourceStream) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_SINGLE_QUOTE || next === chars.CHAR_DOUBLE_QUOTE;\n    },\n    lexeme (sourceStream) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_DOUBLE_QUOTE ? doubleQuote(sourceStream) : singleQuote(sourceStream);\n    }\n  };\n};\n\nexport const punctuators = (punctuatorList = puncutators) => {\n\n  const sizeOnePunctuatorList = punctuatorList.filter(p => p.length === 1);\n  const sizeTwoPunctuatorList = punctuatorList.filter(p => p.length === 2);\n  const sizeThreePunctuatorList = punctuatorList.filter(p => p.length === 3);\n  const sizeFourPunctuatorList = punctuatorList.filter(p => p.length === 4);\n\n  //micro optimization (this function will run often)\n  const isInPunctuatorList = (str) => {\n    switch (str.length) {\n      case 2:\n        return sizeTwoPunctuatorList.includes(str);\n      case 3:\n        return sizeThreePunctuatorList.includes(str);\n      case 4:\n        return sizeFourPunctuatorList.includes(str);\n      default:\n        return false;\n    }\n  };\n  const lexeme = (sourceStream, count = 1) => {\n    const nextStretch = sourceStream.nextSubStr(count + 1);\n    if (!isInPunctuatorList(nextStretch) || nextStretch.length !== count + 1 /*End of file */) {\n      return {\n        type: categories.Punctuator,\n        rawValue: sourceStream.read(count)\n      };\n    }\n    return lexeme(sourceStream, count + 1);\n  };\n  const lexemeFromDot = sourceStream => ({\n    type: categories.Punctuator,\n    rawValue: (sourceStream.nextSubStr(3) === chars.SPREAD) ? sourceStream.read(3) : sourceStream.read(1)\n  });\n  return {\n    test (sourceStream, context) {\n      const next = sourceStream.seeNextAt();\n      switch (next) {\n        case chars.CHAR_SLASH:\n          return ~context & syntacticFlags.allowRegexp;\n        case chars.CHAR_BRACE_CLOSE:\n          return context & syntacticFlags.allowRightBrace;\n        default:\n          return sizeOnePunctuatorList.includes(next);\n      }\n    },\n    lexeme: sourceStream => sourceStream.seeNextAt() === chars.CHAR_DOT ? lexemeFromDot(sourceStream) : lexeme(sourceStream)\n  };\n};\n\nconst scanRegExpBody = (sourceStream, count = 1) => {\n  const next = sourceStream.seeNextAt(count);\n  count += 1;\n  switch (next) {\n    case chars.CHAR_SLASH:\n      return count;\n    case chars.CHAR_LEFT_BRACKET: {\n      // slash are \"escaped\" in a regexp class\n      count = scanRegExpClass(sourceStream, count);//+1\n      break;\n    }\n    case chars.CHAR_BACKSLASH: {\n      count += 1;\n      break;\n    }\n  }\n  return scanRegExpBody(sourceStream, count);\n};\nconst scanRegExpClass = (sourceStream, count) => {\n  const next = sourceStream.seeNextAt(count);\n  count += 1;\n  switch (next) {\n    case chars.CHAR_RIGHT_BRACKET:\n      return count;\n    case chars.CHAR_BACKSLASH:\n      count += 1\n  }\n  return scanRegExpClass(sourceStream, count);\n};\n\nconst identifierPart = /[$\\w]/;\nconst scanRegExpFlags = (sourceStream, count) => {\n  const next = sourceStream.seeNextAt(count);\n  if (!next || !identifierPart.test(next)) {\n    return count;\n  }\n  return scanRegExpFlags(sourceStream, count + 1);\n};\n\nexport const regularExpression = () => {\n  return {\n    test (sourceStream, context) {\n      const next = sourceStream.seeNextAt();\n      return (context & syntacticFlags.allowRegexp) && next === chars.CHAR_SLASH;\n    },\n    lexeme (sourceStream) {\n      const body = scanRegExpBody(sourceStream);\n      const withFlags = scanRegExpFlags(sourceStream, body);\n      const rawValue = sourceStream.read(withFlags);\n      return {\n        type: categories.RegularExpressionLiteral,\n        rawValue,\n        pattern: rawValue.substr(1, body - 2),\n        flags: rawValue.substr(body, withFlags - body)\n      };\n    }\n  };\n};\n\nconst templateOrPart = (onExit = categories.Template, onFollow = categories.TemplateHead) => {\n  const fn = (sourceStream, count = 1) => {\n    const next = sourceStream.seeNextAt(count);\n    count += 1;\n    if (next === chars.CHAR_TEMPLATE_QUOTE) {\n      return {\n        type: onExit,\n        rawValue: sourceStream.read(count)\n      };\n    }\n\n    if (next === chars.CHAR_DOLLAR && sourceStream.seeNextAt(count) === chars.CHAR_BRACE_OPEN) {\n      return {\n        type: onFollow,\n        rawValue: sourceStream.read(count + 1)\n      };\n    }\n\n    if (next === chars.CHAR_BACKSLASH) {\n      count += 1;\n    }\n\n    return fn(sourceStream, count);\n\n  };\n  return fn;\n};\nconst headOrTemplate = templateOrPart();\nexport const templateHeadOrLiteral = () => {\n  return {\n    test (sourceStream) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_TEMPLATE_QUOTE;\n    },\n    lexeme (sourceStream) {\n      return headOrTemplate(sourceStream);\n    }\n  };\n};\n\nconst middleOrTail = templateOrPart(categories.TemplateTail, categories.TemplateMiddle);\nexport const templateTailOrMiddle = () => {\n  return {\n    test (sourceStream, context) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_BRACE_CLOSE && (~context & syntacticFlags.allowRightBrace);\n    },\n    lexeme (sourceStream) {\n      return middleOrTail(sourceStream);\n    }\n  }\n};\n\nexport const ECMAScriptLexicalGrammar = [\n  whiteSpace,\n  lineTerminator,\n  numbers,\n  singleLineComment,\n  multiLineComment,\n  punctuators,\n  identifiers,\n  regularExpression,\n  stringLiteral,\n  templateHeadOrLiteral,\n  templateTailOrMiddle\n];\n\nexport const scanner = (lexicalRules = ECMAScriptLexicalGrammar.map(g => g())) => {\n  return (source, context) => {\n    const rule = lexicalRules.find(lr => lr.test(source, context));\n    if (rule === void 0) {\n      throw new Error(`could not understand the symbol ${source.seeNextAt()}`);\n    }\n    return rule.lexeme(source);\n  };\n};\n\nexport default scanner();\n","import {sourceStream} from \"./source\";\nimport {allowRegexpAfter, categories} from \"./tokens\";\nimport {syntacticFlags, lazyFilterWith, lazyMapWith} from \"./utils\";\nimport {default as defaultScanner} from './scanners';\nimport {default as defaultRegistry} from './tokens';\n\n/* Note\n\nwe could greatly improve perf by directly yielding filtered (and evaluated token?) at the scanner level instead of passing every lexeme through a lazy stream combinators pipe chain,\nhowever we would lost the great flexibility we have here !\n\nfor example if we simply ignored white space, line terminators, etc.\nour filter combinator would have to run much less (at least for big files)\n\nbottom line: we value more modularity and flexibility of the system over performance\n\ntodo: later we can give ability to the consumer to configure the scanner to perform better\n\n*/\n\n\n//return an iterable sequence of lexemes (note it can only be consumed once like a generator)\n//The consumer (like a parser) will have to handle the syntactic state and the token evaluation by itself\nexport const lexemes = (code, scanner) => {\n  let context = syntacticFlags.allowRegexp | syntacticFlags.allowRightBrace;\n  let previousContext = context;\n  const source = sourceStream(code);\n  const holdContext = fn => _ => {\n    previousContext = context;\n    fn();\n  };\n  return {\n    * [Symbol.iterator] () {\n      while (true) {\n        if (source.done === true) {\n          return;\n        }\n        yield scanner(source, context);\n      }\n    },\n    restoreContext () {\n      context = previousContext\n    },\n    allowRegexp: holdContext(() => {\n      context |= syntacticFlags.allowRegexp;\n    }),\n    disallowRegexp: holdContext(() => {\n      context &= ~syntacticFlags.allowRegexp;\n    }),\n    allowRightBrace: holdContext(() => { // as punctuator vs template middle/tail\n      context |= syntacticFlags.allowRightBrace;\n    }),\n    disallowRightBrace: holdContext(() => {\n      context &= ~syntacticFlags.allowRightBrace;\n    }),\n    loc () {\n      return source.loc();\n    }\n  }\n};\n\nlet defaultFilter = t => t.type >= 4;\nconst defaultOptions = {\n  scanner: defaultScanner,\n  tokenRegistry: defaultRegistry,\n  evaluate: defaultRegistry.evaluate,\n  filter: defaultFilter\n};\n\n// a standalone tokenizer (ie uses some heuristics based on the last meaningful token to know how to scan a slash)\n// https://stackoverflow.com/questions/5519596/when-parsing-javascript-what-determines-the-meaning-of-a-slash\nexport const tokenize = function* (code, {scanner = defaultScanner, tokenRegistry = defaultRegistry, filter, evaluate} = defaultOptions) {\n  const filterFunc = lazyFilterWith(filter || defaultFilter);\n  const mapFunc = lazyMapWith(evaluate || tokenRegistry.evaluate);\n  const filterMap = iter => mapFunc(filterFunc(iter));\n  const stream = lexemes(code, scanner);\n\n  let substitutionStack = []; //pending braces\n\n  for (let t of filterMap(stream)) {\n    yield t;\n    //meaningful tokens\n    if (Object.is(t.type, t) || t.type >= 4) {\n\n      //heuristic for regexp context\n      if (allowRegexpAfter.includes(t.rawValue)) {\n        stream.allowRegexp();\n      } else {\n        stream.disallowRegexp();\n      }\n\n      //template literal substitution\n      if (t.type === categories.TemplateHead || t.type === categories.TemplateMiddle) {\n        substitutionStack.push(0);\n        stream.disallowRightBrace();\n        stream.allowRegexp();\n      } else if (t.type === categories.TemplateTail) {\n        substitutionStack.pop();\n      }\n\n      //without context we need to backtrack braces\n      if (substitutionStack.length) {\n\n        const lastSubstitutionIndex = substitutionStack.length - 1;\n\n        if (t.rawValue === '{') {\n          substitutionStack[lastSubstitutionIndex] = substitutionStack[lastSubstitutionIndex] + 1;\n          stream.allowRightBrace();\n        }\n\n        if (t.rawValue === '}') {\n          let pending = substitutionStack[lastSubstitutionIndex] = substitutionStack[lastSubstitutionIndex] - 1;\n          if (pending === 0) {\n            stream.disallowRightBrace();\n          }\n        }\n      }\n    }\n  }\n};","export const withEventualSemiColon = (fn) => parser => {\n  const node = fn(parser);\n  parser.eventually(';');\n  return node;\n};\nexport const composeArityTwo = (factory, fn) => (a, b) => factory(fn(a, b));\nexport const composeArityOne = (factory, fn) => _ => factory(fn(_));\nexport const composeArityThree = (factory, fn) => (a, b, c) => factory(fn(a, b, c));\nexport const composeArityFour = (factory, fn) => (a, b, c, d) => factory(fn(a, b, c, d));\n\n// these are to forward parameters to grammar production rules ([?yield], [+in], etc)\nexport const grammarParams = {\n  yield: 1 << 0,\n  await: 1 << 1,\n  in: 1 << 2,\n  return: 1 << 3,\n  default: 1 << 4\n};\n","const nodeFactory = (defaultOrType, proto = null) => {\n  const defaultObj = typeof defaultOrType === 'string' ? {type: defaultOrType} : defaultOrType;\n  return obj => Object.assign(Object.create(proto), defaultObj, obj);\n};\n\nconst yieldArgument = {\n  * [Symbol.iterator] () {\n    yield this.argument;\n  }\n};\nconst yieldLeftRight = {\n  * [Symbol.iterator] () {\n    yield this.left;\n    yield this.right;\n  }\n};\nconst yieldExpression = {\n  * [Symbol.iterator] () {\n    yield this.expression;\n  }\n};\nconst delegateBody = {\n  * [Symbol.iterator] () {\n    yield* this.body;\n  }\n};\nconst delegateElements = {\n  * [Symbol.iterator] () {\n    yield* this.elements;\n  }\n};\nconst delegateProperties = {\n  * [Symbol.iterator] () {\n    yield* this.properties;\n  }\n};\nconst iterateFunction = {\n  * [Symbol.iterator] () {\n    yield this.id;\n    yield* this.params;\n    yield this.body;\n  }\n};\nconst iterateCall = {\n  * [Symbol.iterator] () {\n    yield this.callee;\n    yield* this.arguments;\n  }\n};\nconst iterateProperty = {\n  * [Symbol.iterator] () {\n    yield this.key;\n    yield this.value;\n  }\n};\nconst iterateCondition = {\n  * [Symbol.iterator] () {\n    yield this.test;\n    yield this.consequent;\n    yield this.alternate;\n  }\n};\n\n//pefix nodes\nexport const UnaryExpression = nodeFactory('UnaryExpression', yieldArgument);\nexport const ThisExpression = nodeFactory('ThisExpression');\nexport const Super = nodeFactory('Super');\nexport const Literal = nodeFactory('Literal');\nexport const Identifier = nodeFactory('Identifier');\nexport const UpdateExpression = nodeFactory('UpdateExpression', yieldArgument);\nexport const FunctionExpression = nodeFactory({\n  type: 'FunctionExpression',\n  id: null,\n  async: false,\n  generator: false\n}, iterateFunction);\nexport const ClassExpression = nodeFactory('ClassExpression', delegateBody);\nexport const NewExpression = nodeFactory('NewExpression', iterateCall);\nexport const SpreadElement = nodeFactory('SpreadElement', yieldArgument);\nexport const ArrayExpression = nodeFactory('ArrayExpression', delegateElements);\nexport const ObjectExpression = nodeFactory('ObjectExpression', delegateProperties);\nexport const Property = nodeFactory({\n  type: 'Property',\n  shorthand: false,\n  computed: false,\n  kind: 'init',\n  method: false,\n  value: null\n}, iterateProperty);\nexport const YieldExpression = nodeFactory({type: 'YieldExpression', delegate: false}, yieldArgument);\n\n//infix nodes\nconst asBinary = type => nodeFactory(type, yieldLeftRight);\nexport const AssignmentExpression = asBinary('AssignmentExpression');\nexport const BinaryExpression = asBinary('BinaryExpression');\nexport const LogicalExpression = asBinary('LogicalExpression');\nexport const MemberExpression = nodeFactory('MemberExpression', {\n  * [Symbol.iterator] () {\n    yield this.object;\n    yield this.property;\n  }\n});\nexport const ConditionalExpression = nodeFactory('ConditionalExpression', iterateCondition);\nexport const CallExpression = nodeFactory('CallExpression', iterateCall);\nexport const SequenceExpression = nodeFactory('SequenceExpression', {\n  * [Symbol.iterator] () {\n    yield* this.expressions;\n  }\n});\nexport const ArrowFunctionExpression = nodeFactory({\n  type: 'ArrowFunctionExpression',\n  expression: true,\n  async: false,\n  generator: false,\n  id:null\n}, iterateFunction);\n\n//statements nodes\nexport const IfStatement = nodeFactory('IfStatement', iterateCondition);\nexport const BlockStatement = nodeFactory('BlockStatement', delegateBody);\nexport const ExpressionStatement = nodeFactory('ExpressionStatement', yieldExpression);\nexport const EmptyStatement = nodeFactory('EmptyStatement');\nexport const DebuggerStatement = nodeFactory('DebuggerStatement');\nconst withArgument = (type) => nodeFactory(type, yieldArgument);\nexport const ReturnStatement = withArgument('ReturnStatement');\nexport const BreakStatement = withArgument('BreakStatement');\nexport const ContinueStatement = withArgument('ContinueStatement');\n\nexport const WithStatement = nodeFactory('WithStatement', {\n  * [Symbol.iterator] () {\n    yield this.object;\n    yield this.body;\n  }\n});\nexport const SwitchStatement = nodeFactory('SwitchStatement', {\n  * [Symbol.iterator] () {\n    yield this.discriminant;\n    yield* this.cases;\n  }\n});\nexport const SwitchCase = nodeFactory('SwitchCase', {\n  * [Symbol.iterator] () {\n    yield this.test;\n    yield* this.consequent;\n  }\n});\nexport const ThrowStatement = nodeFactory('ThrowStatement', yieldExpression);\nexport const TryStatement = nodeFactory('TryStatement', {\n  * [Symbol.iterator] () {\n    yield this.block;\n    yield this.handler;\n    yield this.finalizer;\n  }\n});\nexport const CatchClause = nodeFactory('CatchClause', {\n  * [Symbol.iterator] () {\n    yield this.param;\n    yield this.body;\n  }\n});\nexport const WhileStatement = nodeFactory('WhileStatement', {\n  * [Symbol.iterator] () {\n    yield this.test;\n    yield this.body;\n  }\n});\nexport const DoWhileStatement = nodeFactory('DoWhileStatement', {\n  * [Symbol.iterator] () {\n    yield this.body;\n    yield this.test;\n  }\n});\nexport const ForInStatement = nodeFactory('ForInStatement', yieldLeftRight);\nexport const ForStatement = nodeFactory('ForStatement', {\n  * [Symbol.iterator] () {\n    yield this.init;\n    yield this.test;\n    yield this.update;\n  }\n});\nexport const ForOfStatement = nodeFactory('ForOfStatement', yieldLeftRight);\nexport const LabeledStatement = nodeFactory('LabeledStatement', {\n  * [Symbol.iterator] () {\n    yield this.body;\n  }\n});\n\nexport const Program = nodeFactory({type: 'Program', sourceType: 'script'}, delegateBody);\n\n//declarations\nexport const AssignmentPattern = nodeFactory('AssignmentPattern', yieldLeftRight);\nexport const FunctionDeclaration = nodeFactory({\n  type: 'FunctionDeclaration',\n  async: false,\n  generator: false\n}, iterateFunction);\nexport const VariableDeclarator = nodeFactory('VariableDeclarator', {\n  * [Symbol.iterator] () {\n    yield this.id;\n    yield this.init;\n  }\n});\nexport const VariableDeclaration = nodeFactory('VariableDeclaration', {\n  * [Symbol.iterator] () {\n    yield* this.declarations;\n  }\n});\nexport const ArrayPattern = nodeFactory('ArrayPattern', delegateElements);\nexport const RestElement = nodeFactory('RestElement', yieldArgument);\nexport const ObjectPattern = nodeFactory('ObjectPattern', delegateProperties);\nexport const Class = nodeFactory('ClassDeclaration', {\n  * [Symbol.iterator] () {\n    yield this.id;\n    yield this.superClass;\n    yield this.body;\n  }\n});\nexport const ClassBody = nodeFactory('ClassBody', delegateBody);\nexport const MethodDefinition = nodeFactory('MethodDefinition', iterateProperty);\n\n//modules\nexport const ImportDeclaration = nodeFactory('ImportDeclaration', {\n  * [Symbol.iterator] () {\n    yield* this.specifiers;\n    yield this.source;\n  }\n});\nexport const ImportSpecifier = nodeFactory('ImportSpecifier', {\n  * [Symbol.iterator] () {\n    yield this.imported;\n    yield this.local;\n  }\n});\nexport const ImportDefaultSpecifier = nodeFactory('ImportDefaultSpecifier', {\n  * [Symbol.iterator] () {\n    yield this.local;\n  }\n});\nexport const ImportNamespaceSpecifier = nodeFactory('ImportNamespaceSpecifier', {\n  * [Symbol.iterator] () {\n    yield this.local;\n  }\n});\nexport const ExportNamedDeclaration = nodeFactory({\n  type: 'ExportNamedDeclaration',\n  specifiers: [],\n  declaration: null,\n  source: null\n}, {\n  * [Symbol.iterator] () {\n    yield this.declaration;\n    yield* this.specifiers;\n    yield this.source;\n  }\n});\nexport const ExportSpecifier = nodeFactory('ExportSpecifier', {\n  * [Symbol.iterator] () {\n    yield this.local;\n    yield this.exported;\n  }\n});\nexport const ExportDefaultDeclaration = nodeFactory({type: 'ExportDefaultDeclaration', specifiers: [], source: null}, {\n  * [Symbol.iterator] () {\n    yield this.declaration;\n  }\n});\nexport const ExportAllDeclaration = nodeFactory('ExportAllDeclaration', {\n  * [Symbol.iterator] () {\n    yield this.source;\n  }\n});\n\n//walk & traverse\nexport function* traverse (node) {\n  yield node;\n  if (node && node[Symbol.iterator]) {\n    for (let child of node) {\n      yield* traverse(child);\n    }\n  }\n}\n\nexport const visitWithAncestors = visitor => node => {\n\n};\nexport const visit = (...visitors) => {\n  const aggregatedVisitor = visitors.reduce((acc, curr) => {\n    for (let nodeType of Object.keys(curr)) {\n      const fns = acc[nodeType] || [];\n      fns.push(curr[nodeType]);\n      acc[nodeType] = fns;\n    }\n    return acc;\n  }, {});\n\n  return node => {\n    for (let n of traverse(node)) {\n      if (n) {\n        if (aggregatedVisitor[n.type]) {\n          for (let vfunc of aggregatedVisitor[n.type]) {\n            vfunc(n);\n          }\n        }\n      }\n    }\n  };\n};\n\n","/*\n this convert a node initially parsed as a literal (likely object or array) to an assignment pattern\n this will mutate node and its descendant to match the new grammar used\n it occurs in cases where we have parsed as literal first and then encounter a token (such \"=\" which actually indicates the literal was a pattern)\n example:\n\n let a = 3,b =4;\n [a,b] = [b,a];\n\n we don't know we have a assignment pattern until we reach the \"=\" token\n\n */\nexport const toAssignable = node => {\n  switch (node.type) {\n    case 'ArrayPattern':\n    case 'ObjectPattern':\n    case 'AssignmentPattern':\n    case 'RestElement':\n    case 'Identifier':\n      break; //skip\n    case 'ArrayExpression': {\n      node.type = 'ArrayPattern';\n      for (let ch of node) {\n        toAssignable(ch); //recursive descent\n      }\n      break;\n    }\n    case 'ObjectExpression': {\n      node.type = 'ObjectPattern';\n      for (let prop of node) {\n        if (prop.kind !== 'init' || prop.method) {\n          throw new Error('can not convert property as a destructuring pattern');\n        }\n        toAssignable(prop.value);\n      }\n      break\n    }\n    case 'SpreadElement': {\n      node.type = 'RestElement';\n      toAssignable(node.argument);\n      break;\n    }\n    case 'AssignmentExpression': {\n      if (node.operator !== '=') {\n        throw new Error('can not reinterpret assignment expression with operator different than \"=\"');\n      }\n      node.type = 'AssignmentPattern';\n      delete node.operator; // operator is not relevant for assignment pattern\n      toAssignable(node.left);//recursive descent\n      break;\n    }\n    default:\n      throw new Error(`Unexpected node could not parse \"${node.type}\" as part of a destructuring pattern `);\n  }\n  return node;\n};\n","import {\n  composeArityOne as Prefix,\n  composeArityThree as Infix,\n  composeArityTwo,\n  composeArityFour, grammarParams\n} from \"./utils\";\nimport * as ast from \"./ast\";\nimport {categories} from \"../../tokenizer/src/tokens\";\nimport {toAssignable} from \"./asAssign\";\n\n// expressions based on Javascript operators whether they are \"prefix\" or \"infix\"\n// Note: Functions and Class expressions, Object literals and Array literals are in their own files\n\n//prefix\nconst asValue = (type, key) => composeArityTwo(type, (parser, params = 0) => {\n  const {value: token} = parser.next();\n  return key ? {[key]: token.value} : {};\n});\nconst asUnaryExpression = (type) => composeArityTwo(type, (parser, params = 0) => {\n  const {value: token} = parser.next();\n  return {\n    operator: token.value,\n    argument: parser.expression(parser.getPrefixPrecedence(token), params),\n    prefix: true\n  };\n});\n\n//todo maybe split between binding identifier and binding reference (for params handling) ?\nexport const parseBindingIdentifier = composeArityTwo(ast.Identifier, (parser, params = 0) => {\n  const {value: next} = parser.next();\n  if (next.type !== categories.Identifier) {\n    throw new Error('expected an identifier');\n  }\n  return {\n    name: next.value\n  };\n});\nexport const parseIdentifierName = composeArityTwo(ast.Identifier, (parser, params = 0) => {\n  const {value: next} = parser.next();\n  if (next.type !== categories.Identifier) {\n    throw new Error('expected an identifier');\n  }\n  return {\n    name: next.value\n  };\n});\nexport const parseGroupExpression = (parser) => {\n  parser.expect('(');\n  const exp = parser.expression();\n  parser.expect(')');\n  return exp;\n};\nexport const parseUnaryExpression = asUnaryExpression(ast.UnaryExpression);\nexport const parseThisExpression = asValue(ast.ThisExpression);\nexport const parseSuperExpression = asValue(ast.Super);\nexport const parseLiteralExpression = asValue(ast.Literal, 'value');\nexport const parseRegularExpressionLiteral = Prefix(ast.Literal, parser => {\n  const {value: regexp} = parser.next();\n  return {\n    value: regexp.value,\n    regex: {\n      pattern: regexp.value.source,\n      flags: regexp.value.flags\n    }\n  }\n});\nexport const parseUpdateExpressionAsPrefix = asUnaryExpression(ast.UpdateExpression);\nexport const parseNewExpression = Prefix(ast.NewExpression, parser => {\n  const {value: newToken} = parser.expect('new');\n  const callee = parser.expression(parser.getPrefixPrecedence(newToken));\n  return {\n    callee: callee.callee ? callee.callee : callee,\n    arguments: callee.arguments ? callee.arguments : []\n  };\n});\nexport const parseYieldExpression = (parser, params = 0) => {\n  if (params & grammarParams.yield) {\n    parser.expect('yield');\n    let delegate = false;\n    if (parser.eventually('*')) {\n      delegate = true;\n    }\n    return ast.YieldExpression({\n      argument: parser.expression(parser.getPrefixPrecedence(parser.get('yield')), params),\n      delegate\n    });\n  }\n  return parseIdentifierName(parser, params);\n};\n\ncomposeArityTwo(ast.YieldExpression, parser => {\n  parser.expect('yield');\n  let delegate = false;\n  if (parser.eventually('*')) {\n    delegate = true;\n  }\n  return {\n    argument: parser.expression(parser.getPrefixPrecedence(parser.get('yield'))),\n    delegate\n  };\n});\n\n//infix\nconst asBinaryExpression = type => composeArityFour(type, (parser, params = 0, left, operator) => {\n  return {\n    left,\n    right: parser.expression(parser.getInfixPrecedence(operator), params),\n    operator: operator.value\n  };\n});\nexport const parseEqualAssignmentExpression = Infix(ast.AssignmentExpression, (parser, left, operator) => {\n  const {type} = left;\n  if (type === 'ArrayExpression' || type === 'ObjectExpression') {\n    toAssignable(left);\n  }\n  return {\n    left,\n    right: parser.expression(parser.getInfixPrecedence(operator)),\n    operator: operator.value\n  };\n});\nexport const parseAssignmentExpression = asBinaryExpression(ast.AssignmentExpression);\nexport const parseBinaryExpression = asBinaryExpression(ast.BinaryExpression);\nexport const parseLogicalExpression = asBinaryExpression(ast.LogicalExpression);\nexport const parseMemberAccessExpression = Infix(ast.MemberExpression, (parser, left, operator) => {\n  const computed = operator === parser.get('[');\n  const node = {\n    object: left,\n    computed: computed,\n    property: computed ? parser.expression() : parseIdentifierName(parser)\n  };\n  if (computed) {\n    parser.expect(']');\n  }\n  return node;\n});\nexport const parseUpdateExpression = Infix(ast.UpdateExpression, (parser, left, operator) => ({\n  argument: left,\n  operator: operator.value,\n  prefix: false\n}));\nexport const parseConditionalExpression = Infix(ast.ConditionalExpression, (parser, test) => {\n  const node = {\n    test\n  };\n  const commaPrecedence = parser.getInfixPrecedence(parser.get(','));\n  node.consequent = parser.expression(commaPrecedence);\n  parser.expect(':');\n  node.alternate = parser.expression(commaPrecedence);\n  return node;\n});\nexport const parseSequenceExpression = Infix(ast.SequenceExpression, (parser, left) => {\n  let node = left;\n  const comma = parser.get(',');\n  const next = parser.expression(parser.getInfixPrecedence(comma));\n  if (left.type === 'SequenceExpression') {\n    left.expressions.push(next);\n  } else {\n    node = {\n      expressions: [left, next]\n    }\n  }\n  return node;\n});","import {ArrayExpression, ArrayPattern, RestElement, SpreadElement} from \"./ast\";\nimport {composeArityOne, composeArityTwo} from \"./utils\";\nimport {parseAssignmentPattern, parseBindingIdentifierOrPattern} from \"./statements\";\n\n// \"array\" parsing is shared across various components:\n// - as array literals\n// - as array pattern\nexport const parseRestElement = composeArityOne(RestElement, parser => {\n  parser.expect('...');\n  return {\n    argument: parseBindingIdentifierOrPattern(parser)\n  };\n});\nexport const parseSpreadExpression = composeArityOne(SpreadElement, parser => {\n  parser.expect('...');\n  return {\n    argument: parser.expression(parser.getPrefixPrecedence(parser.get('...')))\n  };\n});\n\nconst parseArrayElision = (parser, elements) => {\n  const {value: next} = parser.lookAhead();\n\n  if (next !== parser.get(',')) {\n    return elements;\n  }\n\n  elements.push(null);\n  parser.eat();\n\n  return parseArrayElision(parser, elements);\n};\nconst arrayElements = (parseEllipsis, process) => {\n  const fn = (parser, elements = []) => {\n    const {value: next} = parser.lookAhead();\n    const comma = parser.get(',');\n\n    if (next === parser.get(']')) {\n      return elements;\n    }\n\n    if (next === parser.get('...')) {\n      elements.push(parseEllipsis(parser));\n      parser.eventually(',');\n      return fn(parser, elements);\n    }\n\n    if (next === comma) {\n      parseArrayElision(parser, elements);\n      return fn(parser, elements);\n    }\n\n    process(parser, elements);\n\n    return fn(parser, elements);\n  };\n  return fn;\n};\nconst parseArrayElements = arrayElements(parseSpreadExpression, (parser, elements) => {\n  elements.push(parser.expression(parser.getInfixPrecedence(parser.get(','))));\n  parser.eventually(',');\n});\nconst parseArrayElementsBindingPattern = arrayElements(parseRestElement, (parser, elements) => {\n  let element = parseBindingIdentifierOrPattern(parser);\n  if (parser.eventually('=')) {\n    element = parseAssignmentPattern(parser, element);\n  }\n  elements.push(element);\n  parser.eventually(',');\n});\n\nexport const parseArrayBindingPattern = composeArityTwo(ArrayPattern, parser => {\n  parser.expect('[');\n  const node = {\n    elements: parseArrayElementsBindingPattern(parser)\n  };\n  parser.expect(']');\n  return node;\n});\nexport const parseArrayLiteralExpression = composeArityOne(ArrayExpression, (parser) => {\n  parser.expect('[');\n  const node = {\n    elements: parseArrayElements(parser)\n  };\n  parser.expect(']');\n  return node;\n});","import * as ast from './ast';\nimport {parseBindingIdentifier} from \"./expressions\";\nimport {parseBlockStatement, parseAssignmentPattern, parseBindingIdentifierOrPattern} from \"./statements\";\nimport {composeArityOne, composeArityTwo} from \"./utils\";\nimport {parseSpreadExpression, parseRestElement} from \"./array\";\nimport {toAssignable} from \"./asAssign\";\n\n// \"function\" parsing is shared across multiple components and deserves its own module to mutualize code more easily:\n// - as statement aka function declaration\n// - as expression\n// - as arrow function (expression)\n// - as method (within object or class body)\n// - as function call\n\nexport const parseFormalParameters = (parser, parameters = []) => {\n  const {value: next} = parser.lookAhead();\n  const comma = parser.get(',');\n\n  if (next === parser.get(')')) {\n    return parameters;\n  }\n\n  if (next === parser.get('...')) {\n    parameters.push(parseRestElement(parser));\n    return parameters; //rest parameter must be the last\n  }\n\n  //todo no elision & defaultParameters must be last ...\n  if (next !== comma) {\n    let param = parseBindingIdentifierOrPattern(parser);\n    if (parser.eventually('=')) {\n      param = parseAssignmentPattern(parser, param);\n    }\n    parameters.push(param);\n  } else {\n    parser.eat();\n  }\n  return parseFormalParameters(parser, parameters);\n};\nexport const asPropertyFunction = (parser, prop) => {\n  parser.expect('(');\n  const params = parseFormalParameters(parser);\n  parser.expect(')');\n  const body = parseBlockStatement(parser);\n  return Object.assign(prop, {\n    value: ast.FunctionExpression({\n      params,\n      body\n    })\n  });\n};\n\nconst parseParamsAndBody = parser => {\n  parser.expect('(');\n  const params = parseFormalParameters(parser);\n  parser.expect(')');\n  const body = parseBlockStatement(parser);\n  return {params, body};\n};\nexport const parseFunctionDeclaration = composeArityOne(ast.FunctionDeclaration, parser => {\n  parser.expect('function');\n  const generator = parser.eventually('*');\n  const id = parseBindingIdentifier(parser);\n  return Object.assign({\n    id,\n    generator\n  }, parseParamsAndBody(parser));\n});\n\n//that is a prefix expression\nexport const parseFunctionExpression = composeArityOne(ast.FunctionExpression, parser => {\n  parser.expect('function');\n  const generator = parser.eventually('*');\n  let id = null;\n  const {value: nextToken} = parser.lookAhead();\n  if (nextToken !== parser.get('(')) {\n    id = parseBindingIdentifier(parser);\n  }\n  return Object.assign({id, generator}, parseParamsAndBody(parser));\n});\n\n//todo we might want to process \"parenthesized\" expression instead. ie this parser will parse {a},b => a+b whereas it is invalid\nconst asFormalParameters = (node) => {\n  if (node === null) {\n    return []\n  }\n  return node.type === 'SequenceExpression' ? [...node].map(toAssignable) : [toAssignable(node)];\n};\n\nexport const parseArrowFunctionExpression = composeArityTwo(ast.ArrowFunctionExpression, (parser, left) => {\n  const params = asFormalParameters(left);\n  const {value: next} = parser.lookAhead();\n  const body = next === parser.get('{') ? parseBlockStatement(parser) : parser.expression();\n  return {\n    params,\n    body\n  };\n});\n\n//that is an infix expression\nconst parseFunctionCallArguments = (parser, expressions = []) => {\n  const {value: next} = parser.lookAhead();\n  const comma = parser.get(',');\n\n  if (next === parser.get(')')) {\n    return expressions;\n  }\n\n  if (next === parser.get('...')) {\n    expressions.push(parseSpreadExpression(parser));\n    parser.eventually(',');\n    return expressions;\n  }\n\n  expressions.push(parser.expression(parser.getInfixPrecedence(comma)));\n  parser.eventually(','); //todo no elision allowed\n  return parseFunctionCallArguments(parser, expressions);\n};\nexport const parseCallExpression = composeArityTwo(ast.CallExpression, (parser, callee) => {\n  const node = {\n    callee,\n    arguments: parseFunctionCallArguments(parser)\n  };\n  parser.expect(')');\n  return node;\n});\n\n","import {Property, ObjectExpression, ObjectPattern, Identifier} from \"./ast\"\nimport {composeArityOne} from \"./utils\";\nimport {categories} from \"../../tokenizer/src/tokens\";\nimport {parseBindingIdentifier, parseIdentifierName} from \"./expressions\";\nimport {asPropertyFunction} from \"./function\";\nimport {parseBindingIdentifierOrPattern, parseAssignmentPattern} from \"./statements\";\n\n// \"object\" parsing is shared across various components:\n// - as object literals\n// - as object pattern\n// - within class bodies as well\n\nconst parseComputedPropertyName = parser => {\n  parser.expect('[');\n  const key = parser.expression();\n  parser.expect(']');\n  return {\n    key,\n    computed: true\n  };\n};\nconst parseLiteralPropertyName = parser => ({key: parser.expression(20), computed: false});// max precedence => a literal or an identifier or a keyword\nexport const parsePropertyName = parser => {\n  const {value: next} = parser.lookAhead();\n  return next === parser.get('[') ?\n    parseComputedPropertyName(parser) :\n    parseLiteralPropertyName(parser)\n};\n\nconst parsePropertyDefinition = composeArityOne(Property, parser => {\n  let {value: next} = parser.lookAhead();\n  let prop;\n  const {value: secondNext} = parser.lookAhead(1);\n\n  //binding reference\n  if (next.type === categories.Identifier) {\n    if ((secondNext === parser.get(',') || secondNext === parser.get('}'))) {\n      const key = parseBindingIdentifier(parser);\n      return {\n        shorthand: true,\n        key,\n        value: key\n      };\n    }\n    //cover Initialized grammar https://tc39.github.io/ecma262/#prod-CoverInitializedName\n    if (secondNext === parser.get('=')) {\n      const key = parseBindingIdentifier(parser);\n      const value = parseAssignmentPattern(parser, key);\n      return {\n        shorthand: true,\n        key,\n        value\n      };\n    }\n  }\n\n  //can be a getter/setter or a shorthand binding or a property with init...\n  if (next === parser.get('get') || next === parser.get('set')) {\n    const {value: accessor} = parser.next();\n    const {value: next} = parser.lookAhead();\n\n    if (next !== parser.get('(') && next !== parser.get(':')) {\n      prop = Object.assign(parsePropertyName(parser), {kind: accessor.rawValue});\n      return asPropertyFunction(parser, prop);\n    }\n\n    prop = {\n      key: Identifier({name: accessor.value})\n    };\n  }\n\n  prop = prop !== void 0 ? prop : parsePropertyName(parser);\n  next = parser.lookAhead().value;\n  if (next === parser.get('(')) {\n    //method\n    return asPropertyFunction(parser, Object.assign(prop, {method: true}));\n  } else if (next === parser.get(':')) {\n    //with initializer\n    parser.expect(':');\n    return Object.assign(prop, {\n      value: parser.expression(parser.getInfixPrecedence(parser.get(',')))\n    });\n  }\n\n  throw new Error(`Unexpected token: expected \":\" or \"(\" but got ${next.rawValue}`);\n\n});\nconst parsePropertyList = (parser, properties = []) => {\n  const {value: nextToken} = parser.lookAhead();\n  if (nextToken === parser.get('}')) {\n    return properties;\n  }\n\n  if (!parser.eventually(',')) {\n    properties.push(parsePropertyDefinition(parser));\n  }\n\n  return parsePropertyList(parser, properties);\n};\nexport const parseObjectLiteralExpression = composeArityOne(ObjectExpression, parser => {\n  parser.expect('{');\n  const node = {\n    properties: parsePropertyList(parser)\n  };\n  parser.expect('}');\n  return node;\n});\n\nconst parseSingleNameBindingProperty = parser => {\n  const key = parseIdentifierName(parser);\n  let value = key;\n  let shorthand = false;\n  if (parser.eventually(':')) {\n    value = parseBindingIdentifierOrPattern(parser);\n  } else {\n    shorthand = true;\n    value = key;\n  }\n\n  if (parser.eventually('=')) {\n    value = parseAssignmentPattern(parser, value);\n  }\n  return {shorthand, key, value};\n};\nconst parsePropertyNameProperty = parser => {\n  const property = parsePropertyName(parser);\n  parser.expect(':');\n  return Object.assign(property, {\n    value: parseBindingIdentifierOrPattern(parser)\n  });\n};\nconst parseBindingProperty = parser => {\n  const {value: next} = parser.lookAhead();\n  const property = Property({});\n  return next.type === categories.Identifier && parser.isReserved(next) === false ? //identifier but not reserved word\n    Object.assign(property, parseSingleNameBindingProperty(parser)) :\n    Object.assign(property, parsePropertyNameProperty(parser));\n};\nconst parseBindingPropertyList = (parser, properties = []) => {\n  const {value: next} = parser.lookAhead();\n  if (next === parser.get('}')) {\n    return properties;\n  }\n  if (!parser.eventually(',')) {\n    properties.push(parseBindingProperty(parser));\n  }\n  return parseBindingPropertyList(parser, properties);\n};\nexport const parseObjectBindingPattern = composeArityOne(ObjectPattern, parser => {\n  parser.expect('{');\n  const node = {\n    properties: parseBindingPropertyList(parser)\n  };\n  parser.expect('}');\n  return node;\n});","import {MethodDefinition, ClassBody, ClassExpression, Class} from \"./ast\";\nimport {composeArityOne} from \"./utils\";\nimport {parseBindingIdentifier} from \"./expressions\";\nimport {categories} from \"../../tokenizer/src/tokens\";\nimport {asPropertyFunction} from \"./function\";\nimport {parsePropertyName} from \"./object\";\n\nconst parseClassMethod = composeArityOne(MethodDefinition, (parser) => {\n  const isStatic = parser.eventually('static');\n  const {value: next} = parser.lookAhead();\n  const {value: secondNext} = parser.lookAhead(1);\n  let prop;\n\n  if (next === parser.get('get') || next === parser.get('set')) {\n    if (secondNext !== parser.get('(')) {\n      const {value: accessor} = parser.eat();\n      prop = Object.assign(parsePropertyName(parser), {kind: accessor.rawValue});\n    } else {\n      prop = {\n        key: parseBindingIdentifier(parser),\n        computed: false\n      }\n    }\n  }\n\n  prop = prop !== void 0 ? prop : parsePropertyName(parser);\n\n  if (prop.kind === void 0) {\n    prop.kind = prop.key.name === 'constructor' ? 'constructor' : 'method';\n  }\n\n  return Object.assign(asPropertyFunction(parser, prop), {static: isStatic});\n});\nconst parseClassElementList = (parser, elements = []) => {\n  const {value: next} = parser.lookAhead();\n  if (next === parser.get('}')) {\n    return elements;\n  }\n  if (next !== parser.get(';')) {\n    elements.push(parseClassMethod(parser));\n  } else {\n    parser.eat();\n  }\n  return parseClassElementList(parser, elements);\n};\nexport const parseClassBody = composeArityOne(ClassBody, parser => {\n  parser.expect('{');\n  const node = {\n    body: parseClassElementList(parser)\n  };\n  parser.expect('}');\n  return node;\n});\n\nconst parseClassTail = (parser, id) => {\n  let superClass = null;\n\n  if (parser.eventually('extends')) {\n    superClass = parser.expression();\n  }\n\n  return {\n    id,\n    superClass,\n    body: parseClassBody(parser)\n  };\n};\n\nexport const parseClassDeclaration = composeArityOne(Class, parser => {\n  parser.expect('class');\n  const id = parseBindingIdentifier(parser);\n  return parseClassTail(parser, id);\n});\n\nexport const parseClassExpression = composeArityOne(ClassExpression, parser => {\n  parser.expect('class');\n  let id = null;\n  const {value: next} = parser.lookAhead();\n  if (next.type === categories.Identifier && next !== parser.get('extends')) {\n    id = parseBindingIdentifier(parser);\n  }\n  return parseClassTail(parser, id);\n});","import * as ast from './ast';\nimport {categories} from \"../../tokenizer/src/tokens\";\nimport {composeArityOne} from \"./utils\";\nimport {parseBindingIdentifier, parseIdentifierName, parseLiteralExpression} from \"./expressions\";\nimport {parseConstDeclaration, parseLetDeclaration, parseVariableDeclaration} from \"./statements\";\nimport {parseFunctionDeclaration} from \"./function\";\nimport {parseClassDeclaration} from \"./class\";\nimport {parseExpression} from \"./index\";\n\nconst parseNamedImport = (parser, specifiers) => {\n  const {value: next} = parser.lookAhead();\n\n  if (next === parser.get('}')) {\n    return specifiers;\n  }\n\n  const imported = parseIdentifierName(parser);\n  let hasAs = false;\n  if (parser.isReserved(next)) {\n    parser.expect('as');\n    hasAs = true;\n  } else {\n    hasAs = parser.eventually('as');\n  }\n\n  const local = hasAs ? parseBindingIdentifier(parser) : imported;\n\n  specifiers.push(ast.ImportSpecifier({\n    local,\n    imported\n  }));\n\n  if (parser.eventually(',')) { // elision is not allowed\n    const {value: next} = parser.lookAhead();\n    if (next === parser.get('}')) {\n      return specifiers;\n    }\n  }\n\n  return parseNamedImport(parser, specifiers);\n};\nconst parseImportDefaultSpecifier = (parser, specifiers) => {\n  specifiers.push(ast.ImportDefaultSpecifier({\n    local: parseBindingIdentifier(parser)\n  }));\n  return specifiers;\n};\nconst parseImportNamespaceSpecifier = (parser, specifiers) => {\n  parser.expect('*');\n  parser.expect('as');\n  specifiers.push(ast.ImportNamespaceSpecifier({\n    local: parseBindingIdentifier(parser)\n  }));\n  return specifiers;\n};\nconst parseImportClause = (parser, specifiers = []) => {\n  const {value: next} = parser.lookAhead();\n  if (next.type === categories.Identifier) {\n\n    parseImportDefaultSpecifier(parser, specifiers);\n\n    if (parser.eventually(',')) {\n      const {value: next} = parser.lookAhead();\n\n      if (next === parser.get('*')) {\n        return parseImportNamespaceSpecifier(parser, specifiers);\n      } else if (next === parser.get('{')) {\n        parser.expect('{');\n        parseNamedImport(parser, specifiers);\n        parser.expect('}');\n      } else {\n        throw new Error(`expected \"{\" or \"*\"`);\n      }\n    }\n    return specifiers;\n  }\n\n  if (next === parser.get('*')) {\n    return parseImportNamespaceSpecifier(parser, specifiers);\n  }\n\n  parser.expect('{');\n  parseNamedImport(parser, specifiers);\n  parser.expect('}');\n  return specifiers;\n};\nconst parseFromClause = (parser) => {\n  parser.expect('from');\n  const {value: next} = parser.lookAhead();\n  if (next.type !== categories.StringLiteral) {\n    throw new Error('Expected a string literal');\n  }\n  return parseLiteralExpression(parser);\n};\n\nexport const parseImportDeclaration = composeArityOne(ast.ImportDeclaration, parser => {\n  parser.expect('import');\n  const {value: next} = parser.lookAhead();\n  if (next.type === categories.StringLiteral) {\n    return {\n      specifiers: [],\n      source: parseLiteralExpression(parser)\n    };\n  }\n  const specifiers = parseImportClause(parser);\n  const source = parseFromClause(parser);\n  return {\n    source,\n    specifiers\n  };\n});\n\nconst parseExportAllDeclaration = composeArityOne(ast.ExportAllDeclaration, parser => {\n  parser.expect('*');\n  return {\n    source: parseFromClause(parser)\n  };\n});\nconst parseNamedExportDeclaration = (parser, specifiers = []) => {\n  const {value: next} = parser.lookAhead();\n\n  if (next === parser.get('}')) {\n    return specifiers;\n  }\n\n  const local = parseIdentifierName(parser);\n  const exported = parser.eventually('as') ? parseIdentifierName(parser) : local;\n\n  specifiers.push(ast.ExportSpecifier({\n    local,\n    exported\n  }));\n\n  if (parser.eventually(',')) { // elision is not allowed\n    const {value: next} = parser.lookAhead();\n    if (next === parser.get('}')) {\n      return specifiers;\n    }\n  }\n\n  return parseNamedExportDeclaration(parser, specifiers);\n};\nconst parseExportAsDeclaration = (fn) => composeArityOne(ast.ExportNamedDeclaration, parser => ({\n  declaration: fn(parser)\n}));\nconst parseExportAsDefaultDeclaration = (fn) => composeArityOne(ast.ExportDefaultDeclaration, parser => ({\n  declaration: fn(parser)\n}));\nexport const parseExportDeclaration = parser => {\n  parser.expect('export');\n  const {value: next} = parser.lookAhead();\n  switch (next) {\n    case parser.get('*'):\n      return parseExportAllDeclaration(parser);\n    case parser.get('{'): {\n      parser.expect('{');\n      const node = ast.ExportNamedDeclaration({\n        specifiers: parseNamedExportDeclaration(parser)\n      });\n      parser.expect('}');\n      const {value: next} = parser.lookAhead();\n      node.source = next === parser.get('from') ? parseFromClause(parser) : null;\n      return node;\n    }\n    case parser.get('var'):\n      return parseExportAsDeclaration(parseVariableDeclaration)(parser);\n    case parser.get('const'):\n      return parseExportAsDeclaration(parseConstDeclaration)(parser);\n    case parser.get('let'):\n      return parseExportAsDeclaration(parseLetDeclaration)(parser);\n    case parser.get('function'):\n      return parseExportAsDeclaration(parseFunctionDeclaration)(parser);\n    case parser.get('class'):\n      return parseExportAsDeclaration(parseClassDeclaration)(parser);\n    case parser.get('default'): {\n      parser.expect('default');\n      const {value: next} = parser.lookAhead();\n      switch (next) {\n        case parser.get('function'):\n          return parseExportAsDefaultDeclaration(parseFunctionDeclaration)(parser);\n        case parser.get('class'):\n          return parseExportAsDefaultDeclaration(parseClassDeclaration)(parser);\n        default:\n          return parseExportAsDefaultDeclaration(parser => parser.expression())(parser);\n      }\n    }\n    default:\n      throw new Error('Unknown export statement');\n  }\n\n};","import * as ast from './ast';\nimport {parseBindingIdentifier} from \"./expressions\";\nimport {composeArityTwo, grammarParams, withEventualSemiColon} from \"./utils\";\nimport {parseArrayBindingPattern} from \"./array\";\nimport {parseObjectBindingPattern} from \"./object\";\nimport {parseExportDeclaration, parseImportDeclaration} from \"./module\";\n\n// statements\n// Note: Function declarations,class declarations, array and object binding pattern are in they own files\n\nconst Statement = (factory, fn) => {\n  if (!fn) {\n    return factory;\n  } else {\n    return composeArityTwo(factory, fn);\n  }\n};\n\nexport const parseStatementList = (parser, params = 0, statements = []) => {\n  const {done, value: nextToken} = parser.lookAhead();\n  if (done || nextToken === parser.get('}')) {\n    return statements;\n  }\n  statements.push(parseStatement(parser, params));\n  return parseStatementList(parser, params, statements);\n};\n\nconst parseImport = withEventualSemiColon(parseImportDeclaration);\nconst parseExport = withEventualSemiColon(parseExportDeclaration);\nexport const parseModuleItemList = (parser, items = []) => {\n  const {done, value: nextToken} = parser.lookAhead();\n\n  if (done) {\n    return items;\n  }\n\n  if (nextToken === parser.get('import')) {\n    items.push(parseImport(parser));\n  } else if (nextToken === parser.get('export')) {\n    items.push(parseExport(parser));\n  } else {\n    items.push(parseStatement(parser));\n  }\n  return parseModuleItemList(parser, items);\n};\n\nexport const parseExpressionStatement = composeArityTwo(ast.ExpressionStatement, (parser, params = 0) => ({\n  expression: parser.expression(-1, params | grammarParams.in)\n}));\n\nconst parseExpression = withEventualSemiColon(parseExpressionStatement);\nexport const parseStatement = (parser, params = 0) => {\n  const {value: nextToken} = parser.lookAhead();\n  return parser.hasStatement(nextToken) ? parser.getStatement(nextToken)(parser, params) : parseExpression(parser, params);\n};\n\nexport const parseIfStatement = composeArityTwo(ast.IfStatement, (parser, params = 0) => {\n  parser.expect('if');\n  parser.expect('(');\n  const test = parser.expression(-1, params | grammarParams.in);\n  parser.expect(')');\n  const consequent = parseStatement(parser, params);\n  let alternate = null;\n  if (parser.eventually('else')) {\n    alternate = parseStatement(parser, params);\n  }\n  return {\n    test,\n    consequent,\n    alternate\n  };\n});\n\nexport const parseBlockStatement = Statement(ast.BlockStatement, parser => {\n  parser.expect('{');\n  const node = {\n    body: parseStatementList(parser)\n  };\n  parser.expect('}');\n  return node;\n});\n\nexport const parseExpressionOrLabeledStatement = parser => {\n  const {value: nextToken} = parser.lookAhead(1);\n  return nextToken === parser.get(':') ? parseLabeledStatement(parser) : parseExpression(parser);\n};\n\nexport const parseEmptyStatement = Statement(ast.EmptyStatement, parser => {\n  parser.expect(';');\n});\n\nexport const parseDebuggerStatement = Statement(ast.DebuggerStatement);\n\nexport const parseReturnStatement = Statement(ast.ReturnStatement, parser => {\n  parser.expect('return');\n  return {\n    argument: parser.expression()\n  };\n});\n\nexport const parseBreakStatement = Statement(ast.BreakStatement, parser => {\n  parser.expect('break');\n  return {\n    label: parser.expression(20)\n  };\n});\n\nexport const parseContinueStatement = Statement(ast.ContinueStatement, parser => {\n  parser.expect('continue');\n  return {\n    label: parser.expression(20)\n  };\n});\n\nexport const parseWithStatement = Statement(ast.WithStatement, parser => {\n  parser.expect('with');\n  parser.expect('(');\n  const object = parser.expression();\n  parser.expect(')');\n  return {\n    object,\n    body: parseStatement(parser)\n  };\n});\n\nexport const parseSwitchStatement = Statement(ast.SwitchStatement, parser => {\n  parser.expect('switch');\n  parser.expect('(');\n  const discriminant = parser.expression();\n  parser.expect(')');\n  parser.expect('{');\n  const cases = parseSwitchCases(parser);\n  parser.expect('}');\n  return {\n    discriminant,\n    cases\n  };\n});\n\nexport const parseSwitchCases = (parser, cases = []) => {\n  const {value: nextToken} = parser.lookAhead();\n  if (nextToken !== parser.get('case') && nextToken !== parser.get('default')) {\n    return cases;\n  }\n  parser.eat();\n  cases.push(parseSwitchCase(parser, nextToken));\n  return parseSwitchCases(parser, cases);\n};\n\nexport const parseSwitchCase = Statement(ast.SwitchCase, (parser, nextToken) => {\n  const node = {\n    test: nextToken === parser.get('case') ? parser.expression() : null\n  };\n  parser.expect(':');\n  node.consequent = parseStatementList(parser, ['}', 'case', 'default']);\n  return node;\n});\n\nexport const parseThrowStatement = Statement(ast.ThrowStatement, parser => {\n  parser.expect('throw');\n  return {\n    argument: parser.expression()\n  };\n});\n\nexport const parseTryStatement = Statement(ast.TryStatement, parser => {\n  parser.expect('try');\n  const node = {block: parseBlockStatement(parser), handler: null, finalizer: null};\n  if (parser.eventually('catch')) {\n    const handler = {type: 'CatchClause'};\n    parser.expect('(');\n    handler.param = parser.expression();\n    parser.expect(')');\n    handler.body = parseBlockStatement(parser);\n    node.handler = handler;\n  }\n  if (parser.eventually('finally')) {\n    node.finalizer = parseBlockStatement(parser);\n  }\n  return node;\n});\n\nexport const parseWhileStatement = Statement(ast.WhileStatement, parser => {\n  parser.expect('while');\n  parser.expect('(');\n  const node = {\n    test: parser.expression()\n  };\n  parser.expect(')');\n  node.body = parseStatement(parser);\n  return node;\n});\n\nexport const parseDoWhileStatement = Statement(ast.DoWhileStatement, parser => {\n  parser.expect('do');\n  const node = {\n    body: parseStatement(parser)\n  };\n  parser.expect('while');\n  parser.expect('(');\n  node.test = parser.expression();\n  parser.expect(')');\n  return node;\n});\n\nexport const parseAssignmentPattern = Statement(ast.AssignmentPattern, (parser, left) => {\n  return {\n    left,\n    right: parser.expression(parser.getInfixPrecedence(parser.get(',')))\n  };\n});\n\nexport const parseBindingIdentifierOrPattern = (parser, params = 0) => {\n  const {value: next} = parser.lookAhead();\n  if (parser.get('{') === next) {\n    return parseObjectBindingPattern(parser, params);\n  } else if (parser.get('[') === next) {\n    return parseArrayBindingPattern(parser, params);\n  }\n  return parseBindingIdentifier(parser, params);\n};\n\nconst asVariableDeclaration = (keyword = 'var') => composeArityTwo(ast.VariableDeclaration, (parser, params = 0) => {\n  parser.expect(keyword);\n  return {\n    kind: keyword,\n    declarations: parseVariableDeclarators(parser, params)\n  };\n});\nconst parseVariableDeclarator = composeArityTwo(ast.VariableDeclarator, (parser, params = 0) => {\n  const comma = parser.get(',');\n  const node = {id: parseBindingIdentifierOrPattern(parser, params), init: null};\n  if (parser.eventually('=')) {\n    node.init = parser.expression(parser.getInfixPrecedence(comma), params);\n  }\n  return node;\n});\nexport const parseVariableDeclarators = (parser, params = 0, declarators = []) => {\n  const node = parseVariableDeclarator(parser, params);\n  const comma = parser.get(',');\n  const {value: nextToken} = parser.lookAhead();\n\n  declarators.push(node);\n\n  if (nextToken !== comma) {\n    return declarators;\n  }\n  parser.eat();\n  return parseVariableDeclarators(parser, params, declarators);\n};\nexport const parseVariableDeclaration = asVariableDeclaration();\nexport const parseConstDeclaration = asVariableDeclaration('const');\nexport const parseLetDeclaration = asVariableDeclaration('let');\n\nconst getForDerivation = parser => {\n  const {value: nextToken} = parser.lookAhead();\n  switch (nextToken) {\n    case parser.get('in'):\n      return asForIn;\n    case parser.get('of'):\n      return asForOf;\n    default:\n      return asFor;\n  }\n};\n\nconst asFor = Statement(ast.ForStatement, (parser, init) => {\n  parser.expect(';');\n  const n = {\n    init,\n    test: parser.expression()\n  };\n  parser.expect(';');\n  n.update = parser.expression();\n  return n;\n});\nconst asForIn = Statement(ast.ForInStatement, (parser, left) => {\n  parser.expect('in');\n  return {\n    left,\n    right: parser.expression()\n  };\n});\nconst asForOf = Statement(ast.ForOfStatement, (parser, left) => {\n  parser.expect('of');\n  return {\n    left,\n    right: parser.expression()\n  };\n});\n\n//todo does not seem to fit all cases\nexport const parseForStatement = parser => {\n  parser.expect('for');\n  parser.expect('(');\n  const {value: token} = parser.lookAhead();\n  let startExpression, node;\n  if (token === parser.get('var')) {\n    startExpression = parseVariableDeclaration(parser);\n  } else if (token === parser.get('const')) {\n    startExpression = parseConstDeclaration(parser);\n  } else if (token === parser.get('let')) {\n    startExpression = parseLetDeclaration(parser);\n  } else {\n    startExpression = parser.expression(-1, [parser.get('in'), parser.get('of')]); //\"in\" is not an operator here !\n  }\n  const derivation = getForDerivation(parser);\n  node = derivation(parser, startExpression);\n  parser.expect(')');\n  node.body = parseStatement(parser);\n  return node;\n};\n\nexport const parseLabeledStatement = Statement(ast.LabeledStatement, parser => {\n  const node = {\n    label: parser.expression(20)\n  };\n  parser.expect(':');\n  node.body = parseStatement(parser);\n  return node;\n});","import {tokenRegistry, categories} from \"../../tokenizer/src/tokens\";\nimport * as expressions from './expressions';\nimport * as statements from './statements';\nimport {parseArrayLiteralExpression, parseSpreadExpression} from \"./array\";\nimport {parseObjectLiteralExpression} from \"./object\";\nimport {parseClassDeclaration, parseClassExpression} from \"./class\";\nimport {\n  parseFunctionExpression, parseFunctionDeclaration, parseCallExpression,\n  parseArrowFunctionExpression\n} from \"./function\";\nimport {withEventualSemiColon} from \"./utils\";\n\nexport const ECMAScriptTokenRegistry = () => {\n  const registry = tokenRegistry();\n\n  /**\n   * EXPRESSIONS\n   */\n\n  const prefixMap = new Map();\n  //unary operators\n  prefixMap.set(registry.get('-'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('+'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('!'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('~'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('typeof'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('void'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('delete'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('...'), {parse: parseSpreadExpression, precedence: 1});\n  prefixMap.set(registry.get('yield'), {parse: expressions.parseYieldExpression, precedence: 2});\n  //update operators\n  prefixMap.set(registry.get('--'), {parse: expressions.parseUpdateExpressionAsPrefix, precedence: 16});\n  prefixMap.set(registry.get('++'), {parse: expressions.parseUpdateExpressionAsPrefix, precedence: 16});\n  //literals\n  prefixMap.set(categories.StringLiteral, {parse: expressions.parseLiteralExpression, precedence: -1});\n  prefixMap.set(categories.NumericLiteral, {parse: expressions.parseLiteralExpression, precedence: -1});\n  prefixMap.set(categories.RegularExpressionLiteral, {\n    parse: expressions.parseRegularExpressionLiteral,\n    precedence: -1\n  });\n  prefixMap.set(registry.get('null'), {parse: expressions.parseLiteralExpression, precedence: -1});\n  prefixMap.set(registry.get('false'), {parse: expressions.parseLiteralExpression, precedence: -1});\n  prefixMap.set(registry.get('true'), {parse: expressions.parseLiteralExpression, precedence: -1});\n  // prefixMap.set(categories.Template, {parse: expressions.parseTemplateLiteral, precedence: -1});\n  // prefixMap.set(categories.TemplateHead, {parse: expressions.parseTemplateLiteral, precedence: -1});\n  prefixMap.set(registry.get('['), {parse: parseArrayLiteralExpression, precedence: -1});\n  prefixMap.set(registry.get('{'), {parse: parseObjectLiteralExpression, precedence: -1});\n  //identifiers\n  prefixMap.set(registry.get('this'), {parse: expressions.parseThisExpression, precedence: -1});\n  prefixMap.set(registry.get('super'), {parse: expressions.parseSuperExpression, precedence: -1});\n  prefixMap.set(categories.Identifier, {parse: expressions.parseIdentifierName, precedence: -1});\n  //functions\n  prefixMap.set(registry.get('function'), {parse: parseFunctionExpression, precedence: -1});\n  prefixMap.set(registry.get('class'), {parse: parseClassExpression, precedence: -1});\n  prefixMap.set(registry.get('new'), {parse: expressions.parseNewExpression, precedence: 18});\n  //group\n  prefixMap.set(registry.get('('), {parse: expressions.parseGroupExpression, precedence: 20});\n\n  const infixMap = new Map();\n  //sequence\n  infixMap.set(registry.get(','), {parse: expressions.parseSequenceExpression, precedence: 0});\n  //conditional\n  infixMap.set(registry.get('?'), {parse: expressions.parseConditionalExpression, precedence: 4});\n  //assignment operators\n  infixMap.set(registry.get('='), {parse: expressions.parseEqualAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('+='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('-='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('*='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('/='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('%='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('<<='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('>>='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('>>>='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('&='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('^='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('|='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('=>'), {parse: parseArrowFunctionExpression, precedence: 21}); // fake precedence of 21\n  //binary operators\n  infixMap.set(registry.get('=='), {parse: expressions.parseBinaryExpression, precedence: 10});\n  infixMap.set(registry.get('!='), {parse: expressions.parseBinaryExpression, precedence: 10});\n  infixMap.set(registry.get('==='), {parse: expressions.parseBinaryExpression, precedence: 10});\n  infixMap.set(registry.get('!=='), {parse: expressions.parseBinaryExpression, precedence: 10});\n  infixMap.set(registry.get('<'), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('<='), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('>'), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('>='), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('in'), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('instanceof'), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('<<'), {parse: expressions.parseBinaryExpression, precedence: 12});\n  infixMap.set(registry.get('>>'), {parse: expressions.parseBinaryExpression, precedence: 12});\n  infixMap.set(registry.get('>>>'), {parse: expressions.parseBinaryExpression, precedence: 12});\n  infixMap.set(registry.get('+'), {parse: expressions.parseBinaryExpression, precedence: 13});\n  infixMap.set(registry.get('-'), {parse: expressions.parseBinaryExpression, precedence: 13});\n  infixMap.set(registry.get('*'), {parse: expressions.parseBinaryExpression, precedence: 14});\n  infixMap.set(registry.get('/'), {parse: expressions.parseBinaryExpression, precedence: 14});\n  infixMap.set(registry.get('%'), {parse: expressions.parseBinaryExpression, precedence: 14});\n  infixMap.set(registry.get('**'), {parse: expressions.parseBinaryExpression, precedence: 15});\n  infixMap.set(registry.get('|'), {parse: expressions.parseBinaryExpression, precedence: 7});\n  infixMap.set(registry.get('^'), {parse: expressions.parseBinaryExpression, precedence: 8});\n  infixMap.set(registry.get('&'), {parse: expressions.parseBinaryExpression, precedence: 9});\n  //member access operator\n  infixMap.set(registry.get('.'), {parse: expressions.parseMemberAccessExpression, precedence: 19});\n  infixMap.set(registry.get('['), {parse: expressions.parseMemberAccessExpression, precedence: 19});\n  //logical operators\n  infixMap.set(registry.get('||'), {parse: expressions.parseLogicalExpression, precedence: 5});\n  infixMap.set(registry.get('&&'), {parse: expressions.parseLogicalExpression, precedence: 6});\n  //update operators\n  infixMap.set(registry.get('++'), {parse: expressions.parseUpdateExpression, precedence: 17});\n  infixMap.set(registry.get('--'), {parse: expressions.parseUpdateExpression, precedence: 17});\n  //call\n  infixMap.set(registry.get('('), {parse: parseCallExpression, precedence: 19});\n\n  /**\n   * STATEMENTS\n   */\n\n  const statementsMap = new Map();\n  statementsMap.set(registry.get('if'), statements.parseIfStatement);\n  statementsMap.set(registry.get(';'), statements.parseEmptyStatement);\n  statementsMap.set(registry.get('{'), statements.parseBlockStatement);\n  statementsMap.set(registry.get('for'), statements.parseForStatement);\n  statementsMap.set(registry.get('var'), withEventualSemiColon(statements.parseVariableDeclaration));\n  statementsMap.set(registry.get('const'), withEventualSemiColon(statements.parseConstDeclaration));\n  statementsMap.set(registry.get('let'), withEventualSemiColon(statements.parseLetDeclaration));\n  statementsMap.set(registry.get('function'), parseFunctionDeclaration);\n  statementsMap.set(registry.get('class'), parseClassDeclaration);\n  statementsMap.set(registry.get('return'), withEventualSemiColon(statements.parseReturnStatement));\n  statementsMap.set(registry.get('break'), withEventualSemiColon(statements.parseBreakStatement));\n  statementsMap.set(registry.get('continue'), withEventualSemiColon(statements.parseContinueStatement));\n  statementsMap.set(registry.get('throw'), withEventualSemiColon(statements.parseThrowStatement));\n  statementsMap.set(registry.get('while'), withEventualSemiColon(statements.parseWhileStatement));\n  statementsMap.set(registry.get('do'), withEventualSemiColon(statements.parseDoWhileStatement));\n  statementsMap.set(registry.get('try'), statements.parseTryStatement);\n  statementsMap.set(registry.get('switch'), statements.parseSwitchStatement);\n  statementsMap.set(registry.get('with'), statements.parseWithStatement);\n  statementsMap.set(registry.get('debugger'), withEventualSemiColon(statements.parseDebuggerStatement));\n  statementsMap.set(categories.Identifier, statements.parseExpressionOrLabeledStatement);\n\n  const isLexicallyReserved = registry.isReserved;\n\n  return Object.assign(registry, {\n    getInfix (token) {\n      return infixMap.get(token) || infixMap.get(token.type);\n    },\n    getPrefix (token) {\n      return prefixMap.get(token) || prefixMap.get(token.type);\n    },\n    getStatement (token) {\n      return statementsMap.get(token) || statementsMap.get(token.type);\n    },\n    hasPrefix (token) {\n      return prefixMap.has(token) || prefixMap.has(token.type);\n    },\n    hasInfix (token) {\n      return infixMap.has(token) || infixMap.has(token.type)\n    },\n    hasStatement (token) {\n      return statementsMap.has(token) || statementsMap.has(token.type);\n    },\n    isReserved (token) {\n      return isLexicallyReserved(token.value);\n    },\n    addUnaryOperator (precedence) {\n      return this.addPrefixOperator(precedence, expressions.parseUnaryExpression);\n    },\n    addBinaryOperator (precedence) {\n      return this.addPrefixOperator(precedence, expressions.parseBinaryExpression);\n    },\n    addPrefixOperator (precedence, parseFunction) {\n      throw new Error('not Implemented');\n      return {\n        asPunctuator (symbol) {\n        },\n        asReservedKeyWord (symbol) {\n        },\n        asIdentifierName (symbol) {\n        }\n      };\n    },\n    addInfixOperator (precendence, parseFunction) {\n      throw new Error('not Implemented');\n      return {\n        asPunctuator (symbol) {\n        },\n        asReservedKeyWord (symbol) {\n        },\n        asKeyword (symbol) {\n        }\n      };\n    },\n    addStatement (parseFunction) {\n      throw new Error('not Implemented');\n      return {\n        asReservedKeyWord (symbol) {\n        },\n        asKeyword (symbol) {\n        }\n      };\n    }\n  });\n};\n\nexport default ECMAScriptTokenRegistry();","import {lazyMapWith, lazyFilterWith} from \"../../tokenizer/src/utils\"\nimport {lexemes} from \"../../tokenizer/src/index\";\nimport {default as ECMAScriptTokens} from './tokens';\nimport {default as ECMAScriptScanner} from \"../../tokenizer/src/scanners\"\n\n//forward method of arrity one (more efficient than using spread operator on arguments)\nexport const forwardArrityOne = (receiver, stream, ...methods) => {\n  for (let m of methods) {\n    receiver[m] = (arg) => stream[m](arg);\n  }\n  return receiver;\n};\n\n//a buffered token stream\nconst tokenStream = ({scanner, tokenRegistry, filter, evaluate}) => {\n  const filterFunc = lazyFilterWith(filter || (t => t.type >= 4));\n  const map = lazyMapWith(evaluate || tokenRegistry.evaluate);\n  const filterMap = it => map(filterFunc(it));\n\n  //as generator(only consumed once)\n  return (code) => {\n\n    const stream = lexemes(code, scanner);\n    const iterator = filterMap(stream)[Symbol.iterator]();\n    const buffer = [];\n    let lastLoc;\n\n    const next = () => iterator.next();\n\n    return forwardArrityOne({\n      [Symbol.iterator] () {\n        return this;\n      },\n      lookAhead (offset = 0) {\n        if (buffer.length > offset) {\n          return buffer[offset]\n        }\n        buffer.push(next());\n        return this.lookAhead(offset);\n      },\n      eventually (expected) {\n        const {value: token, done} = this.lookAhead();\n        if (!done && expected === token) {\n          this.eat();\n          return true;\n        }\n        return false;\n      },\n      expect (expected) {\n        const nextToken = this.next();\n        if (expected !== nextToken.value) {\n          throw new Error(`Unexpected token: expected \"${expected.rawValue}\" but got \"${nextToken.value.rawValue}\"`);\n        }\n        return nextToken;\n      },\n      next () {\n        return buffer.length ? buffer.shift() : next();\n      },\n      eat (number = 1) {\n        const n = this.next();\n        number -= 1;\n        return number < 1 ? n : this.eat(number);\n      }\n    }, stream, 'allowRegexp', 'disallowRegexp', 'allowRightBrace', 'disallowRightBrace');\n  };\n};\n\nexport default tokenStream({scanner: ECMAScriptScanner, tokenRegistry: ECMAScriptTokens});","import {default as stream, forwardArrityOne} from './source';\nimport {default as defaultRegistry} from './tokens';\nimport {parseModuleItemList, parseStatementList} from \"./statements\";\nimport {Program} from \"./ast\";\nimport {grammarParams} from \"./utils\";\n\nconst parserFactory = (tokens = defaultRegistry) => {\n\n  const getInfixPrecedence = operator => tokens.hasInfix(operator) ? tokens.getInfix(operator).precedence : -1;\n  const getPrefixPrecedence = operator => tokens.hasPrefix(operator) ? tokens.getPrefix(operator).precedence : -1;\n\n  const parseInfix = (parser, params, left, precedence) => {\n    parser.disallowRegexp(); //regexp as a literal is a \"prefix operator\" so a \"/\" in infix position is a div punctuator\n    const {value: operator} = parser.lookAhead();\n    if (!operator || precedence >= getInfixPrecedence(operator) || (operator === parser.get('in') && !(params & grammarParams.in))) {\n      return left;\n    }\n    parser.eat();\n    parser.allowRegexp();\n    const nextLeft = tokens.getInfix(operator).parse(parser, params, left, operator);\n    return parseInfix(parser, params, nextLeft, precedence);\n  };\n\n  return code => {\n    const tokenStream = stream(code);\n    const parser = Object.assign(forwardArrityOne({\n        expect: symbol => tokenStream.expect(tokens.get(symbol)), //more convenient to have it from the symbol\n        eventually: symbol => tokenStream.eventually(tokens.get(symbol)), //more convenient to have it from the symbol\n        getInfixPrecedence,\n        getPrefixPrecedence,\n        expression (precedence = -1, params = 0) {\n          parser.allowRegexp(); //regexp as literal is a \"prefix operator\"\n          const {value: token} = parser.lookAhead();\n          if (!tokens.hasPrefix(token)) {\n            return null;\n          }\n          const left = tokens.getPrefix(token).parse(parser, params);\n\n          return parseInfix(parser, params, left, precedence);\n        },\n        program () {\n          return Program({\n            body: parseStatementList(parser)\n          });\n        },\n        module () {\n          return Program({\n            sourceType: 'module',\n            body: parseModuleItemList(parser)\n          });\n        },\n      }, tokenStream, 'lookAhead', 'next', 'eat', 'allowRegexp', 'disallowRegexp'),\n      tokens);\n\n    return parser;\n  };\n\n};\n\nexport const parseModule = program => {\n  const parse = parserFactory();\n  return parse(program).module();\n};\n\nexport const parseExpression = (expression) => {\n  const parse = parserFactory();\n  return parse(expression).expression();\n};\n\nexport const parseScript = program => {\n  const parse = parserFactory();\n  return parse(program).program();\n};\n\nexport const parse = parseModule; //alias","import {parseScript} from \"../src/index\";\n\n// const fs = require('fs');\n// const path = require('path');\nconst utils = require('util');\n// const programPath = path.resolve(__dirname, '../../src/statements.js');\n// const program = fs.readFileSync(programPath, {encoding: 'utf8'});\n// const acorn = require('acorn');\n// const cherow = require('cherow');\n\nconst program = `'foo' in {}`;\n// const ast = parseModule(program);\n// const ast = cherow.parse(program, {sourceType: 'script'});\nconst ast = parseScript(program);\nconsole.log(utils.inspect(ast, {depth: null, colors: true}));\n\n/* browser  */\n// (async function  () {\n//    const resp = await fetch('../fixtures/jquery.js');\n//    const text = await resp.text();\n//\n//   const ast = parseScript(text);\n//    // console.log(ast);\n// })();\n/* end browser */\n"],"names":["chars.SINGLE_LINE_COMMENT_START","chars.CHAR_STAR","chars.CHAR_SLASH","chars.MULTI_LINE_COMMENT_START","chars.CHAR_BACKSLASH","chars.CHAR_SINGLE_QUOTE","chars.CHAR_DOUBLE_QUOTE","chars.SPREAD","chars.CHAR_BRACE_CLOSE","chars.CHAR_DOT","chars.CHAR_LEFT_BRACKET","chars.CHAR_RIGHT_BRACKET","chars.CHAR_TEMPLATE_QUOTE","chars.CHAR_DOLLAR","chars.CHAR_BRACE_OPEN","scanner","tokenRegistry","ast.Identifier","ast.UnaryExpression","ast.ThisExpression","ast.Super","ast.Literal","Prefix","ast.UpdateExpression","ast.NewExpression","ast.YieldExpression","Infix","ast.AssignmentExpression","ast.BinaryExpression","ast.LogicalExpression","ast.MemberExpression","ast.ConditionalExpression","ast.SequenceExpression","ast.FunctionExpression","ast.FunctionDeclaration","ast.ArrowFunctionExpression","ast.CallExpression","ast.ImportSpecifier","ast.ImportDefaultSpecifier","ast.ImportNamespaceSpecifier","ast.ImportDeclaration","ast.ExportAllDeclaration","ast.ExportSpecifier","ast.ExportNamedDeclaration","ast.ExportDefaultDeclaration","ast.ExpressionStatement","parseExpression","ast.IfStatement","ast.BlockStatement","ast.EmptyStatement","ast.DebuggerStatement","ast.ReturnStatement","ast.BreakStatement","ast.ContinueStatement","ast.WithStatement","ast.SwitchStatement","ast.SwitchCase","ast.ThrowStatement","ast.TryStatement","ast.WhileStatement","ast.DoWhileStatement","ast.AssignmentPattern","ast.VariableDeclaration","ast.VariableDeclarator","ast.ForStatement","ast.ForInStatement","ast.ForOfStatement","ast.LabeledStatement","expressions.parseUnaryExpression","expressions.parseYieldExpression","expressions.parseUpdateExpressionAsPrefix","expressions.parseLiteralExpression","expressions.parseRegularExpressionLiteral","expressions.parseThisExpression","expressions.parseSuperExpression","expressions.parseIdentifierName","expressions.parseNewExpression","expressions.parseGroupExpression","expressions.parseSequenceExpression","expressions.parseConditionalExpression","expressions.parseEqualAssignmentExpression","expressions.parseAssignmentExpression","expressions.parseBinaryExpression","expressions.parseMemberAccessExpression","expressions.parseLogicalExpression","expressions.parseUpdateExpression","statements.parseIfStatement","statements.parseEmptyStatement","statements.parseBlockStatement","statements.parseForStatement","statements.parseVariableDeclaration","statements.parseConstDeclaration","statements.parseLetDeclaration","statements.parseReturnStatement","statements.parseBreakStatement","statements.parseContinueStatement","statements.parseThrowStatement","statements.parseWhileStatement","statements.parseDoWhileStatement","statements.parseTryStatement","statements.parseSwitchStatement","statements.parseWithStatement","statements.parseDebuggerStatement","statements.parseExpressionOrLabeledStatement","ECMAScriptScanner","defaultRegistry"],"mappings":"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"}