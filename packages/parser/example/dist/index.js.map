{"version":3,"file":"index.js","sources":["../../../tokenizer/src/utils.js","../../../tokenizer/src/source.js","../../../tokenizer/src/tokens.js","../../../tokenizer/src/chars.js","../../../tokenizer/src/scanners.js","../../../tokenizer/src/index.js","../../src/utils.js","../../src/ast.js","../../src/asAssign.js","../../src/array.js","../../src/function.js","../../src/object.js","../../src/class.js","../../src/module.js","../../src/statements.js","../../src/expressions.js","../../src/tokens.js","../../src/source.js","../../src/index.js","../index.js"],"sourcesContent":["export const lazyMapWith = (fn) => function* (iterator) {\n  for (let i of iterator) {\n    yield fn(i);\n  }\n};\n\nexport const lazyFilterWith = fn => function* (iterator) {\n  for (let i of iterator) {\n    if (fn(i)) {\n      yield i;\n    }\n  }\n};\n\nexport const syntacticFlags = {\n  allowRegexp: 1 << 0,\n  allowRightBrace: 1 << 1\n};","//todo put track loc as an option ?\nexport const sourceStream = (code) => {\n  const lineTerminatorRegexp = /[\\u000a\\u000d\\u2028\\u2029]/g;\n  let index = 0;\n  let col = 0;\n  let line = 1;\n\n  const test = (regexp) => nextStretch().search(regexp) === 0;\n  const nextSubStr = (count = 1) => code.substr(index, count);\n  const seeNextAt = (offset = 0) => code[index + offset];\n  const nextStretch = () => nextSubStr(3); //we need three chars to be really sure of the current lexical production (0x3...)\n  const loc = () => ({col, line});\n\n  const advance = (number = 1) => {\n    let lastLineIndex = 0;\n    // console.log(`col: ${col}`);\n    // console.log(`line: ${line}`);\n    const stretch = nextSubStr(number);\n    // console.log(`symbols: ${stretch}`);\n    // console.log('-------')\n    while (lineTerminatorRegexp.test(stretch)) {\n      line += 1;\n      col = 0;\n      lastLineIndex = lineTerminatorRegexp.lastIndex;\n    }\n    col += (number - lastLineIndex);\n    index += number;\n  };\n\n  const stream = {\n    loc,\n    test,\n    nextSubStr,\n    seeNextAt,\n    //advance stream\n    match (regexp) {\n      regexp.lastIndex = index;\n      const [rawValue] = regexp.exec(code);\n      advance(rawValue.length);\n      return rawValue;\n    },\n    //advance stream\n    read (length) {\n      const s = this.nextSubStr(length);\n      advance(length);\n      return s;\n    }\n  };\n\n  Object.defineProperty(stream, 'done', {\n    get () {\n      return code[index] === void 0;\n    }\n  });\n\n  return stream;\n};","export const categories = {\n  WhiteSpace: 0,\n  LineTerminator: 1,\n  SingleLineComment: 2,\n  MultiLineComment: 3,\n  Punctuator: 4,\n  Identifier: 5,\n  NumericLiteral: 6,\n  StringLiteral: 7,\n  RegularExpressionLiteral: 8,\n  Template: 9,\n  TemplateHead: 10,\n  TemplateMiddle: 11,\n  TemplateTail: 12\n};\n\n//defined as keywords\nconst keywords = 'await break case catch class const continue debugger default delete do else export extends finally for function if import in instanceof new return super switch this throw try typeof var void while with yield'.split(' ');\nconst futureReservedKeyword = ['enum'];\nconst reservedKeywords = keywords.concat(futureReservedKeyword, ['null', 'true', 'false']);\n\n//defined as punctuators\nexport const puncutators = `{ ( ) [ ] . ... ; , < > <= >= == != === !== + - * % ** ++ -- << >> >>> & | ^ ! ~ && || ? : = += -= *= %= **= <<= >>= >>>= &= |= ^= => / /= }`.split(' ');\n\nexport const allowRegexpAfter = 'case delete do else in instanceof new return throw typeof void { ( [ . ; , < > <= >= == != === !== + - * << >> >>> & | ^ ! ~ && || ? : = += -= *= %= <<= >>= >>>= &= |= ^= /='.split(' ');\n\nconst createLanguageToken = (symbol, value) => {\n  return Object.freeze(Object.assign(Object.create(null), {\n    type: puncutators.includes(symbol) ? categories.Punctuator : categories.Identifier,\n    value: value !== void  0 ? value : symbol,\n    rawValue: symbol\n  }));\n};\n\n//create a token table\nexport const tokenRegistry = () => {\n  const ecmaScriptTokens = puncutators.concat(keywords, futureReservedKeyword)\n    .map(symbol => ([symbol, createLanguageToken(symbol)]));\n  ecmaScriptTokens.push(['null', createLanguageToken('null', null)]);\n  ecmaScriptTokens.push(['true', createLanguageToken('true', true)]);\n  ecmaScriptTokens.push(['false', createLanguageToken('false', false)]);\n\n  //todo in some context the next tokens can be considered as identifier or identifierName\n  ecmaScriptTokens.push(['of', createLanguageToken('of')]);\n  ecmaScriptTokens.push(['let', createLanguageToken('let')]);\n  ecmaScriptTokens.push(['get', createLanguageToken('get')]);\n  ecmaScriptTokens.push(['set', createLanguageToken('set')]);\n  ecmaScriptTokens.push(['static', createLanguageToken('static')]);\n  ecmaScriptTokens.push(['as', createLanguageToken('as')]);\n  ecmaScriptTokens.push(['from', createLanguageToken('from')]);\n\n  const tokenMap = new Map(ecmaScriptTokens);\n\n  return {\n    get (key) {\n      return tokenMap.get(key)\n    },\n    isReserved(symbol){\n      return reservedKeywords.includes(symbol)\n    },\n    evaluate (lexeme) {\n      if (!tokenMap.has(lexeme.rawValue)) {\n        switch (lexeme.type) {\n          case categories.StringLiteral:\n            return Object.assign(lexeme, {\n              value: lexeme.rawValue.substr(1, lexeme.rawValue.length - 2)\n            });\n          case categories.NumericLiteral:\n            return Object.assign(lexeme, {value: Number(lexeme.rawValue)});\n          case categories.RegularExpressionLiteral:\n            return Object.assign(lexeme, {value: new RegExp(lexeme.pattern, lexeme.flags)});\n          default:\n            return Object.assign(lexeme, {value: lexeme.rawValue});\n        }\n      }\n      return tokenMap.get(lexeme.rawValue);\n    },\n    addToken () {\n      throw new Error('not implemented');\n    }\n  }\n};\n\nexport default tokenRegistry();","export const CHAR_STAR = '*';\nexport const CHAR_SLASH = '/';\nexport const MULTI_LINE_COMMENT_START = '/*';\nexport const SINGLE_LINE_COMMENT_START = '//';\nexport const CHAR_BACKSLASH = '\\\\';\nexport const CHAR_SINGLE_QUOTE = \"'\";\nexport const CHAR_DOUBLE_QUOTE = '\"';\nexport const CHAR_LEFT_BRACKET = '[';\nexport const CHAR_RIGHT_BRACKET = ']';\nexport const CHAR_DOT = '.';\nexport const SPREAD = '...';\nexport const CHAR_TEMPLATE_QUOTE = '`';\nexport const CHAR_DOLLAR = '$';\nexport const CHAR_BRACE_OPEN = '{';\nexport const CHAR_BRACE_CLOSE = '}';","import {\n  categories,\n  puncutators\n} from \"./tokens\";\nimport * as chars from \"./chars\";\nimport {syntacticFlags} from \"./utils\";\n\nconst lexemeFromRegExp = (regExp, category) => sourceStream => ({type: category, rawValue: sourceStream.match(regExp)});\nconst testFromRegExp = regExp => sourceStream => sourceStream.test(regExp);\nconst productionFromRegexp = ({test, lexeme, category}) => () => {\n  //we create regexp dynamically so they are not global to every instance of the scanner\n  const testRegexp = new RegExp(test);\n  const lexemeRegexp = new RegExp(lexeme, 'y');\n  return {\n    test: testFromRegExp(testRegexp),\n    lexeme: lexemeFromRegExp(lexemeRegexp, category)\n  }\n};\n\nexport const numbers = productionFromRegexp({\n  category: categories.NumericLiteral,\n  test: `^(?:[1-9]|\\\\.\\\\d|0[1-9]?|0[xX][0-9a-fA-F]|0[bB][01]|0[oO][0-7])`,\n  lexeme: `0[xX][0-9a-fA-F]+|0[bB][01]+|0[oO][0-7]+|(?:(?:\\\\d+(?:\\\\.\\\\d*)?|\\\\.\\\\d+)(?:[eE][-+]?\\\\d+)?)`\n});\n\nexport const identifiers = productionFromRegexp({\n  category: categories.Identifier,\n  test: `^[$_a-zA-Z]`,\n  lexeme: `[$_a-zA-Z][$\\\\w]*`\n});\n\nexport const whiteSpace = productionFromRegexp({\n  category: categories.WhiteSpace,\n  test: `^(?:[\\\\u0009\\\\u000b\\\\u000c\\\\u0020\\\\u00a0\\\\ufeff])`,\n  lexeme: `[\\\\u0009\\\\u000b\\\\u000c\\\\u0020\\\\u00a0\\\\ufeff]+`\n});\n\nexport const lineTerminator = productionFromRegexp({\n  category: categories.LineTerminator,\n  test: `^(?:[\\\\u000a\\\\u000d\\\\u2028\\\\u2029])`,\n  lexeme: `[\\\\u000a\\\\u000d\\\\u2028\\\\u2029]+`\n});\n\nexport const singleLineComment = () => {\n  const lexemeRegExp = /\\/\\/.*/y;\n  return {\n    test: (sourceStream) => sourceStream.nextSubStr(2) === chars.SINGLE_LINE_COMMENT_START,\n    lexeme: lexemeFromRegExp(lexemeRegExp, categories.SingleLineComment)\n  };\n};\n\nexport const multiLineComment = () => {\n  const lexeme = (sourceStream, count = 2) => {\n    const next = sourceStream.seeNextAt(count);\n    count++;\n    if (next === chars.CHAR_STAR) {\n      const secondNext = sourceStream.seeNextAt(count);\n      if (secondNext === chars.CHAR_SLASH) {\n        return {\n          type: categories.MultiLineComment,\n          rawValue: sourceStream.read(count + 1)\n        }\n      }\n    }\n    return lexeme(sourceStream, count);\n  };\n  return {\n    test (sourceStream) {\n      return sourceStream.nextSubStr(2) === chars.MULTI_LINE_COMMENT_START;\n    },\n    lexeme\n  };\n};\n\nconst fromQuote = quote => {\n  const fn = (sourceStream, count = 1) => {\n    const next = sourceStream.seeNextAt(count);\n    count += 1;\n    if (next === quote) {\n      return {\n        type: categories.StringLiteral,\n        rawValue: sourceStream.read(count)\n      };\n    }\n    if (next === chars.CHAR_BACKSLASH) {\n      count += 1;\n    }\n    return fn(sourceStream, count);\n  };\n  return fn;\n};\nexport const stringLiteral = () => {\n  const singleQuote = fromQuote(chars.CHAR_SINGLE_QUOTE);\n  const doubleQuote = fromQuote(chars.CHAR_DOUBLE_QUOTE);\n  return {\n    test (sourceStream) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_SINGLE_QUOTE || next === chars.CHAR_DOUBLE_QUOTE;\n    },\n    lexeme (sourceStream) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_DOUBLE_QUOTE ? doubleQuote(sourceStream) : singleQuote(sourceStream);\n    }\n  };\n};\n\nexport const punctuators = (punctuatorList = puncutators) => {\n\n  const sizeOnePunctuatorList = punctuatorList.filter(p => p.length === 1);\n  const sizeTwoPunctuatorList = punctuatorList.filter(p => p.length === 2);\n  const sizeThreePunctuatorList = punctuatorList.filter(p => p.length === 3);\n  const sizeFourPunctuatorList = punctuatorList.filter(p => p.length === 4);\n\n  //micro optimization (this function will run often)\n  const isInPunctuatorList = (str) => {\n    switch (str.length) {\n      case 2:\n        return sizeTwoPunctuatorList.includes(str);\n      case 3:\n        return sizeThreePunctuatorList.includes(str);\n      case 4:\n        return sizeFourPunctuatorList.includes(str);\n      default:\n        return false;\n    }\n  };\n  const lexeme = (sourceStream, count = 1) => {\n    const nextStretch = sourceStream.nextSubStr(count + 1);\n    if (!isInPunctuatorList(nextStretch) || nextStretch.length !== count + 1 /*End of file */) {\n      return {\n        type: categories.Punctuator,\n        rawValue: sourceStream.read(count)\n      };\n    }\n    return lexeme(sourceStream, count + 1);\n  };\n  const lexemeFromDot = sourceStream => ({\n    type: categories.Punctuator,\n    rawValue: (sourceStream.nextSubStr(3) === chars.SPREAD) ? sourceStream.read(3) : sourceStream.read(1)\n  });\n  return {\n    test (sourceStream, context) {\n      const next = sourceStream.seeNextAt();\n      switch (next) {\n        case chars.CHAR_SLASH:\n          return ~context & syntacticFlags.allowRegexp;\n        case chars.CHAR_BRACE_CLOSE:\n          return context & syntacticFlags.allowRightBrace;\n        default:\n          return sizeOnePunctuatorList.includes(next);\n      }\n    },\n    lexeme: sourceStream => sourceStream.seeNextAt() === chars.CHAR_DOT ? lexemeFromDot(sourceStream) : lexeme(sourceStream)\n  };\n};\n\nconst scanRegExpBody = (sourceStream, count = 1) => {\n  const next = sourceStream.seeNextAt(count);\n  count += 1;\n  switch (next) {\n    case chars.CHAR_SLASH:\n      return count;\n    case chars.CHAR_LEFT_BRACKET: {\n      // slash are \"escaped\" in a regexp class\n      count = scanRegExpClass(sourceStream, count);//+1\n      break;\n    }\n    case chars.CHAR_BACKSLASH: {\n      count += 1;\n      break;\n    }\n  }\n  return scanRegExpBody(sourceStream, count);\n};\nconst scanRegExpClass = (sourceStream, count) => {\n  const next = sourceStream.seeNextAt(count);\n  count += 1;\n  switch (next) {\n    case chars.CHAR_RIGHT_BRACKET:\n      return count;\n    case chars.CHAR_BACKSLASH:\n      count += 1\n  }\n  return scanRegExpClass(sourceStream, count);\n};\n\nconst identifierPart = /[$\\w]/;\nconst scanRegExpFlags = (sourceStream, count) => {\n  const next = sourceStream.seeNextAt(count);\n  if (!next || !identifierPart.test(next)) {\n    return count;\n  }\n  return scanRegExpFlags(sourceStream, count + 1);\n};\n\nexport const regularExpression = () => {\n  return {\n    test (sourceStream, context) {\n      const next = sourceStream.seeNextAt();\n      return (context & syntacticFlags.allowRegexp) && next === chars.CHAR_SLASH;\n    },\n    lexeme (sourceStream) {\n      const body = scanRegExpBody(sourceStream);\n      const withFlags = scanRegExpFlags(sourceStream, body);\n      const rawValue = sourceStream.read(withFlags);\n      return {\n        type: categories.RegularExpressionLiteral,\n        rawValue,\n        pattern: rawValue.substr(1, body - 2),\n        flags: rawValue.substr(body, withFlags - body)\n      };\n    }\n  };\n};\n\nconst templateOrPart = (onExit = categories.Template, onFollow = categories.TemplateHead) => {\n  const fn = (sourceStream, count = 1) => {\n    const next = sourceStream.seeNextAt(count);\n    count += 1;\n    if (next === chars.CHAR_TEMPLATE_QUOTE) {\n      return {\n        type: onExit,\n        rawValue: sourceStream.read(count)\n      };\n    }\n\n    if (next === chars.CHAR_DOLLAR && sourceStream.seeNextAt(count) === chars.CHAR_BRACE_OPEN) {\n      return {\n        type: onFollow,\n        rawValue: sourceStream.read(count + 1)\n      };\n    }\n\n    if (next === chars.CHAR_BACKSLASH) {\n      count += 1;\n    }\n\n    return fn(sourceStream, count);\n\n  };\n  return fn;\n};\nconst headOrTemplate = templateOrPart();\nexport const templateHeadOrLiteral = () => {\n  return {\n    test (sourceStream) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_TEMPLATE_QUOTE;\n    },\n    lexeme (sourceStream) {\n      return headOrTemplate(sourceStream);\n    }\n  };\n};\n\nconst middleOrTail = templateOrPart(categories.TemplateTail, categories.TemplateMiddle);\nexport const templateTailOrMiddle = () => {\n  return {\n    test (sourceStream, context) {\n      const next = sourceStream.seeNextAt();\n      return next === chars.CHAR_BRACE_CLOSE && (~context & syntacticFlags.allowRightBrace);\n    },\n    lexeme (sourceStream) {\n      return middleOrTail(sourceStream);\n    }\n  }\n};\n\nexport const ECMAScriptLexicalGrammar = [\n  whiteSpace,\n  lineTerminator,\n  numbers,\n  singleLineComment,\n  multiLineComment,\n  punctuators,\n  identifiers,\n  regularExpression,\n  stringLiteral,\n  templateHeadOrLiteral,\n  templateTailOrMiddle\n];\n\nexport const scanner = (lexicalRules = ECMAScriptLexicalGrammar.map(g => g())) => {\n  return (source, context) => {\n    const rule = lexicalRules.find(lr => lr.test(source, context));\n    if (rule === void 0) {\n      throw new Error(`could not understand the symbol ${source.seeNextAt()}`);\n    }\n    return rule.lexeme(source);\n  };\n};\n\nexport default scanner();\n","import {sourceStream} from \"./source\";\nimport {allowRegexpAfter, categories} from \"./tokens\";\nimport {syntacticFlags, lazyFilterWith, lazyMapWith} from \"./utils\";\nimport {default as defaultScanner} from './scanners';\nimport {default as defaultRegistry} from './tokens';\n\n/* Note\n\nwe could greatly improve perf by directly yielding filtered (and evaluated token?) at the scanner level instead of passing every lexeme through a lazy stream combinators pipe chain,\nhowever we would lost the great flexibility we have here !\n\nfor example if we simply ignored white space, line terminators, etc.\nour filter combinator would have to run much less (at least for big files)\n\nbottom line: we value more modularity and flexibility of the system over performance\n\ntodo: later we can give ability to the consumer to configure the scanner to perform better\n\n*/\n\n\n//return an iterable sequence of lexemes (note it can only be consumed once like a generator)\n//The consumer (like a parser) will have to handle the syntactic state and the token evaluation by itself\nexport const lexemes = (code, scanner) => {\n  let context = syntacticFlags.allowRegexp | syntacticFlags.allowRightBrace;\n  let previousContext = context;\n  const source = sourceStream(code);\n  const holdContext = fn => _ => {\n    previousContext = context;\n    fn();\n  };\n  return {\n    * [Symbol.iterator] () {\n      while (true) {\n        if (source.done === true) {\n          return;\n        }\n        yield scanner(source, context);\n      }\n    },\n    restoreContext () {\n      context = previousContext\n    },\n    allowRegexp: holdContext(() => {\n      context |= syntacticFlags.allowRegexp;\n    }),\n    disallowRegexp: holdContext(() => {\n      context &= ~syntacticFlags.allowRegexp;\n    }),\n    allowRightBrace: holdContext(() => { // as punctuator vs template middle/tail\n      context |= syntacticFlags.allowRightBrace;\n    }),\n    disallowRightBrace: holdContext(() => {\n      context &= ~syntacticFlags.allowRightBrace;\n    }),\n    loc () {\n      return source.loc();\n    }\n  }\n};\n\nlet defaultFilter = t => t.type >= 4;\nconst defaultOptions = {\n  scanner: defaultScanner,\n  tokenRegistry: defaultRegistry,\n  evaluate: defaultRegistry.evaluate,\n  filter: defaultFilter\n};\n\n// a standalone tokenizer (ie uses some heuristics based on the last meaningful token to know how to scan a slash)\n// https://stackoverflow.com/questions/5519596/when-parsing-javascript-what-determines-the-meaning-of-a-slash\nexport const tokenize = function* (code, {scanner = defaultScanner, tokenRegistry = defaultRegistry, filter, evaluate} = defaultOptions) {\n  const filterFunc = lazyFilterWith(filter || defaultFilter);\n  const mapFunc = lazyMapWith(evaluate || tokenRegistry.evaluate);\n  const filterMap = iter => mapFunc(filterFunc(iter));\n  const stream = lexemes(code, scanner);\n\n  let substitutionStack = []; //pending braces\n\n  for (let t of filterMap(stream)) {\n    yield t;\n    //meaningful tokens\n    if (Object.is(t.type, t) || t.type >= 4) {\n\n      //heuristic for regexp context\n      if (allowRegexpAfter.includes(t.rawValue)) {\n        stream.allowRegexp();\n      } else {\n        stream.disallowRegexp();\n      }\n\n      //template literal substitution\n      if (t.type === categories.TemplateHead || t.type === categories.TemplateMiddle) {\n        substitutionStack.push(0);\n        stream.disallowRightBrace();\n        stream.allowRegexp();\n      } else if (t.type === categories.TemplateTail) {\n        substitutionStack.pop();\n      }\n\n      //without context we need to backtrack braces\n      if (substitutionStack.length) {\n\n        const lastSubstitutionIndex = substitutionStack.length - 1;\n\n        if (t.rawValue === '{') {\n          substitutionStack[lastSubstitutionIndex] = substitutionStack[lastSubstitutionIndex] + 1;\n          stream.allowRightBrace();\n        }\n\n        if (t.rawValue === '}') {\n          let pending = substitutionStack[lastSubstitutionIndex] = substitutionStack[lastSubstitutionIndex] - 1;\n          if (pending === 0) {\n            stream.disallowRightBrace();\n          }\n        }\n      }\n    }\n  }\n};","export const withEventualSemiColon = (fn) => (parser, params) => {\n  const node = fn(parser, params);\n  parser.eventually(';');\n  return node;\n};\nexport const composeArityTwo = (factory, fn) => (a, b) => factory(fn(a, b));\nexport const composeArityOne = (factory, fn) => _ => factory(fn(_));\nexport const composeArityThree = (factory, fn) => (a, b, c) => factory(fn(a, b, c));\nexport const composeArityFour = (factory, fn) => (a, b, c, d) => factory(fn(a, b, c, d));\n\n// these are to forward parameters to grammar production rules ([?yield], [+in], etc)\nexport const grammarParams = {\n  yield: 1 << 0,\n  await: 1 << 1,\n  in: 1 << 2,\n  return: 1 << 3,\n  default: 1 << 4\n};\n","const nodeFactory = (defaultOrType, proto = null) => {\n  const defaultObj = typeof defaultOrType === 'string' ? {type: defaultOrType} : defaultOrType;\n  //todo return obj => Object.assign(Object.create(proto), defaultObj, obj);\n  return obj => Object.assign(defaultObj, obj);\n};\n\nconst yieldArgument = {\n  * [Symbol.iterator] () {\n    yield this.argument;\n  }\n};\nconst yieldLeftRight = {\n  * [Symbol.iterator] () {\n    yield this.left;\n    yield this.right;\n  }\n};\nconst yieldExpression = {\n  * [Symbol.iterator] () {\n    yield this.expression;\n  }\n};\nconst delegateBody = {\n  * [Symbol.iterator] () {\n    yield* this.body;\n  }\n};\nconst delegateElements = {\n  * [Symbol.iterator] () {\n    yield* this.elements;\n  }\n};\nconst delegateProperties = {\n  * [Symbol.iterator] () {\n    yield* this.properties;\n  }\n};\nconst iterateFunction = {\n  * [Symbol.iterator] () {\n    yield this.id;\n    yield* this.params;\n    yield this.body;\n  }\n};\nconst iterateCall = {\n  * [Symbol.iterator] () {\n    yield this.callee;\n    yield* this.arguments;\n  }\n};\nconst iterateProperty = {\n  * [Symbol.iterator] () {\n    yield this.key;\n    yield this.value;\n  }\n};\nconst iterateCondition = {\n  * [Symbol.iterator] () {\n    yield this.test;\n    yield this.consequent;\n    yield this.alternate;\n  }\n};\n\n//pefix nodes\nexport const UnaryExpression = nodeFactory('UnaryExpression', yieldArgument);\nexport const ThisExpression = nodeFactory('ThisExpression');\nexport const Super = nodeFactory('Super');\nexport const Literal = nodeFactory('Literal');\nexport const Identifier = nodeFactory('Identifier');\nexport const UpdateExpression = nodeFactory('UpdateExpression', yieldArgument);\nexport const FunctionExpression = nodeFactory({\n  type: 'FunctionExpression',\n  id: null,\n  async: false,\n  generator: false\n}, iterateFunction);\nexport const ClassExpression = nodeFactory('ClassExpression', delegateBody);\nexport const NewExpression = nodeFactory('NewExpression', iterateCall);\nexport const SpreadElement = nodeFactory('SpreadElement', yieldArgument);\nexport const ArrayExpression = nodeFactory('ArrayExpression', delegateElements);\nexport const ObjectExpression = nodeFactory('ObjectExpression', delegateProperties);\nexport const Property = nodeFactory({\n  type: 'Property',\n  shorthand: false,\n  computed: false,\n  kind: 'init',\n  method: false,\n  value: null\n}, iterateProperty);\nexport const YieldExpression = nodeFactory({type: 'YieldExpression', delegate: false}, yieldArgument);\n\n//infix nodes\nconst asBinary = type => nodeFactory(type, yieldLeftRight);\nexport const AssignmentExpression = asBinary('AssignmentExpression');\nexport const BinaryExpression = asBinary('BinaryExpression');\nexport const LogicalExpression = asBinary('LogicalExpression');\nexport const MemberExpression = nodeFactory('MemberExpression', {\n  * [Symbol.iterator] () {\n    yield this.object;\n    yield this.property;\n  }\n});\nexport const ConditionalExpression = nodeFactory('ConditionalExpression', iterateCondition);\nexport const CallExpression = nodeFactory('CallExpression', iterateCall);\nexport const SequenceExpression = nodeFactory('SequenceExpression', {\n  * [Symbol.iterator] () {\n    yield* this.expressions;\n  }\n});\nexport const ArrowFunctionExpression = nodeFactory({\n  type: 'ArrowFunctionExpression',\n  expression: true,\n  async: false,\n  generator: false,\n  id: null\n}, iterateFunction);\n\n//statements nodes\nexport const IfStatement = nodeFactory('IfStatement', iterateCondition);\nexport const BlockStatement = nodeFactory('BlockStatement', delegateBody);\nexport const ExpressionStatement = nodeFactory('ExpressionStatement', yieldExpression);\nexport const EmptyStatement = nodeFactory('EmptyStatement');\nexport const DebuggerStatement = nodeFactory('DebuggerStatement');\nconst withArgument = (type) => nodeFactory(type, yieldArgument);\nexport const ReturnStatement = withArgument('ReturnStatement');\nexport const BreakStatement = withArgument('BreakStatement');\nexport const ContinueStatement = withArgument('ContinueStatement');\n\nexport const WithStatement = nodeFactory('WithStatement', {\n  * [Symbol.iterator] () {\n    yield this.object;\n    yield this.body;\n  }\n});\nexport const SwitchStatement = nodeFactory('SwitchStatement', {\n  * [Symbol.iterator] () {\n    yield this.discriminant;\n    yield* this.cases;\n  }\n});\nexport const SwitchCase = nodeFactory('SwitchCase', {\n  * [Symbol.iterator] () {\n    yield this.test;\n    yield* this.consequent;\n  }\n});\nexport const ThrowStatement = nodeFactory('ThrowStatement', yieldExpression);\nexport const TryStatement = nodeFactory('TryStatement', {\n  * [Symbol.iterator] () {\n    yield this.block;\n    yield this.handler;\n    yield this.finalizer;\n  }\n});\nexport const CatchClause = nodeFactory('CatchClause', {\n  * [Symbol.iterator] () {\n    yield this.param;\n    yield this.body;\n  }\n});\nexport const WhileStatement = nodeFactory('WhileStatement', {\n  * [Symbol.iterator] () {\n    yield this.test;\n    yield this.body;\n  }\n});\nexport const DoWhileStatement = nodeFactory('DoWhileStatement', {\n  * [Symbol.iterator] () {\n    yield this.body;\n    yield this.test;\n  }\n});\nexport const ForInStatement = nodeFactory('ForInStatement', yieldLeftRight);\nexport const ForStatement = nodeFactory('ForStatement', {\n  * [Symbol.iterator] () {\n    yield this.init;\n    yield this.test;\n    yield this.update;\n  }\n});\nexport const ForOfStatement = nodeFactory('ForOfStatement', yieldLeftRight);\nexport const LabeledStatement = nodeFactory('LabeledStatement', {\n  * [Symbol.iterator] () {\n    yield this.body;\n  }\n});\n\nexport const Program = nodeFactory({type: 'Program', sourceType: 'script'}, delegateBody);\n\n//declarations\nexport const AssignmentPattern = nodeFactory('AssignmentPattern', yieldLeftRight);\nexport const FunctionDeclaration = nodeFactory({\n  type: 'FunctionDeclaration',\n  async: false,\n  generator: false\n}, iterateFunction);\nexport const VariableDeclarator = nodeFactory('VariableDeclarator', {\n  * [Symbol.iterator] () {\n    yield this.id;\n    yield this.init;\n  }\n});\nexport const VariableDeclaration = nodeFactory('VariableDeclaration', {\n  * [Symbol.iterator] () {\n    yield* this.declarations;\n  }\n});\nexport const ArrayPattern = nodeFactory('ArrayPattern', delegateElements);\nexport const RestElement = nodeFactory('RestElement', yieldArgument);\nexport const ObjectPattern = nodeFactory('ObjectPattern', delegateProperties);\nexport const Class = nodeFactory('ClassDeclaration', {\n  * [Symbol.iterator] () {\n    yield this.id;\n    yield this.superClass;\n    yield this.body;\n  }\n});\nexport const ClassBody = nodeFactory('ClassBody', delegateBody);\nexport const MethodDefinition = nodeFactory('MethodDefinition', iterateProperty);\n\n//modules\nexport const ImportDeclaration = nodeFactory('ImportDeclaration', {\n  * [Symbol.iterator] () {\n    yield* this.specifiers;\n    yield this.source;\n  }\n});\nexport const ImportSpecifier = nodeFactory('ImportSpecifier', {\n  * [Symbol.iterator] () {\n    yield this.imported;\n    yield this.local;\n  }\n});\nexport const ImportDefaultSpecifier = nodeFactory('ImportDefaultSpecifier', {\n  * [Symbol.iterator] () {\n    yield this.local;\n  }\n});\nexport const ImportNamespaceSpecifier = nodeFactory('ImportNamespaceSpecifier', {\n  * [Symbol.iterator] () {\n    yield this.local;\n  }\n});\nexport const ExportNamedDeclaration = nodeFactory({\n  type: 'ExportNamedDeclaration',\n  specifiers: [],\n  declaration: null,\n  source: null\n}, {\n  * [Symbol.iterator] () {\n    yield this.declaration;\n    yield* this.specifiers;\n    yield this.source;\n  }\n});\nexport const ExportSpecifier = nodeFactory('ExportSpecifier', {\n  * [Symbol.iterator] () {\n    yield this.local;\n    yield this.exported;\n  }\n});\nexport const ExportDefaultDeclaration = nodeFactory({type: 'ExportDefaultDeclaration', specifiers: [], source: null}, {\n  * [Symbol.iterator] () {\n    yield this.declaration;\n  }\n});\nexport const ExportAllDeclaration = nodeFactory('ExportAllDeclaration', {\n  * [Symbol.iterator] () {\n    yield this.source;\n  }\n});\n\n//walk & traverse\nexport function* traverse (node) {\n  yield node;\n  if (node && node[Symbol.iterator]) {\n    for (let child of node) {\n      yield* traverse(child);\n    }\n  }\n}\n\nexport const visitWithAncestors = visitor => node => {\n\n};\nexport const visit = (...visitors) => {\n  const aggregatedVisitor = visitors.reduce((acc, curr) => {\n    for (let nodeType of Object.keys(curr)) {\n      const fns = acc[nodeType] || [];\n      fns.push(curr[nodeType]);\n      acc[nodeType] = fns;\n    }\n    return acc;\n  }, {});\n\n  return node => {\n    for (let n of traverse(node)) {\n      if (n) {\n        if (aggregatedVisitor[n.type]) {\n          for (let vfunc of aggregatedVisitor[n.type]) {\n            vfunc(n);\n          }\n        }\n      }\n    }\n  };\n};\n\n","/*\n this convert a node initially parsed as a literal (likely object or array) to an assignment pattern\n this will mutate node and its descendant to match the new grammar used\n it occurs in cases where we have parsed as literal first and then encounter a token (such \"=\" which actually indicates the literal was a pattern)\n example:\n\n let a = 3,b =4;\n [a,b] = [b,a];\n\n we don't know we have a assignment pattern until we reach the \"=\" token\n\n */\nexport const toAssignable = node => {\n\n  if (node === null) {\n    return node;\n  }\n\n  switch (node.type) {\n    case 'ArrayPattern':\n    case 'ObjectPattern':\n    case 'AssignmentPattern':\n    case 'RestElement':\n    case 'Identifier':\n      break; //skip\n    case 'ArrayExpression':\n      node.type = 'ArrayPattern';\n      for (let ch of node) {\n        toAssignable(ch); //recursive descent\n      }\n      break;\n    case 'ObjectExpression':\n      node.type = 'ObjectPattern';\n      for (let prop of node) {\n        if (prop.kind !== 'init' || prop.method) {\n          throw new Error('can not convert property as a destructuring pattern');\n        }\n        toAssignable(prop.value);\n      }\n      break;\n    case 'SpreadElement':\n      node.type = 'RestElement';\n      toAssignable(node.argument);\n      break;\n    case 'AssignmentExpression':\n      if (node.operator !== '=') {\n        throw new Error('can not reinterpret assignment expression with operator different than \"=\"');\n      }\n      node.type = 'AssignmentPattern';\n      delete node.operator;// operator is not relevant for assignment pattern\n      toAssignable(node.left);// recursive descent\n      break;\n    default:\n      throw new Error(`Unexpected node could not parse \"${node.type}\" as part of a destructuring pattern `);\n  }\n  return node;\n};","import {ArrayExpression, ArrayPattern, RestElement, SpreadElement} from \"./ast\";\nimport {composeArityOne, composeArityTwo, grammarParams} from \"./utils\";\nimport {parseAssignmentPattern, parseBindingIdentifierOrPattern} from \"./statements\";\n\n// \"array\" parsing is shared across various components:\n// - as array literals\n// - as array pattern\nexport const parseRestElement = composeArityTwo(RestElement, (parser, params) => {\n  parser.expect('...');\n  return {\n    argument: parseBindingIdentifierOrPattern(parser, params)\n  };\n});\nexport const parseSpreadExpression = composeArityTwo(SpreadElement, (parser, params) => {\n  parser.expect('...');\n  return {\n    argument: parser.expression(parser.getPrefixPrecedence(parser.get('...'), params | grammarParams.in))\n  };\n});\n\nconst parseArrayElision = (parser, elements) => {\n  const {value: next} = parser.lookAhead();\n\n  if (next !== parser.get(',')) {\n    return elements;\n  }\n\n  elements.push(null);\n  parser.eat();\n\n  return parseArrayElision(parser, elements);\n};\nconst arrayElements = (parseEllipsis, process) => {\n  const fn = (parser, params, elements = []) => {\n    const {value: next} = parser.lookAhead();\n    const comma = parser.get(',');\n\n    if (next === parser.get(']')) {\n      return elements;\n    }\n\n    if (next === parser.get('...')) {\n      elements.push(parseEllipsis(parser, params));\n      parser.eventually(',');\n      return fn(parser, params, elements);\n    }\n\n    if (next === comma) {\n      parseArrayElision(parser, elements);\n      return fn(parser, params, elements);\n    }\n\n    process(parser, params, elements);\n\n    return fn(parser, params, elements);\n  };\n  return fn;\n};\nconst parseArrayElements = arrayElements(parseSpreadExpression, (parser, params, elements) => {\n  elements.push(parser.expression(parser.getInfixPrecedence(parser.get(',')), params | grammarParams.in));\n  parser.eventually(',');\n});\nconst parseArrayElementsBindingPattern = arrayElements(parseRestElement, (parser, params, elements) => {\n  let element = parseBindingIdentifierOrPattern(parser, params);\n  if (parser.eventually('=')) {\n    element = parseAssignmentPattern(parser, params | grammarParams.in, element);\n  }\n  elements.push(element);\n  parser.eventually(',');\n});\n\nexport const parseArrayBindingPattern = composeArityTwo(ArrayPattern, (parser, params) => {\n  parser.expect('[');\n  const node = {\n    elements: parseArrayElementsBindingPattern(parser, params)\n  };\n  parser.expect(']');\n  return node;\n});\nexport const parseArrayLiteralExpression = composeArityTwo(ArrayExpression, (parser, params) => {\n  parser.expect('[');\n  const node = {\n    elements: parseArrayElements(parser, params)\n  };\n  parser.expect(']');\n  return node;\n});","import * as ast from './ast';\nimport {\n  parseBlockStatement, parseBindingIdentifier, parseBindingElement\n} from \"./statements\";\nimport {composeArityThree, composeArityTwo, grammarParams} from \"./utils\";\nimport {parseSpreadExpression, parseRestElement} from \"./array\";\nimport {toAssignable} from \"./asAssign\";\nimport {categories} from \"../../tokenizer/src/tokens\";\nimport {parsePropertyName} from \"./object\";\n\n// \"function\" parsing is shared across multiple components and deserves its own module to mutualize code more easily:\n// - as statement aka function declaration\n// - as expression\n// - as arrow function (expression)\n// - as method (within object or class body)\n// - as function call\n\nconst getNewParams = (asGenerator, params) => {\n  let newParams = params;\n  if (asGenerator) {\n    newParams |= grammarParams.yield;\n    newParams &= ~grammarParams.await;\n  } else {\n    newParams &= ~(grammarParams.yield | grammarParams.await);\n  }\n  return newParams;\n};\n\nexport const parseFormalParameterList = (parser, params, paramList = []) => {\n  const {value: next} = parser.lookAhead();\n\n  if (next === parser.get(')')) {\n    return paramList;\n  }\n\n  if (next === parser.get('...')) {\n    paramList.push(parseRestElement(parser, params));\n    return paramList; //rest parameter must be the last\n  }\n\n  if (parser.eventually(',')) {\n    if (parser.eventually(',')) {\n      throw new Error('Elision not allowed in function parameters');\n    }\n  } else {\n    paramList.push(parseBindingElement(parser, params));\n  }\n\n  return parseFormalParameterList(parser, params, paramList);\n};\nexport const asPropertyFunction = (parser, params, prop) => {\n  parser.expect('(');\n  const paramList = parseFormalParameterList(parser, params);\n  parser.expect(')');\n  const body = parseBlockStatement(parser, params);\n  return Object.assign(prop, {\n    value: ast.FunctionExpression({\n      params: paramList,\n      body\n    })\n  });\n};\nexport const parseClassMethod = composeArityTwo(ast.MethodDefinition, (parser, params) => {\n  const isStatic = parser.eventually('static');\n  const asGenerator = parser.eventually('*');\n  const newParams = getNewParams(asGenerator, params);\n\n  const {value: next} = parser.lookAhead();\n  const {value: secondNext} = parser.lookAhead(1);\n  let kind = 'method';\n\n  if ((next === parser.get('get') || next === parser.get('set')) && secondNext !== parser.get('(')) {\n    const {value: accessor} = parser.eat();\n    kind = accessor.value;\n  }\n\n  const prop = parsePropertyName(parser, params);\n  kind = prop.key.name === 'constructor' ? 'constructor' : kind;\n  return Object.assign(asPropertyFunction(parser, newParams, prop), {static: isStatic, kind});\n});\n\nconst parseParamsAndBody = (parser, params) => {\n  parser.expect('(');\n  const paramList = parseFormalParameterList(parser, params);\n  parser.expect(')');\n  const body = parseBlockStatement(parser, params | grammarParams.return);\n  return {params: paramList, body};\n};\n\nexport const parseFunctionDeclaration = composeArityTwo(ast.FunctionDeclaration, (parser, params) => {\n  parser.expect('function');\n  const generator = parser.eventually('*');\n  const id = parseBindingIdentifier(parser, params);\n  const newParams = getNewParams(generator, params);\n  return Object.assign({\n    id,\n    generator\n  }, parseParamsAndBody(parser, newParams));\n});\n\n//that is a prefix expression\nexport const parseFunctionExpression = composeArityTwo(ast.FunctionExpression, (parser, params) => {\n  parser.expect('function');\n  const generator = parser.eventually('*');\n  let id = null;\n  const {value: nextToken} = parser.lookAhead();\n  const newParams = getNewParams(generator, params);\n  if (nextToken.type === categories.Identifier) {\n    id = parseBindingIdentifier(parser, newParams);\n  }\n  return Object.assign({id, generator}, parseParamsAndBody(parser, newParams));\n});\n\n//arrow function\nconst asFormalParameters = (node) => {\n  if (node === null) {\n    return [];\n  }\n  return node.type === 'SequenceExpression' ? [...node].map(toAssignable) : [toAssignable(node)];\n};\nexport const parseArrowFunctionExpression = composeArityThree(ast.ArrowFunctionExpression, (parser, params, left) => {\n  const paramList = asFormalParameters(left, params);\n  const newParams = getNewParams(false, params);\n  const {value: next} = parser.lookAhead();\n  const body = next === parser.get('{') ? parseBlockStatement(parser, newParams | grammarParams.return) : parser.expression(-1, newParams);\n  return {\n    params: paramList,\n    body\n  };\n});\n\n//function call\n//that is an infix expression\nconst parseFunctionCallArguments = (parser, params, expressions = []) => {\n  const {value: next} = parser.lookAhead();\n  const comma = parser.get(',');\n\n  if (next === parser.get(')')) {\n    return expressions;\n  }\n\n  if (next === parser.get('...')) {\n    expressions.push(parseSpreadExpression(parser, params));\n  } else if (parser.eventually(',')) {\n    if (parser.eventually(',')) {\n      throw new Error('no elision allowed in function call parameters');\n    }\n  } else {\n    expressions.push(parser.expression(parser.getInfixPrecedence(comma), params | grammarParams.in));\n  }\n  return parseFunctionCallArguments(parser, params, expressions);\n};\n\nexport const parseCallExpression = composeArityThree(ast.CallExpression, (parser, params, callee) => {\n  const node = {\n    callee,\n    arguments: parseFunctionCallArguments(parser, params)\n  };\n  parser.expect(')');\n  return node;\n});","import {Property, ObjectExpression, ObjectPattern, Identifier} from \"./ast\";\nimport {composeArityTwo, grammarParams} from \"./utils\";\nimport {categories} from \"../../tokenizer/src/tokens\";\nimport {parseBindingIdentifier, parseIdentifierName} from \"./statements\";\nimport {asPropertyFunction} from \"./function\";\nimport {parseBindingIdentifierOrPattern, parseAssignmentPattern} from \"./statements\";\n\n// \"object\" parsing is shared across various components:\n// - as object literals\n// - as object pattern\n// - within class bodies as well\n\nconst asPropertyList = (parseDefinition) => {\n  const fn = (parser, params, properties = []) => {\n    const {value: nextToken} = parser.lookAhead();\n    if (nextToken === parser.get('}')) {\n      return properties;\n    }\n\n    if (parser.eventually(',')) {\n      if (parser.eventually(',')) {\n        throw new Error('Elision not allowed in object property list');\n      }\n    } else {\n      properties.push(parseDefinition(parser, params));\n    }\n    return fn(parser, params, properties);\n  };\n  return fn;\n};\nconst parseComputedPropertyName = (parser, params) => {\n  parser.expect('[');\n  const key = parser.expression(-1, params | grammarParams.in);\n  parser.expect(']');\n  return {\n    key,\n    computed: true\n  };\n};\nconst parseLiteralPropertyName = (parser, params) => ({key: parser.expression(20, params), computed: false});// max precedence => a literal or an identifier or a keyword\n\nexport const parsePropertyName = (parser, params) => {\n  const {value: next} = parser.lookAhead();\n  return next === parser.get('[') ?\n    parseComputedPropertyName(parser, params) :\n    parseLiteralPropertyName(parser, params);\n};\nconst parseWithValue = (parser, params, prop) => {\n  prop = prop !== void 0 ? prop : parsePropertyName(parser, params);\n  const {value: next} = parser.lookAhead();\n  if (next === parser.get('(')) {\n    //method\n    return asPropertyFunction(parser, params, Object.assign(prop, {method: true}));\n  } else if (next === parser.get(':')) {\n    //with initializer\n    parser.expect(':');\n    return Object.assign(prop, {\n      value: parser.expression(parser.getInfixPrecedence(parser.get(',')), params | grammarParams.in)\n    });\n  }\n  throw new Error(`Unexpected token: expected \":\" or \"(\" but got ${next.rawValue}`);\n};\nconst parsePropertyDefinition = composeArityTwo(Property, (parser, params) => {\n  let {value: next} = parser.lookAhead();\n  let prop;\n  const {value: secondNext} = parser.lookAhead(1);\n\n  //binding reference\n  if (next.type === categories.Identifier) {\n    if ((secondNext === parser.get(',') || secondNext === parser.get('}'))) {\n      const key = parseBindingIdentifier(parser, params);\n      return {\n        shorthand: true,\n        key,\n        value: key\n      };\n    }\n    //cover Initialized grammar https://tc39.github.io/ecma262/#prod-CoverInitializedName\n    if (secondNext === parser.get('=')) {\n      const key = parseBindingIdentifier(parser, params);\n      const value = parseAssignmentPattern(parser, params, key);\n      return {\n        shorthand: true,\n        key,\n        value\n      };\n    }\n  }\n\n  //can be a getter/setter or a shorthand binding or a property with init...\n  if (next === parser.get('get') || next === parser.get('set')) {\n    const {value: accessor} = parser.next();\n    const {value: next} = parser.lookAhead();\n\n    if (next !== parser.get('(') && next !== parser.get(':')) {\n      prop = Object.assign(parsePropertyName(parser, params), {kind: accessor.rawValue});\n      return asPropertyFunction(parser, params, prop);\n    }\n\n    prop = {\n      key: Identifier({name: accessor.value})\n    };\n  }\n\n  return parseWithValue(parser, params, prop);\n});\nconst parsePropertyList = asPropertyList(parsePropertyDefinition);\nexport const parseObjectLiteralExpression = composeArityTwo(ObjectExpression, (parser, params) => {\n  parser.expect('{');\n  const node = {\n    properties: parsePropertyList(parser, params)\n  };\n  parser.expect('}');\n  return node;\n});\n\nconst parseSingleNameBindingProperty = (parser, params) => {\n  const key = parseIdentifierName(parser, params);\n  const shorthand = !parser.eventually(':');\n  let value = shorthand ? key : parseBindingIdentifierOrPattern(parser, params);\n  if (parser.eventually('=')) {\n    value = parseAssignmentPattern(parser, params | grammarParams.in, value);\n  }\n  return {shorthand, key, value};\n};\nconst parsePropertyNameProperty = (parser, params) => {\n  const property = parsePropertyName(parser, params);\n  parser.expect(':');\n  return Object.assign(property, {\n    value: parseBindingIdentifierOrPattern(parser, params)\n  });\n};\nconst parseBindingProperty = (parser, params) => {\n  const {value: next} = parser.lookAhead();\n  const property = Property({});\n  return next.type === categories.Identifier && parser.isReserved(next) === false ? //identifier but not reserved word\n    Object.assign(property, parseSingleNameBindingProperty(parser, params)) :\n    Object.assign(property, parsePropertyNameProperty(parser, params));\n};\nconst parseBindingPropertyList = asPropertyList(parseBindingProperty);\nexport const parseObjectBindingPattern = composeArityTwo(ObjectPattern, (parser, params) => {\n  parser.expect('{');\n  const node = {\n    properties: parseBindingPropertyList(parser, params)\n  };\n  parser.expect('}');\n  return node;\n});","import {ClassBody, ClassExpression, Class} from \"./ast\";\nimport {composeArityTwo} from \"./utils\";\nimport {parseBindingIdentifier} from \"./statements\";\nimport {categories} from \"../../tokenizer/src/tokens\";\nimport {parseClassMethod} from \"./function\";\n\nconst parseClassElementList = (parser, params, elements = []) => {\n  const {value: next} = parser.lookAhead();\n  if (next === parser.get('}')) {\n    return elements;\n  }\n\n  if (!parser.eventually(';')) {\n    elements.push(parseClassMethod(parser, params));\n  }\n\n  return parseClassElementList(parser, params, elements);\n};\nexport const parseClassBody = composeArityTwo(ClassBody, (parser, params) => {\n  parser.expect('{');\n  const node = {\n    body: parseClassElementList(parser, params)\n  };\n  parser.expect('}');\n  return node;\n});\n\nconst parseClassTail = (parser, params, id) => {\n  const superClass = parser.eventually('extends') ? parser.expression(-1, params) : null;\n  return {\n    id,\n    superClass,\n    body: parseClassBody(parser, params)\n  };\n};\n\nexport const parseClassDeclaration = composeArityTwo(Class, (parser, params) => {\n  parser.expect('class');\n  const id = parseBindingIdentifier(parser, params);\n  return parseClassTail(parser, params, id);\n});\nexport const parseClassExpression = composeArityTwo(ClassExpression, (parser, params) => {\n  parser.expect('class');\n  let id = null;\n  const {value: next} = parser.lookAhead();\n  if (next.type === categories.Identifier && next !== parser.get('extends')) {\n    id = parseBindingIdentifier(parser);\n  }\n  return parseClassTail(parser, params, id);\n});","import * as ast from './ast';\nimport {categories} from \"../../tokenizer/src/tokens\";\nimport {composeArityTwo, grammarParams} from \"./utils\";\nimport {parseLiteralExpression} from \"./expressions\";\nimport {\n  parseBindingIdentifier,\n  parseIdentifierName,\n  parseConstDeclaration,\n  parseLetDeclaration,\n  parseVariableDeclaration\n} from \"./statements\";\nimport {parseFunctionDeclaration} from \"./function\";\nimport {parseClassDeclaration} from \"./class\";\n\nconst getNewParams = params => params & ~(grammarParams.yield | grammarParams.await);\nconst parseNamedImport = (parser, params, specifiers) => {\n  const {value: next} = parser.lookAhead();\n\n  if (next === parser.get('}')) {\n    return specifiers;\n  }\n\n  const imported = parseIdentifierName(parser, getNewParams(params));\n  let hasAs = false;\n  if (parser.isReserved(next)) {\n    parser.expect('as');\n    hasAs = true;\n  } else {\n    hasAs = parser.eventually('as');\n  }\n\n  const local = hasAs ? parseBindingIdentifier(parser, getNewParams(params)) : imported;\n\n  specifiers.push(ast.ImportSpecifier({\n    local,\n    imported\n  }));\n\n  if (parser.eventually(',')) { // elision is not allowed\n    const {value: next} = parser.lookAhead();\n    if (next === parser.get('}')) {\n      return specifiers;\n    }\n  }\n\n  return parseNamedImport(parser, params, specifiers);\n};\nconst parseImportDefaultSpecifier = (parser, params, specifiers) => {\n  specifiers.push(ast.ImportDefaultSpecifier({\n    local: parseBindingIdentifier(parser, params)\n  }));\n  return specifiers;\n};\nconst parseImportNamespaceSpecifier = (parser, params, specifiers) => {\n  parser.expect('*');\n  parser.expect('as');\n  specifiers.push(ast.ImportNamespaceSpecifier({\n    local: parseBindingIdentifier(parser, params)\n  }));\n  return specifiers;\n};\nconst parseImportClause = (parser, params, specifiers = []) => {\n  const {value: next} = parser.lookAhead();\n  if (next.type === categories.Identifier) {\n\n    parseImportDefaultSpecifier(parser, params, specifiers);\n\n    if (parser.eventually(',')) {\n      const {value: next} = parser.lookAhead();\n\n      if (next === parser.get('*')) {\n        return parseImportNamespaceSpecifier(parser, params, specifiers);\n      } else if (next === parser.get('{')) {\n        parser.expect('{');\n        parseNamedImport(parser, params, specifiers);\n        parser.expect('}');\n      } else {\n        throw new Error(`expected \"{\" or \"*\"`);\n      }\n    }\n    return specifiers;\n  }\n\n  if (next === parser.get('*')) {\n    return parseImportNamespaceSpecifier(parser, params, specifiers);\n  }\n\n  parser.expect('{');\n  parseNamedImport(parser, params, specifiers);\n  parser.expect('}');\n  return specifiers;\n};\nconst parseFromClause = (parser, params) => {\n  parser.expect('from');\n  const {value: next} = parser.lookAhead();\n  if (next.type !== categories.StringLiteral) {\n    throw new Error('Expected a string literal');\n  }\n  return parseLiteralExpression(parser, params);\n};\n\nexport const parseImportDeclaration = composeArityTwo(ast.ImportDeclaration, (parser, params) => {\n  parser.expect('import');\n  const {value: next} = parser.lookAhead();\n  if (next.type === categories.StringLiteral) {\n    return {\n      specifiers: [],\n      source: parseLiteralExpression(parser, params)\n    };\n  }\n  const specifiers = parseImportClause(parser, params);\n  const source = parseFromClause(parser, params);\n  return {\n    source,\n    specifiers\n  };\n});\n\nconst parseExportAllDeclaration = composeArityTwo(ast.ExportAllDeclaration, (parser, params) => {\n  parser.expect('*');\n  return {\n    source: parseFromClause(parser, params)\n  };\n});\nconst parseNamedExportDeclaration = (parser, params, specifiers = []) => {\n  const {value: next} = parser.lookAhead();\n\n  if (next === parser.get('}')) {\n    return specifiers;\n  }\n\n  const local = parseIdentifierName(parser, params);\n  const exported = parser.eventually('as') ? parseIdentifierName(parser, params) : local;\n\n  specifiers.push(ast.ExportSpecifier({\n    local,\n    exported\n  }));\n\n  if (parser.eventually(',')) { // elision is not allowed\n    const {value: next} = parser.lookAhead();\n    if (next === parser.get('}')) {\n      return specifiers;\n    }\n  }\n\n  return parseNamedExportDeclaration(parser, params, specifiers);\n};\nconst parseExportAsDeclaration = (fn) => composeArityTwo(ast.ExportNamedDeclaration, (parser, params) => ({\n  declaration: fn(parser, params)\n}));\nconst parseExportAsDefaultDeclaration = (fn) => composeArityTwo(ast.ExportDefaultDeclaration, (parser, params) => ({\n  declaration: fn(parser, params)\n}));\nexport const parseExportDeclaration = (parser, params) => {\n  parser.expect('export');\n  const {value: next} = parser.lookAhead();\n  switch (next) {\n    case parser.get('*'):\n      return parseExportAllDeclaration(parser, params);\n    case parser.get('{'): {\n      parser.expect('{');\n      const node = ast.ExportNamedDeclaration({\n        specifiers: parseNamedExportDeclaration(parser, params)\n      });\n      parser.expect('}');\n      const {value: next} = parser.lookAhead();\n      node.source = next === parser.get('from') ? parseFromClause(parser, params) : null;\n      return node;\n    }\n    case parser.get('var'):\n      return parseExportAsDeclaration(parseVariableDeclaration)(parser, getNewParams(params));\n    case parser.get('const'):\n      return parseExportAsDeclaration(parseConstDeclaration)(parser, getNewParams(params));\n    case parser.get('let'):\n      return parseExportAsDeclaration(parseLetDeclaration)(parser, getNewParams(params));\n    case parser.get('function'):\n      return parseExportAsDeclaration(parseFunctionDeclaration)(parser, getNewParams(params));\n    case parser.get('class'):\n      return parseExportAsDeclaration(parseClassDeclaration)(parser, getNewParams(params));\n    case parser.get('default'): {\n      parser.expect('default');\n      const {value: next} = parser.lookAhead();\n      switch (next) {\n        case parser.get('function'):\n          return parseExportAsDefaultDeclaration(parseFunctionDeclaration)(parser, getNewParams(params));\n        case parser.get('class'):\n          return parseExportAsDefaultDeclaration(parseClassDeclaration)(parser, getNewParams(params));\n        default:\n          return parseExportAsDefaultDeclaration((parser, params) => parser.expression(-1, getNewParams(params) & grammarParams.in))(parser, params);\n      }\n    }\n    default:\n      throw new Error('Unknown export statement');\n  }\n\n};","import * as ast from './ast';\nimport {composeArityThree, composeArityTwo, grammarParams, withEventualSemiColon} from \"./utils\";\nimport {parseArrayBindingPattern} from \"./array\";\nimport {parseObjectBindingPattern} from \"./object\";\nimport {parseExportDeclaration, parseImportDeclaration} from \"./module\";\nimport {categories} from \"../../tokenizer/src/tokens\";\nimport {toAssignable} from \"./asAssign\";\n\n// statements\n// Note: Function declarations,class declarations, array and object binding pattern are in they own files\n\n// statement list and blocks\nconst needToBreak = (parser, nextToken) => !(parser.hasStatement(nextToken) || parser.hasPrefix(nextToken)) || nextToken === parser.get('case') || nextToken === parser.get('default');\nexport const parseStatementList = (parser, params, statements = []) => {\n  const {done, value: nextToken} = parser.lookAhead();\n  // we break if stream is done or next token does not imply a statement\n  // note1: we check for expression statement as well by checking whether the next token matches an expression prefix\n  // note2: we break on \"case\" and \"default\" as well as they can't be used to start a new Statement, neither a Declaration neither an identifier in expression\n  if (done || needToBreak(parser, nextToken)) {\n    return statements;\n  }\n  statements.push(parseStatement(parser, params));\n  return parseStatementList(parser, params, statements);\n};\nexport const parseBlockStatement = composeArityTwo(ast.BlockStatement, (parser, params) => {\n  parser.expect('{');\n  const node = {\n    body: parseStatementList(parser, params)\n  };\n  parser.expect('}');\n  return node;\n});\nexport const parseStatement = (parser, params) => {\n  const {value: nextToken} = parser.lookAhead();\n  const isReturnAsExpression = (nextToken === parser.get('return') && !(params & grammarParams.return));\n  if (!parser.hasStatement(nextToken) || isReturnAsExpression) {\n    return parseExpression(parser, params);\n  }\n  let newParams = params;\n  switch (nextToken) {\n    case parser.get('function'):\n    case parser.get('class'):\n    case parser.get('async'):\n      newParams &= ~grammarParams.default;\n      break;\n    case parser.get('let'):\n    case parser.get('const'):\n      newParams |= grammarParams.in;\n      break;\n  }\n  const statement = parser.getStatement(nextToken);\n  return statement(parser, newParams);\n};\n\n// module highest level statements\nconst parseImport = withEventualSemiColon(parseImportDeclaration);\nconst parseExport = withEventualSemiColon(parseExportDeclaration);\nexport const parseModuleItemList = (parser, params, items = []) => {\n  const {done, value: nextToken} = parser.lookAhead();\n\n  if (done) {\n    return items;\n  }\n\n  switch (nextToken) {\n    case parser.get('import'):\n      items.push(parseImport(parser, params));\n      break;\n    case parser.get('export'):\n      items.push(parseExport(parser, params));\n      break;\n    default:\n      items.push(parseStatement(parser, params));\n  }\n  return parseModuleItemList(parser, params, items);\n};\n\n// variables\nconst parseVariableDeclarator = composeArityTwo(ast.VariableDeclarator, (parser, params) => {\n  const comma = parser.get(',');\n  const node = {id: parseBindingIdentifierOrPattern(parser, params), init: null};\n  if (parser.eventually('=')) {\n    node.init = parser.expression(parser.getInfixPrecedence(comma), params);\n  }\n  return node;\n});\nconst parseVariableDeclarators = (parser, params, declarators = []) => {\n  const node = parseVariableDeclarator(parser, params);\n  const comma = parser.get(',');\n  const {value: nextToken} = parser.lookAhead();\n\n  declarators.push(node);\n\n  if (nextToken !== comma) {\n    return declarators;\n  }\n  parser.eat();\n  return parseVariableDeclarators(parser, params, declarators);\n};\nconst variableDeclaration = (keyword = 'var') => {\n  const modifier = keyword === 'var' ? grammarParams.in : 0;\n  return composeArityTwo(ast.VariableDeclaration, (parser, params) => {\n    parser.expect(keyword);\n    return {\n      kind: keyword,\n      declarations: parseVariableDeclarators(parser, params | modifier)\n    };\n  });\n};\nexport const parseVariableDeclaration = variableDeclaration('var');\nexport const parseConstDeclaration = variableDeclaration('const');\nexport const parseLetDeclaration = variableDeclaration('let');\n\nexport const parseEmptyStatement = parser => {\n  parser.expect(';');\n  return ast.EmptyStatement();\n};\n\n// expression\nexport const parseExpressionStatement = composeArityTwo(ast.ExpressionStatement, (parser, params) => ({\n  expression: parser.expression(-1, params | grammarParams.in)\n}));\nconst parseExpression = withEventualSemiColon(parseExpressionStatement);\n\nexport const parseIfStatement = composeArityTwo(ast.IfStatement, (parser, params) => {\n  parser.expect('if');\n  parser.expect('(');\n  const test = parser.expression(-1, params | grammarParams.in);\n  parser.expect(')');\n  const consequent = parseStatement(parser, params);\n  let alternate = null;\n  if (parser.eventually('else')) {\n    alternate = parseStatement(parser, params);\n  }\n  return {\n    test,\n    consequent,\n    alternate\n  };\n});\n\nexport const parseExpressionOrLabeledStatement = (parser, params) => {\n  const {value: nextToken} = parser.lookAhead(1);\n  return nextToken === parser.get(':') ? parseLabeledStatement(parser, params) : parseExpression(parser, params);\n};\n\nexport const parseDoWhileStatement = composeArityTwo(ast.DoWhileStatement, (parser, params) => {\n  parser.expect('do');\n  const node = {\n    body: parseStatement(parser, params)\n  };\n  parser.expect('while');\n  parser.expect('(');\n  node.test = parser.expression(-1, params | grammarParams.in);\n  parser.expect(')');\n  return node;\n});\n\nexport const parseWhileStatement = composeArityTwo(ast.WhileStatement, (parser, params) => {\n  parser.expect('while');\n  parser.expect('(');\n  const node = {\n    test: parser.expression(-1, params | grammarParams.in)\n  };\n  parser.expect(')');\n  node.body = parseStatement(parser, params);\n  return node;\n});\n\n//for\nconst getForDerivation = parser => {\n  const {value: nextToken} = parser.lookAhead();\n  switch (nextToken) {\n    case parser.get('in'):\n      return asForIn;\n    case parser.get('of'):\n      return asForOf;\n    default:\n      return asFor;\n  }\n};\nconst asFor = composeArityThree(ast.ForStatement, (parser, params, init) => {\n  parser.expect(';');\n  const n = {\n    init,\n    test: parser.expression(-1, params | grammarParams.in)\n  };\n  parser.expect(';');\n  n.update = parser.expression(-1, params | grammarParams.in);\n  return n;\n});\nconst asForIn = composeArityThree(ast.ForInStatement, (parser, params, left) => {\n  parser.expect('in');\n  return {\n    left,\n    right: parser.expression(-1, params | grammarParams.in)\n  };\n});\nconst asForOf = composeArityThree(ast.ForOfStatement, (parser, params, left) => {\n  parser.expect('of');\n  return {\n    left,\n    right: parser.expression(-1, params | grammarParams.in)\n  };\n});\nconst getForLeftSide = (parser, params) => {\n  const {value: nextToken} = parser.lookAhead();\n  switch (nextToken) {\n    case parser.get('var'):\n    case parser.get('const'):\n    case parser.get('let'):\n      return variableDeclaration(nextToken.value)(parser, params & ~grammarParams.in);\n  }\n  return parser.expression(-1, params & ~grammarParams.in);\n};\nexport const parseForStatement = (parser, params) => {\n  parser.expect('for');\n  parser.expect('(');\n  const startExpression = getForLeftSide(parser, params);\n  const derivation = getForDerivation(parser);\n  const node = derivation(parser, params, startExpression);\n  parser.expect(')');\n  node.body = parseStatement(parser, params);\n  return node;\n};\n\n//switch\nconst parseCaseClause = composeArityTwo(ast.SwitchCase, (parser, params) => {\n  parser.expect('case');\n  const test = parser.expression(-1, params | grammarParams.in);\n  parser.expect(':');\n  return {\n    test,\n    consequent: parseStatementList(parser, params)\n  };\n});\nconst parseDefaultClause = composeArityTwo(ast.SwitchCase, (parser, params) => {\n  parser.expect('default');\n  parser.expect(':');\n  return {\n    test: null,\n    consequent: parseStatementList(parser, params)\n  };\n});\nexport const parseSwitchCases = (parser, params, cases = []) => {\n  const {value: nextToken} = parser.lookAhead();\n\n  if (nextToken === parser.get('}')) {\n    return cases;\n  }\n\n  if (nextToken === parser.get('default')) {\n    cases.push(parseDefaultClause(parser, params));\n    return cases;\n  }\n\n  cases.push(parseCaseClause(parser, params));\n  return parseSwitchCases(parser, params, cases);\n};\nexport const parseSwitchStatement = composeArityTwo(ast.SwitchStatement, (parser, params) => {\n  parser.expect('switch');\n  parser.expect('(');\n  const discriminant = parser.expression(-1, params | grammarParams.in);\n  parser.expect(')');\n  parser.expect('{');\n  const cases = parseSwitchCases(parser, params);\n  parser.expect('}');\n  return {\n    discriminant,\n    cases\n  };\n});\n\nconst parseLabelIdentifier = composeArityTwo(ast.Identifier, (parser, params) => {\n  const newParams = params & ~(grammarParams.yield | grammarParams.await);\n  return parseBindingIdentifier(parser, newParams);\n});\nconst withLabel = (keyword, factory) => composeArityTwo(factory, (parser, params) => {\n  parser.expect(keyword);\n  const {value: next} = parser.lookAhead();\n  const label = parser.hasPrefix(next) ? parseLabelIdentifier(parser, params) : null;\n  return {\n    label\n  };\n});\nexport const parseLabeledStatement = composeArityTwo(ast.LabeledStatement, (parser, params) => {\n  const node = {\n    label: parseLabelIdentifier(parser, params)\n  };\n  parser.expect(':');\n  node.body = parseStatement(parser, params & ~grammarParams.default);\n  return node;\n});\nexport const parseBreakStatement = withLabel('break', ast.BreakStatement);\nexport const parseContinueStatement = withLabel('continue', ast.ContinueStatement);\n\nexport const parseReturnStatement = composeArityTwo(ast.ReturnStatement, (parser, params) => {\n  parser.expect('return');\n  return {\n    argument: parser.expression(-1, params | grammarParams.in)\n  };\n});\n\nexport const parseWithStatement = composeArityTwo(ast.WithStatement, (parser, params) => {\n  parser.expect('with');\n  parser.expect('(');\n  const object = parser.expression(-1, params | grammarParams.in);\n  parser.expect(')');\n  return {\n    object,\n    body: parseStatement(parser, params)\n  };\n});\n\nexport const parseThrowStatement = composeArityTwo(ast.ThrowStatement, (parser, params) => {\n  parser.expect('throw');\n  return {\n    argument: parser.expression(-1, params | grammarParams.in)\n  };\n});\n\nexport const parseTryStatement = composeArityTwo(ast.TryStatement, (parser, params) => {\n  parser.expect('try');\n  const node = {block: parseBlockStatement(parser, params), handler: null, finalizer: null};\n  if (parser.eventually('catch')) {\n    const handler = {type: 'CatchClause'};\n    parser.expect('(');\n    handler.param = parseBindingIdentifierOrPattern(parser, params);\n    parser.expect(')');\n    handler.body = parseBlockStatement(parser, params);\n    node.handler = handler;\n  }\n  if (parser.eventually('finally')) {\n    node.finalizer = parseBlockStatement(parser);\n  }\n  return node;\n});\n\nexport const parseDebuggerStatement = parser => {\n  parser.expect('debugger');\n  return ast.DebuggerStatement();\n};\n\n// identifiers and bindings\nexport const parseBindingElement = (parser, params) => {\n  const binding = parseBindingIdentifierOrPattern(parser, params);\n  if (parser.eventually('=')) {\n    return ast.AssignmentPattern({\n      left: binding,\n      right: parser.expression(-1, params | grammarParams.in)\n    });\n  }\n  return binding;\n};\nexport const parseBindingIdentifierOrPattern = (parser, params) => {\n  const {value: next} = parser.lookAhead();\n  if (next === parser.get('[')) {\n    return parseArrayBindingPattern(parser, params);\n  } else if (next === parser.get('{')) {\n    return parseObjectBindingPattern(parser, params);\n  }\n  return parseBindingIdentifier(parser, params);\n};\nexport const parseBindingIdentifier = composeArityTwo(ast.Identifier, (parser, params) => {\n  const identifier = parseIdentifierName(parser, params);\n  if (parser.isReserved(identifier.name)) {\n    throw new Error(`can not use reseved word  ${identifier.name} as binding identifier`);\n  }\n  return identifier;\n});\nexport const parseIdentifierName = composeArityTwo(ast.Identifier, (parser, params) => {\n  const {value: next} = parser.lookAhead();\n  if (next.type !== categories.Identifier) {\n    throw new Error('expected an identifier');\n  }\n  parser.eat();\n  return {\n    name: next.value\n  };\n});\nexport const parseAssignmentPattern = composeArityThree(ast.AssignmentPattern, (parser, params, left) => ({\n  left,\n  right: parser.expression(parser.getInfixPrecedence(parser.get(',')), params)\n}));","import {\n  composeArityOne,\n  composeArityThree,\n  composeArityTwo,\n  composeArityFour, grammarParams\n} from \"./utils\";\nimport * as ast from \"./ast\";\nimport {toAssignable} from \"./asAssign\";\nimport {parseIdentifierName} from \"./statements\";\n\n// expressions based on Javascript operators whether they are \"prefix\" or \"infix\"\n// Note: Functions and Class expressions, Object literals and Array literals are in their own files\n\n//prefix\nconst asValue = (type, key) => composeArityOne(type, (parser) => {\n  const {value: token} = parser.next();\n  return key ? {[key]: token.value} : {};\n});\nconst asUnaryExpression = (type) => composeArityTwo(type, (parser, params) => {\n  const {value: token} = parser.next();\n  return {\n    operator: token.value,\n    argument: parser.expression(parser.getPrefixPrecedence(token), params),\n    prefix: true\n  };\n});\nexport const parseGroupExpression = (parser, params) => {\n  parser.expect('(');\n  const exp = parser.expression(-1, params);\n  parser.expect(')');\n  return exp;\n};\nexport const parseUnaryExpression = asUnaryExpression(ast.UnaryExpression);\nexport const parseThisExpression = asValue(ast.ThisExpression);\nexport const parseSuperExpression = asValue(ast.Super);\nexport const parseLiteralExpression = asValue(ast.Literal, 'value');\nexport const parseRegularExpressionLiteral = composeArityOne(ast.Literal, parser => {\n  const {value: regexp} = parser.next();\n  return {\n    value: regexp.value,\n    regex: {\n      pattern: regexp.value.source,\n      flags: regexp.value.flags\n    }\n  };\n});\nexport const parseUpdateExpressionAsPrefix = asUnaryExpression(ast.UpdateExpression);\nexport const parseNewExpression = composeArityTwo(ast.NewExpression, (parser, params) => {\n  const {value: newToken} = parser.expect('new');\n  const callee = parser.expression(parser.getPrefixPrecedence(newToken), params);\n  return {\n    callee: callee.callee ? callee.callee : callee,\n    arguments: callee.arguments ? callee.arguments : []\n  };\n});\nexport const parseYieldExpression = (parser, params) => {\n  if (params & grammarParams.yield) {\n    parser.expect('yield');\n    const delegate = parser.eventually('*');\n    return ast.YieldExpression({\n      argument: parser.expression(parser.getPrefixPrecedence(parser.get('yield')), params),\n      delegate\n    });\n  }\n  return parseIdentifierName(parser, params);\n};\n\n//infix\nconst asBinaryExpression = type => composeArityFour(type, (parser, params, left, operator) => {\n  return {\n    left,\n    right: parser.expression(parser.getInfixPrecedence(operator), params),\n    operator: operator.value\n  };\n});\nexport const parseEqualAssignmentExpression = composeArityFour(ast.AssignmentExpression, (parser, params, left, operator) => {\n  const {type} = left;\n  if (type === 'ArrayExpression' || type === 'ObjectExpression') {\n    toAssignable(left);\n  }\n  return {\n    left,\n    right: parser.expression(parser.getInfixPrecedence(operator), params),\n    operator: operator.value\n  };\n});\nexport const parseAssignmentExpression = asBinaryExpression(ast.AssignmentExpression);\nexport const parseBinaryExpression = asBinaryExpression(ast.BinaryExpression);\nexport const parseLogicalExpression = asBinaryExpression(ast.LogicalExpression);\nexport const parseMemberAccessExpression = composeArityFour(ast.MemberExpression, (parser, params, left, operator) => {\n  const computed = operator === parser.get('[');\n  const node = {\n    object: left,\n    computed: computed,\n    property: computed ? parser.expression(-1, params | grammarParams.in) : parseIdentifierName(parser)\n  };\n  if (computed) {\n    parser.expect(']');\n  }\n  return node;\n});\nexport const parseUpdateExpression = composeArityFour(ast.UpdateExpression, (parser, params, left, operator) => ({\n  argument: left,\n  operator: operator.value,\n  prefix: false\n}));\nexport const parseConditionalExpression = composeArityThree(ast.ConditionalExpression, (parser, params, test) => {\n  const node = {\n    test\n  };\n  const commaPrecedence = parser.getInfixPrecedence(parser.get(','), params);\n  node.consequent = parser.expression(commaPrecedence, params | grammarParams.in);\n  parser.expect(':');\n  node.alternate = parser.expression(commaPrecedence, params);\n  return node;\n});\nexport const parseSequenceExpression = composeArityThree(ast.SequenceExpression, (parser,params, left) => {\n  let node = left;\n  const comma = parser.get(',');\n  const next = parser.expression(parser.getInfixPrecedence(comma));\n  if (left.type === 'SequenceExpression') {\n    left.expressions.push(next);\n  } else {\n    node = {\n      expressions: [left, next]\n    };\n  }\n  return node;\n});","import {tokenRegistry, categories} from \"../../tokenizer/src/tokens\";\nimport * as expressions from './expressions';\nimport * as statements from './statements';\nimport {parseArrayLiteralExpression, parseSpreadExpression} from \"./array\";\nimport {parseObjectLiteralExpression} from \"./object\";\nimport {parseClassDeclaration, parseClassExpression} from \"./class\";\nimport {\n  parseFunctionExpression, parseFunctionDeclaration, parseCallExpression,\n  parseArrowFunctionExpression\n} from \"./function\";\nimport {withEventualSemiColon} from \"./utils\";\nimport {parseIdentifierName} from \"./statements\";\n\nexport const ECMAScriptTokenRegistry = () => {\n  const registry = tokenRegistry();\n\n  /**\n   * EXPRESSIONS\n   */\n\n  const prefixMap = new Map();\n  //unary operators\n  prefixMap.set(registry.get('-'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('+'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('!'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('~'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('typeof'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('void'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('delete'), {parse: expressions.parseUnaryExpression, precedence: 16});\n  prefixMap.set(registry.get('...'), {parse: parseSpreadExpression, precedence: 1});\n  prefixMap.set(registry.get('yield'), {parse: expressions.parseYieldExpression, precedence: 2});\n  //update operators\n  prefixMap.set(registry.get('--'), {parse: expressions.parseUpdateExpressionAsPrefix, precedence: 16});\n  prefixMap.set(registry.get('++'), {parse: expressions.parseUpdateExpressionAsPrefix, precedence: 16});\n  //literals\n  prefixMap.set(categories.StringLiteral, {parse: expressions.parseLiteralExpression, precedence: -1});\n  prefixMap.set(categories.NumericLiteral, {parse: expressions.parseLiteralExpression, precedence: -1});\n  prefixMap.set(categories.RegularExpressionLiteral, {\n    parse: expressions.parseRegularExpressionLiteral,\n    precedence: -1\n  });\n  prefixMap.set(registry.get('null'), {parse: expressions.parseLiteralExpression, precedence: -1});\n  prefixMap.set(registry.get('false'), {parse: expressions.parseLiteralExpression, precedence: -1});\n  prefixMap.set(registry.get('true'), {parse: expressions.parseLiteralExpression, precedence: -1});\n  // prefixMap.set(categories.Template, {parse: expressions.parseTemplateLiteral, precedence: -1});\n  // prefixMap.set(categories.TemplateHead, {parse: expressions.parseTemplateLiteral, precedence: -1});\n  prefixMap.set(registry.get('['), {parse: parseArrayLiteralExpression, precedence: -1});\n  prefixMap.set(registry.get('{'), {parse: parseObjectLiteralExpression, precedence: -1});\n  //identifiers\n  prefixMap.set(registry.get('this'), {parse: expressions.parseThisExpression, precedence: -1});\n  prefixMap.set(registry.get('super'), {parse: expressions.parseSuperExpression, precedence: -1});\n  prefixMap.set(categories.Identifier, {parse: parseIdentifierName, precedence: -1});\n  //functions\n  prefixMap.set(registry.get('function'), {parse: parseFunctionExpression, precedence: -1});\n  prefixMap.set(registry.get('class'), {parse: parseClassExpression, precedence: -1});\n  prefixMap.set(registry.get('new'), {parse: expressions.parseNewExpression, precedence: 18});\n  //group\n  prefixMap.set(registry.get('('), {parse: expressions.parseGroupExpression, precedence: 20});\n\n  const infixMap = new Map();\n  //sequence\n  infixMap.set(registry.get(','), {parse: expressions.parseSequenceExpression, precedence: 0});\n  //conditional\n  infixMap.set(registry.get('?'), {parse: expressions.parseConditionalExpression, precedence: 4});\n  //assignment operators\n  infixMap.set(registry.get('='), {parse: expressions.parseEqualAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('+='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('-='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('*='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('/='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('%='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('<<='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('>>='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('>>>='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('&='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('^='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('|='), {parse: expressions.parseAssignmentExpression, precedence: 3});\n  infixMap.set(registry.get('=>'), {parse: parseArrowFunctionExpression, precedence: 21}); // fake precedence of 21\n  //binary operators\n  infixMap.set(registry.get('=='), {parse: expressions.parseBinaryExpression, precedence: 10});\n  infixMap.set(registry.get('!='), {parse: expressions.parseBinaryExpression, precedence: 10});\n  infixMap.set(registry.get('==='), {parse: expressions.parseBinaryExpression, precedence: 10});\n  infixMap.set(registry.get('!=='), {parse: expressions.parseBinaryExpression, precedence: 10});\n  infixMap.set(registry.get('<'), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('<='), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('>'), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('>='), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('in'), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('instanceof'), {parse: expressions.parseBinaryExpression, precedence: 11});\n  infixMap.set(registry.get('<<'), {parse: expressions.parseBinaryExpression, precedence: 12});\n  infixMap.set(registry.get('>>'), {parse: expressions.parseBinaryExpression, precedence: 12});\n  infixMap.set(registry.get('>>>'), {parse: expressions.parseBinaryExpression, precedence: 12});\n  infixMap.set(registry.get('+'), {parse: expressions.parseBinaryExpression, precedence: 13});\n  infixMap.set(registry.get('-'), {parse: expressions.parseBinaryExpression, precedence: 13});\n  infixMap.set(registry.get('*'), {parse: expressions.parseBinaryExpression, precedence: 14});\n  infixMap.set(registry.get('/'), {parse: expressions.parseBinaryExpression, precedence: 14});\n  infixMap.set(registry.get('%'), {parse: expressions.parseBinaryExpression, precedence: 14});\n  infixMap.set(registry.get('**'), {parse: expressions.parseBinaryExpression, precedence: 15});\n  infixMap.set(registry.get('|'), {parse: expressions.parseBinaryExpression, precedence: 7});\n  infixMap.set(registry.get('^'), {parse: expressions.parseBinaryExpression, precedence: 8});\n  infixMap.set(registry.get('&'), {parse: expressions.parseBinaryExpression, precedence: 9});\n  //member access operator\n  infixMap.set(registry.get('.'), {parse: expressions.parseMemberAccessExpression, precedence: 19});\n  infixMap.set(registry.get('['), {parse: expressions.parseMemberAccessExpression, precedence: 19});\n  //logical operators\n  infixMap.set(registry.get('||'), {parse: expressions.parseLogicalExpression, precedence: 5});\n  infixMap.set(registry.get('&&'), {parse: expressions.parseLogicalExpression, precedence: 6});\n  //update operators\n  infixMap.set(registry.get('++'), {parse: expressions.parseUpdateExpression, precedence: 17});\n  infixMap.set(registry.get('--'), {parse: expressions.parseUpdateExpression, precedence: 17});\n  //call\n  infixMap.set(registry.get('('), {parse: parseCallExpression, precedence: 19});\n\n  /**\n   * STATEMENTS\n   */\n\n  const statementsMap = new Map();\n  statementsMap.set(registry.get('if'), statements.parseIfStatement);\n  statementsMap.set(registry.get(';'), statements.parseEmptyStatement);\n  statementsMap.set(registry.get('{'), statements.parseBlockStatement);\n  statementsMap.set(registry.get('for'), statements.parseForStatement);\n  statementsMap.set(registry.get('var'), withEventualSemiColon(statements.parseVariableDeclaration));\n  statementsMap.set(registry.get('const'), withEventualSemiColon(statements.parseConstDeclaration));\n  statementsMap.set(registry.get('let'), withEventualSemiColon(statements.parseLetDeclaration));\n  statementsMap.set(registry.get('function'), parseFunctionDeclaration);\n  statementsMap.set(registry.get('class'), parseClassDeclaration);\n  statementsMap.set(registry.get('return'), withEventualSemiColon(statements.parseReturnStatement));\n  statementsMap.set(registry.get('break'), withEventualSemiColon(statements.parseBreakStatement));\n  statementsMap.set(registry.get('continue'), withEventualSemiColon(statements.parseContinueStatement));\n  statementsMap.set(registry.get('throw'), withEventualSemiColon(statements.parseThrowStatement));\n  statementsMap.set(registry.get('while'), withEventualSemiColon(statements.parseWhileStatement));\n  statementsMap.set(registry.get('do'), withEventualSemiColon(statements.parseDoWhileStatement));\n  statementsMap.set(registry.get('try'), statements.parseTryStatement);\n  statementsMap.set(registry.get('switch'), statements.parseSwitchStatement);\n  statementsMap.set(registry.get('with'), statements.parseWithStatement);\n  statementsMap.set(registry.get('debugger'), withEventualSemiColon(statements.parseDebuggerStatement));\n  statementsMap.set(categories.Identifier, statements.parseExpressionOrLabeledStatement);\n\n  const isLexicallyReserved = registry.isReserved;\n\n  return Object.assign(registry, {\n    getInfix (token) {\n      return infixMap.get(token) || infixMap.get(token.type);\n    },\n    getPrefix (token) {\n      return prefixMap.get(token) || prefixMap.get(token.type);\n    },\n    getStatement (token) {\n      return statementsMap.get(token) || statementsMap.get(token.type);\n    },\n    hasPrefix (token) {\n      return prefixMap.has(token) || prefixMap.has(token.type);\n    },\n    hasInfix (token) {\n      return infixMap.has(token) || infixMap.has(token.type)\n    },\n    hasStatement (token) {\n      return statementsMap.has(token) || statementsMap.has(token.type);\n    },\n    isReserved (token) {\n      return isLexicallyReserved(token.value);\n    },\n    addUnaryOperator (precedence) {\n      return this.addPrefixOperator(precedence, expressions.parseUnaryExpression);\n    },\n    addBinaryOperator (precedence) {\n      return this.addPrefixOperator(precedence, expressions.parseBinaryExpression);\n    },\n    addPrefixOperator (precedence, parseFunction) {\n      throw new Error('not Implemented');\n      return {\n        asPunctuator (symbol) {\n        },\n        asReservedKeyWord (symbol) {\n        },\n        asIdentifierName (symbol) {\n        }\n      };\n    },\n    addInfixOperator (precendence, parseFunction) {\n      throw new Error('not Implemented');\n      return {\n        asPunctuator (symbol) {\n        },\n        asReservedKeyWord (symbol) {\n        },\n        asKeyword (symbol) {\n        }\n      };\n    },\n    addStatement (parseFunction) {\n      throw new Error('not Implemented');\n      return {\n        asReservedKeyWord (symbol) {\n        },\n        asKeyword (symbol) {\n        }\n      };\n    }\n  });\n};\n\nexport default ECMAScriptTokenRegistry();","import {lazyMapWith, lazyFilterWith} from \"../../tokenizer/src/utils\"\nimport {lexemes} from \"../../tokenizer/src/index\";\nimport {default as ECMAScriptTokens} from './tokens';\nimport {default as ECMAScriptScanner} from \"../../tokenizer/src/scanners\"\n\n//forward method of arrity one (more efficient than using spread operator on arguments)\nexport const forwardArrityOne = (receiver, stream, ...methods) => {\n  for (let m of methods) {\n    receiver[m] = (arg) => stream[m](arg);\n  }\n  return receiver;\n};\n\n//a buffered token stream\nconst tokenStream = ({scanner, tokenRegistry, filter, evaluate}) => {\n  const filterFunc = lazyFilterWith(filter || (t => t.type >= 4));\n  const map = lazyMapWith(evaluate || tokenRegistry.evaluate);\n  const filterMap = it => map(filterFunc(it));\n\n  //as generator(only consumed once)\n  return (code) => {\n\n    const stream = lexemes(code, scanner);\n    const iterator = filterMap(stream)[Symbol.iterator]();\n    const buffer = [];\n    let lastLoc;\n\n    const next = () => iterator.next();\n\n    return forwardArrityOne({\n      [Symbol.iterator] () {\n        return this;\n      },\n      lookAhead (offset = 0) {\n        if (buffer.length > offset) {\n          return buffer[offset]\n        }\n        buffer.push(next());\n        return this.lookAhead(offset);\n      },\n      eventually (expected) {\n        const {value: token, done} = this.lookAhead();\n        if (!done && expected === token) {\n          this.eat();\n          return true;\n        }\n        return false;\n      },\n      expect (expected) {\n        const nextToken = this.next();\n        if (expected !== nextToken.value) {\n          throw new Error(`Unexpected token: expected \"${expected.rawValue}\" but got \"${nextToken.value.rawValue}\"`);\n        }\n        return nextToken;\n      },\n      next () {\n        return buffer.length ? buffer.shift() : next();\n      },\n      eat (number = 1) {\n        const n = this.next();\n        number -= 1;\n        return number < 1 ? n : this.eat(number);\n      }\n    }, stream, 'allowRegexp', 'disallowRegexp');\n  };\n};\n\nexport default tokenStream({scanner: ECMAScriptScanner, tokenRegistry: ECMAScriptTokens});","import {default as stream, forwardArrityOne} from './source';\nimport {default as defaultRegistry} from './tokens';\nimport {parseModuleItemList, parseStatementList} from \"./statements\";\nimport {Program} from \"./ast\";\nimport {grammarParams} from \"./utils\";\n\nconst parserFactory = (tokens = defaultRegistry) => {\n\n  const getInfixPrecedence = operator => tokens.hasInfix(operator) ? tokens.getInfix(operator).precedence : -1;\n  const getPrefixPrecedence = operator => tokens.hasPrefix(operator) ? tokens.getPrefix(operator).precedence : -1;\n\n  const parseInfix = (parser, params, left, precedence) => {\n    parser.disallowRegexp(); //regexp as a literal is a \"prefix operator\" so a \"/\" in infix position is a div punctuator\n    const {value: operator} = parser.lookAhead();\n    if (!operator || precedence >= getInfixPrecedence(operator) || (operator === parser.get('in') && !(params & grammarParams.in))) {\n      return left;\n    }\n    parser.eat();\n    parser.allowRegexp();\n    const nextLeft = tokens.getInfix(operator).parse(parser, params, left, operator);\n    return parseInfix(parser, params, nextLeft, precedence);\n  };\n\n  return code => {\n    const tokenStream = stream(code);\n    const parser = Object.assign(forwardArrityOne({\n        expect: symbol => tokenStream.expect(tokens.get(symbol)), //more convenient to have it from the symbol\n        eventually: symbol => tokenStream.eventually(tokens.get(symbol)), //more convenient to have it from the symbol\n        getInfixPrecedence,\n        getPrefixPrecedence,\n        expression (precedence = -1, params = 0) {\n          parser.allowRegexp(); //regexp as literal is a \"prefix operator\"\n          const {value: token} = parser.lookAhead();\n          if (!tokens.hasPrefix(token)) {\n            return null; //todo maybe throw ?\n          }\n          const left = tokens.getPrefix(token).parse(parser, params);\n          return parseInfix(parser, params, left, precedence);\n        },\n        program (params = 0) {\n          return Program({\n            body: parseStatementList(parser, params)\n          });\n        },\n        module (params = 0) {\n          return Program({\n            sourceType: 'module',\n            body: parseModuleItemList(parser, params)\n          });\n        },\n      }, tokenStream, 'lookAhead', 'next', 'eat', 'allowRegexp', 'disallowRegexp'),\n      tokens);\n\n    return parser;\n  };\n\n};\n\nexport const parseModule = program => {\n  const parse = parserFactory();\n  return parse(program).module();\n};\n\nexport const parseExpression = (expression,precedence = -1, params = 0) => {\n  const parse = parserFactory();\n  return parse(expression).expression(precedence, params);\n};\n\nexport const parseScript = program => {\n  const parse = parserFactory();\n  return parse(program).program();\n};\n\nexport const parse = parseModule; //alias","import {parseScript} from \"../src/index\";\n\n// const fs = require('fs');\n// const path = require('path');\n// const utils = require('util');\n// const programPath = path.resolve(__dirname, '../fixtures/jquery.js');\n// const program = fs.readFileSync(programPath, {encoding: 'utf8'});\n\n// import {tokenize} from \"../../tokenizer/src/index\";\n//\n// const tokens = [...tokenize(program, {filter: _ => true})];\n//\n// const ws = tokens.filter(t => t.type === 0);\n// const lt = tokens.filter(t => t.type === 1);\n// const sc = tokens.filter(t => t.type === 2);\n// const mc = tokens.filter(t => t.type === 3);\n// const punc = tokens.filter(t => t.type === 4);\n// const id = tokens.filter(t => t.type === 5);\n//\n// console.log(`white space ${ws.length}`);\n// console.log(`line terminator ${lt.length}`);\n// console.log(`single line comment ${sc.length}`);\n// console.log(`multi line comment ${mc.length}`);\n// console.log(`punctuators ${punc.length}`);\n// console.log(`id ${id.length}`);\n\n\n// import {parse} from 'acorn';\n// const cherow = require('cherow');\n\n// const program = `function a(){foo++}`;\n\n// const ast = parseScript(program);\n// const ast = cherow.parse(program, {sourceType: 'script'});\n// const ast = acorn.parse(program,{sourceType:'script'});\n// console.log(utils.inspect(ast, {depth: null, colors: true}));\n\n/* browser  */\n(async function  () {\n   const resp = await fetch('../fixtures/jquery.js');\n   const text = await resp.text();\n\n  const ast = parseScript(text);\n   // console.log(ast);\n})();\n/* end browser */\n"],"names":["chars.SINGLE_LINE_COMMENT_START","chars.CHAR_STAR","chars.CHAR_SLASH","chars.MULTI_LINE_COMMENT_START","chars.CHAR_BACKSLASH","chars.CHAR_SINGLE_QUOTE","chars.CHAR_DOUBLE_QUOTE","chars.SPREAD","chars.CHAR_BRACE_CLOSE","chars.CHAR_DOT","chars.CHAR_LEFT_BRACKET","chars.CHAR_RIGHT_BRACKET","chars.CHAR_TEMPLATE_QUOTE","chars.CHAR_DOLLAR","chars.CHAR_BRACE_OPEN","scanner","tokenRegistry","ast.FunctionExpression","ast.MethodDefinition","ast.FunctionDeclaration","ast.ArrowFunctionExpression","ast.CallExpression","getNewParams","ast.ImportSpecifier","ast.ImportDefaultSpecifier","ast.ImportNamespaceSpecifier","ast.ImportDeclaration","ast.ExportAllDeclaration","ast.ExportSpecifier","ast.ExportNamedDeclaration","ast.ExportDefaultDeclaration","ast.BlockStatement","parseExpression","ast.VariableDeclarator","ast.VariableDeclaration","ast.EmptyStatement","ast.ExpressionStatement","ast.IfStatement","ast.DoWhileStatement","ast.WhileStatement","ast.ForStatement","ast.ForInStatement","ast.ForOfStatement","ast.SwitchCase","ast.SwitchStatement","ast.Identifier","ast.LabeledStatement","ast.BreakStatement","ast.ContinueStatement","ast.ReturnStatement","ast.WithStatement","ast.ThrowStatement","ast.TryStatement","ast.DebuggerStatement","ast.AssignmentPattern","ast.UnaryExpression","ast.ThisExpression","ast.Super","ast.Literal","ast.UpdateExpression","ast.NewExpression","ast.YieldExpression","ast.AssignmentExpression","ast.BinaryExpression","ast.LogicalExpression","ast.MemberExpression","ast.ConditionalExpression","ast.SequenceExpression","expressions.parseUnaryExpression","expressions.parseYieldExpression","expressions.parseUpdateExpressionAsPrefix","expressions.parseLiteralExpression","expressions.parseRegularExpressionLiteral","expressions.parseThisExpression","expressions.parseSuperExpression","expressions.parseNewExpression","expressions.parseGroupExpression","expressions.parseSequenceExpression","expressions.parseConditionalExpression","expressions.parseEqualAssignmentExpression","expressions.parseAssignmentExpression","expressions.parseBinaryExpression","expressions.parseMemberAccessExpression","expressions.parseLogicalExpression","expressions.parseUpdateExpression","statements.parseIfStatement","statements.parseEmptyStatement","statements.parseBlockStatement","statements.parseForStatement","statements.parseVariableDeclaration","statements.parseConstDeclaration","statements.parseLetDeclaration","statements.parseReturnStatement","statements.parseBreakStatement","statements.parseContinueStatement","statements.parseThrowStatement","statements.parseWhileStatement","statements.parseDoWhileStatement","statements.parseTryStatement","statements.parseSwitchStatement","statements.parseWithStatement","statements.parseDebuggerStatement","statements.parseExpressionOrLabeledStatement","ECMAScriptScanner","defaultRegistry"],"mappings":"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"}